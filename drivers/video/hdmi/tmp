diff ./Makefile /home/jaeseong.gim/android/kernel/drivers/video/hdmi/Makefile
10,11c10,11
< TDA_PLATFORM := ZOOMII
< # TDA_PLATFORM := OTHERS
---
> # TDA_PLATFORM := ZOOMII
> TDA_PLATFORM := OTHERS
13,14c13,14
< # TDA_HDCP := 0
< TDA_HDCP := TMFL_HDCP_SUPPORT
---
> TDA_HDCP := 0
> #TDA_HDCP := TMFL_HDCP_SUPPORT
21d20
< # EXTRA_CFLAGS += -DTMFL_NO_RTOS -DIRQ -DFORMAT_PC
34,35d32
< else
< EXTRA_CFLAGS += -DNO_HDCP
91c88,89
< obj-m += hdmitx.o
---
> #[jaeseong.gim]  m->y
> obj-y += hdmitx.o
Common subdirectories: ./comps and /home/jaeseong.gim/android/kernel/drivers/video/hdmi/comps
Only in .: i2c_test.c
Only in .: i2c_test.c.tmp
Common subdirectories: ./inc and /home/jaeseong.gim/android/kernel/drivers/video/hdmi/inc
diff ./release_note.txt /home/jaeseong.gim/android/kernel/drivers/video/hdmi/release_note.txt
9,33d8
< The release note gives all necessary detail for installation in Linux
< kernel and application tunning. Installation is Linux typical and does
< not require any HDMI background. A default video and audio setting is
< defined in hdmi_tx_init function. It can be changed at will.
< There is no porting to do, it is already provided in module. And the
< classical HDMI DevLib is embedded in it. But the UserManual is still
< usefull for customers who like to optimise the module according to
< their needs. If so, feedback is welcome. ;)
< Customers who like to drive the module from userland can do it using
< IOCTL. IOCTL maps the classical HDMI API. Using the WAIT_FRAME IOCTL,
< userland can catch HDMI events like Hot Plug Detect, RxSens or EDID.
< 
< So the two main functions the customer needs to take care are :
< - hdmi_tx_init
< - eventCallbackTx
< 
< For OMAP architecture, a DSS plugin is provided. So in order to activate
< HDMI (switch DSS to HDMI output) just prompt on target:
< echo "3" > /sys/power/vdd2_lock
< echo "1" > /sys/devices/platform/omapdss/display2/enabled
< And desactivate : 
< echo "0" > /sys/devices/platform/omapdss/display2/enabled
< 
< -------------------------------
< 
37d11
<   . HDCP linux module (on request only)
39,41d12
<   . TRANSMITTER_TDA998X_SW_UM_Devlib.pdf for HDMI TX API
<   . HDMI_CEC_User_Manual.pdf for HDMI CEC API
<   . this release note
46c17
<   . HDCP (on request only)
---
>   . HDCP
57d27
<   . driver/video/hdcp (only if hdcp is delivered)
65,73d34
< 
<  * V1.0: 2010, 1st Jully by Andre Lepine
<   . ATC compliancy
<   . BCaps polling during 5s when CCLK is not devided by 2
<   . It HPD+RxSens rebound (several changes before SW polling)
<   . EDID used for video mode switch (HDMI, DVI)
<   . blue screen before the HDCP authentification is passed
<   . TDA reset when removing Linux module
<   . hdcp_fail_status not used in TDA9981
124c85,92
< - Installation :
---
> - DV :
>   . How to create a DV :
>     -> update tda998xversion.h and set PATCH_LEVEL to 0
>     -> update release_note.txt
>     $>cd driver/video/hdmi
>     $>make -f MakeModules clean
>     $>cd ..
>     $>tar cvfj $DV_FOLDER/linux-hdmi-nxp-modules.vXYZ.tar.cvfj hdmi
125a94
> - Installation :
155d123
< 
173c141,150
< - FAQ :
---
> - Restriction :
>   . Remove IRQ flag in Makefile for timer based polling
>   . Add ZOOMII_PATCH to reverse clock edge in ZOOMII
>   . add TWL4030_HACK to get keypad handle and inject CEC::USER_CONTROL events
>   . omap_dss_driver might not be supported by kernel, then hdmi_enable
>     and hdmi_disable should be triggered by any other kernel means or
>     replaced by direct call from application using:
>     -->  ioctl(my_fd,TDA_IOCTL_SET_POWER,[tmPowerOn|tmPowerStandby]);
>   . HDCP can not be switch off dynamically with TDA_IOCTL_SET_HDCP but
>     removing nwolc.ko module
174a152,166
> - License :
>   . hdmitx and hdmicec modules are free software; you can redistribute
>     it and/or modify it under the terms of the GNU General Public License
>     as published by the Free Software Foundation, using version 2 of the License.
>     These modules are distributed in the hope that it will be useful, but
>     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
>     or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
>     for more details.
>   . nwolc module source code and any compilation or derivative thereof is
>     the proprietary information of NXP N.V. and is confidential in nature.
>     Under no circumstances is this software to be exposed to or placed under
>     an Open Source License of any type without the expressed written permission
>     of NXP N.V.
> 
> - FAQ :
182d173
< 
185d175
< 
189,215d178
< 
<   . I want "720p@60Hz" :
<     1- Line 860: Uncomment> /*    this->tda.setio.video_out.format = TMDL_HDMITX_VFMT_04_1280x720p_60Hz; */
<     2- Line 862: Comment> this->tda.setio.video_out.format = TMDL_HDMITX_VFMT_02_720x480p_60Hz;
<     3- Line 1051: Replace> video_720x480at60Hz_panel_timings with video_1280x720at60Hz_panel_timings
< 
<   . "Where can I find all video format definition ?":
<     in hdmi/comps/tmdlHdmiTx/inc/tmdlHdmiTx_Types.h
< 
<   . "Where can I find all audio format definition ?":
<     in hdmi/comps/tmdlHdmiTx/inc/tmdlHdmiTx_Types.h
< 
<   . "Where can I find all HDMI types definition ?":
<     in hdmi/comps/tmdlHdmiTx/inc/tmdlHdmiTx_Types.h
< 
<   . "Where can I find all power management types definition ?":
<     in hdmi/comps/tmdlHdmiTx/inc/tmdlHdmiTx_Types.h
< 
<   . "Where can I find all HDMI Tx API definition ?":
<     in hdmi/comps/tmdlHdmiTx/inc/tmdlHdmiTx_Functions.h
< 
<   . "Where can I find all HDMI CEC types definition ?":
<     in hdmi/comps/tmdlHdmiCec/inc/tmdlHdmiCec_Types.h
< 
<   . "Where can I find all HDMI CEC API definition ?":
<     in hdmi/comps/tmdlHdmiCec/inc/tmdlHdmiCec_Functions.h
< 
218d180
< 
221,222d182
< 
< 
225d184
< 
228d186
< 
236,298d193
<   . "How to install HDMI module ?"
<     See installation chapter above.
< 
<   . "HDCP is not supported"
<     Ask NXP to deliver you the proprietary HDCP module
< 
<   . "HDCP module does not work"
<     Ask NXP to provide you your customer seed number...
< 
<   . "How can I control the HDMI with my apps ?"
<     Use open("/dev/hdmitx") to get access to HdmiTx module.
<     Then use ioctl as described in tda998x_ioctl.h.
< 
<   . "How can I control CEC with my apps ?"
<     Use open("/dev/hdmicec") to get access to HdmiCec module.
<     Then use ioctl as described in tda998x_ioctl.h.
< 
<   . "How can my application get the HDMI event ?"
<     Create a dedicated incoming event thread in your apps and use ioctl WAIT_EVENT
< 
<   . "Is is mandatory to create an incoming event thread in my apps ?"
<     No if you don't care.
< 
<   . "Did I need to create some apps to make HDMI running ?"
<     No, you can modify hdmi_tx_init according to your needs and install the
<     modules in your init.rc. Hdmi will run automatically.
< 
< - Restriction :
< 
<   . Remove IRQ flag in Makefile for timer based polling
<   . Add ZOOMII_PATCH to reverse clock edge in ZOOMII
<   . add TWL4030_HACK to get keypad handle and inject CEC::USER_CONTROL events
<   . omap_dss_driver might not be supported by kernel, then hdmi_enable
<     and hdmi_disable should be triggered by any other kernel means or
<     replaced by direct call from application using:
<     -->  ioctl(my_fd,TDA_IOCTL_SET_POWER,[tmPowerOn|tmPowerStandby]);
<   . HDCP can not be switch off dynamically with TDA_IOCTL_SET_HDCP but
<     removing nwolc.ko module
< 
< - License :
< 
<   . hdmitx and hdmicec modules are free software; you can redistribute
<     it and/or modify it under the terms of the GNU General Public License
<     as published by the Free Software Foundation, using version 2 of the License.
<     These modules are distributed in the hope that it will be useful, but
<     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
<     or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
<     for more details.
<   . nwolc module source code and any compilation or derivative thereof is
<     the proprietary information of NXP N.V. and is confidential in nature.
<     Under no circumstances is this software to be exposed to or placed under
<     an Open Source License of any type without the expressed written permission
<     of NXP N.V.
< 
< - DV :
< 
<   . How to create a DV :
<     -> update tda998xversion.h and set PATCH_LEVEL to 0
<     -> update release_note.txt
<     $>cd driver/video/hdmi
<     $>make -f MakeModules clean
<     $>cd ..
<     $>tar cvfj $DV_FOLDER/linux-hdmi-nxp-modules.vXYZ.tar.cvfj hdmi
diff ./tda998x.c /home/jaeseong.gim/android/kernel/drivers/video/hdmi/tda998x.c
1,1956c1,2029
< /*****************************************************************************/
< /* Copyright (c) 2009 NXP Semiconductors BV                                  */
< /*                                                                           */
< /* This program is free software; you can redistribute it and/or modify      */
< /* it under the terms of the GNU General Public License as published by      */
< /* the Free Software Foundation, using version 2 of the License.             */
< /*                                                                           */
< /* This program is distributed in the hope that it will be useful,           */
< /* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
< /* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              */
< /* GNU General Public License for more details.                              */
< /*                                                                           */
< /* You should have received a copy of the GNU General Public License         */
< /* along with this program; if not, write to the Free Software               */
< /* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307       */
< /* USA.                                                                      */
< /*                                                                           */
< /*****************************************************************************/
< 
< #define _tx_c_
< 
< #include <linux/kernel.h>
< #include <linux/init.h>
< #include <linux/module.h>
< #include <linux/cdev.h>  
< #include <linux/fs.h>
< #include <linux/ioctl.h>
< #include <linux/i2c.h>
< #include <linux/delay.h>
< #include <linux/workqueue.h>
< #include <linux/interrupt.h>
< #include <asm/uaccess.h>
< #include <mach/gpio.h>
< #include <mach/display.h>
< 
< /* HDMI DevLib */
< #include "tmNxCompId.h"
< #include "tmdlHdmiTx_Types.h"
< #include "tmdlHdmiTx_Functions.h"
< 
< /* local */
< #include "tda998x_version.h"
< #include "tda998x.h"
< #include "tda998x_ioctl.h"
< 
< #ifdef ANDROID_DSS
< /* DSS hack */
< #include <../omap2/dss/dss.h>
< #endif
< 
< /*
<  *
<  * DEFINITION
<  * ----------
<  * LEVEL 0
<  *
<  */
< 
< /*
<  *  Global
<  */
< 
< tda_instance our_instance;
< static struct cdev our_cdev, *this_cdev=&our_cdev;
< #ifdef ANDROID_DSS
< static struct omap_video_timings video_640x480at60Hz_panel_timings = {
<    .x_res          = 640,
<    .y_res          = 480,
<    .pixel_clock    = 25175,
<    .hfp            = 16,
<    .hsw            = 96,
<    .hbp            = 48,
<    .vfp            = 10,
<    .vsw            = 2,
<    .vbp            = 33,
< };
< static struct omap_video_timings video_640x480at72Hz_panel_timings = {
<    .x_res          = 640,
<    .y_res          = 480,
<    .pixel_clock    = 31500,
<    .hfp            = 24,
<    .hsw            = 40,
<    .hbp            = 128,
<    .vfp            = 9,
<    .vsw            = 3,
<    .vbp            = 28,
< };
< static struct omap_video_timings video_720x480at60Hz_panel_timings = {
<    .x_res          = 720,
<    .y_res          = 480,
<    .pixel_clock    = 27027,
<    .hfp            = 16,
<    .hbp            = 60,
<    .hsw            = 62,
<    .vfp            = 9,
<    .vbp            = 30,
<    .vsw            = 6,
< };
< static struct omap_video_timings video_1280x720at50Hz_panel_timings = {
<    .x_res          = 1280,
<    .y_res          = 720,
<    .pixel_clock    = 74250,
< #ifdef ZOOMII_PATCH
<    .hfp            = 400,
<    .hbp            = 260,
< #else
<    .hfp            = 440,
<    .hbp            = 220,
< #endif
<    .hsw            = 40,
<    .vfp            = 5,
<    .vbp            = 20,
<    .vsw            = 5,
< };
< static struct omap_video_timings video_1280x720at60Hz_panel_timings = {
<    .x_res          = 1280,
<    .y_res          = 720,
<    .pixel_clock    = 74250,
< #ifdef ZOOMII_PATCH
<    .hfp            = 70,
<    .hbp            = 260,
< #else
<    .hfp            = 110,
<    .hbp            = 220,
< #endif
<    .hsw            = 40,
<    .vfp            = 5,
<    .vbp            = 20,
<    .vsw            = 5,
< };
< static struct omap_video_timings video_1920x1080at50Hz_panel_timings = {
<    .x_res          = 1920,
<    .y_res          = 1080,
<    .pixel_clock    = 148500, /* 2640 x 1125 x 50 /2 */
< #ifdef ZOOMII_PATCH
<    .hfp            = 488,
<    .hbp            = 188,
< #else
<    .hfp            = 528,
<    .hbp            = 148,
< #endif
<    .hsw            = 44,
<    .vfp            = 4,
<    .vbp            = 36,
<    .vsw            = 5,
< };
< static struct omap_video_timings video_800x480at60Hz_panel_timings = {
<    /*    .x_res = 800 /\* 1280 *\/, */
<    /*    .y_res = 480 /\* 720 *\/, */
<    /*    .pixel_clock = 21800 /\* 21800 23800 25700 *\/, */
<    .x_res = 800,
<    .y_res = 480,
<    .pixel_clock = 21800,
<    .hfp = 6,
<    .hsw = 1,
<    .hbp = 4,
<    .vfp = 3,
<    .vsw = 1,
<    .vbp = 4,
< };
< 
< struct omap_dss_device *sysdss;
< #endif
< 
< /* #define HDCP_TEST 1 */
< #ifdef HDCP_TEST
< /* TEST */
< int test = 0;
< #endif
< 
< /*
<  *  Module params
<  */
< 
< static int param_verbose=0,param_major=0,param_minor=0;
< module_param_named(verbose,param_verbose,int,S_IRUGO | S_IWUSR);
< MODULE_PARM_DESC(verbose, "Make the driver verbose");
< module_param_named(major, param_major, int, S_IRUGO);
< MODULE_PARM_DESC(major, "The major number of the device mapper");
< 
< /*
<  *
<  * TOOLBOX
<  * -------
<  * LEVEL 1
<  *
<  * - i2c read/write
<  * - chip Id check
<  * - i2c client info
<  * 
<  */
< 
< 
< /* 
<  *  no mknod nor busybox, so patch it
<  */
< /* static int create_dev(char *name, dev_t dev) */
< /* { */
< /*    sys_unlink(name); */
< /*    return sys_mknod((const char __user *) name, S_IFCHR|0666 /\* S_IFCHR | S_IRUSR | S_IWUSR *\/, new_encode_dev(dev)); */
< /* } */
< 
< /* 
<  *  Get main and unique I2C Client driver handle
<  */
< struct i2c_client *GetThisI2cClient(void)
< {
<    tda_instance *this=&our_instance;
<    return this->driver.i2c_client;
< }
< 
< /*
<  * error handling
<  */
< char *hdmi_tx_err_string(int err)
< {
<    switch (err & 0x0FFF)
<       {
<       case TM_ERR_COMPATIBILITY: {return "SW Interface compatibility";break;}
<       case TM_ERR_MAJOR_VERSION: {return "SW Major Version error";break;}
<       case TM_ERR_COMP_VERSION: {return "SW component version error";break;}
<       case TM_ERR_BAD_UNIT_NUMBER: {return "Invalid device unit number";break;}
<       case TM_ERR_BAD_INSTANCE: {return "Bad input instance value  ";break;}
<       case TM_ERR_BAD_HANDLE: {return "Bad input handle";break;}
<       case TM_ERR_BAD_PARAMETER: {return "Invalid input parameter";break;}
<       case TM_ERR_NO_RESOURCES: {return "Resource is not available ";break;}
<       case TM_ERR_RESOURCE_OWNED: {return "Resource is already in use";break;}
<       case TM_ERR_RESOURCE_NOT_OWNED: {return "Caller does not own resource";break;}
<       case TM_ERR_INCONSISTENT_PARAMS: {return "Inconsistent input params";break;}
<       case TM_ERR_NOT_INITIALIZED: {return "Component is not initialised";break;}
<       case TM_ERR_NOT_SUPPORTED: {return "Function is not supported";break;}
<       case TM_ERR_INIT_FAILED: {return "Initialization failed";break;}
<       case TM_ERR_BUSY: {return "Component is busy";break;}
<       case TMDL_ERR_DLHDMITX_I2C_READ: {return "Read error";break;}
<       case TMDL_ERR_DLHDMITX_I2C_WRITE: {return "Write error";break;}
<       case TM_ERR_FULL: {return "Queue is full";break;}
<       case TM_ERR_NOT_STARTED: {return "Function is not started";break;}
<       case TM_ERR_ALREADY_STARTED: {return "Function is already starte";break;}
<       case TM_ERR_ASSERTION: {return "Assertion failure";break;}
<       case TM_ERR_INVALID_STATE: {return "Invalid state for function";break;}
<       case TM_ERR_OPERATION_NOT_PERMITTED: {return "Corresponds to posix EPERM";break;}
<       case TMDL_ERR_DLHDMITX_RESOLUTION_UNKNOWN: {return "Bad format";break;}
<       case TM_OK: {return "OK";break;}
<       default : {printk(KERN_INFO "(err:%x) ",err);return "unknown";break;}
<       }
< }
< 
< static char *tda_spy_event(int event)
< {
<    switch (event)
<       {
<       case TMDL_HDMITX_HDCP_ACTIVE: {return "HDCP active";break;}
<       case TMDL_HDMITX_HDCP_INACTIVE: {return "HDCP inactive";break;}
<       case TMDL_HDMITX_HPD_ACTIVE: {return "HPD active";break;}
<       case TMDL_HDMITX_HPD_INACTIVE: {return "HPD inactive";break;}
<       case TMDL_HDMITX_RX_KEYS_RECEIVED: {return "Rx keys received";break;}
<       case TMDL_HDMITX_RX_DEVICE_ACTIVE: {return "Rx device active";break;}
<       case TMDL_HDMITX_RX_DEVICE_INACTIVE: {return "Rx device inactive";break;}
<       case TMDL_HDMITX_EDID_RECEIVED: {return "EDID received";break;}
<       case TMDL_HDMITX_VS_RPT_RECEIVED: {return "VS interrupt has been received";break;}
< /*       case TMDL_HDMITX_B_STATUS: {return "TX received BStatus";break;} */ 
< #if defined (TMFL_TDA19989) || defined (TMFL_TDA9984) 
<       case TMDL_HDMITX_DEBUG_EVENT_1: {return "DEBUG_EVENT_1";break;}
< #endif
<       default : {return "Unkonwn event";break;}
<       }
< }
< #if defined (TMFL_TDA19989) || defined (TMFL_TDA9984) 
< static char *tda_spy_hsdc_fail_status(int fail)
< {
<    switch (fail)
<       {
<       case TMDL_HDMITX_HDCP_OK: {return "ok";break;}
<       case  TMDL_HDMITX_HDCP_BKSV_RCV_FAIL: {return "Source does not receive Sink BKsv ";break;}
<       case TMDL_HDMITX_HDCP_BKSV_CHECK_FAIL: {return "BKsv does not contain 20 zeros and 20 ones";break;}
<       case TMDL_HDMITX_HDCP_BCAPS_RCV_FAIL: {return "Source does not receive Sink Bcaps";break;}
<       case TMDL_HDMITX_HDCP_AKSV_SEND_FAIL: {return "Source does not send AKsv";break;}
<       case TMDL_HDMITX_HDCP_R0_RCV_FAIL: {return "Source does not receive R'0";break;}
<       case TMDL_HDMITX_HDCP_R0_CHECK_FAIL: {return "R0 = R'0 check fail";break;}
<       case TMDL_HDMITX_HDCP_BKSV_NOT_SECURE: {return "bksv not secure";break;}
<       case TMDL_HDMITX_HDCP_RI_RCV_FAIL: {return "Source does not receive R'i";break;}
<       case TMDL_HDMITX_HDCP_RPT_RI_RCV_FAIL: {return "Source does not receive R'i repeater mode";break;}
<       case TMDL_HDMITX_HDCP_RI_CHECK_FAIL: {return "RI = R'I check fail";break;}
<       case TMDL_HDMITX_HDCP_RPT_RI_CHECK_FAIL: {return "RI = R'I check fail repeater mode";break;}
<       case TMDL_HDMITX_HDCP_RPT_BCAPS_RCV_FAIL: {return "Source does not receive Sink Bcaps repeater mode";break;}
<       case TMDL_HDMITX_HDCP_RPT_BCAPS_READY_TIMEOUT: {return "bcaps ready timeout";break;}
<       case TMDL_HDMITX_HDCP_RPT_V_RCV_FAIL: {return "Source does not receive V";break;}
<       case TMDL_HDMITX_HDCP_RPT_BSTATUS_RCV_FAIL: {return "Source does not receive BSTATUS repeater mode";break;}
<       case TMDL_HDMITX_HDCP_RPT_KSVLIST_RCV_FAIL: {return "Source does not receive Ksv list in repeater mode";break;}
<       case TMDL_HDMITX_HDCP_RPT_KSVLIST_NOT_SECURE: {return "ksvlist not secure";break;}
<       default: {return "";break;}
<       }
< }
< 
< static char *tda_spy_hdcp_status(int status)
< {
<    switch (status)
<       {
<       case TMDL_HDMITX_HDCP_CHECK_NOT_STARTED: {return "Check not started";break;}
<       case TMDL_HDMITX_HDCP_CHECK_IN_PROGRESS: {return "No failures, more to do";break;}
<       case TMDL_HDMITX_HDCP_CHECK_PASS: {return "Final check has passed";break;}
<       case TMDL_HDMITX_HDCP_CHECK_FAIL_FIRST: {return "First check failure code\nDriver not AUTHENTICATED";break;}
<       case TMDL_HDMITX_HDCP_CHECK_FAIL_DEVICE_T0: {return "A T0 interrupt occurred";break;}
<       case TMDL_HDMITX_HDCP_CHECK_FAIL_DEVICE_RI: {return "Device RI changed";break;}
<       case TMDL_HDMITX_HDCP_CHECK_FAIL_DEVICE_FSM: {return "Device FSM not 10h";break;}
<       default : {return "Unknown hdcp status";break;}
<       }
< 
< }
< #endif
< 
< static char *tda_spy_sink(int sink)
< {
<    switch (sink)
<       {
<       case TMDL_HDMITX_SINK_DVI: {return "DVI";break;}
<       case TMDL_HDMITX_SINK_HDMI: {return "HDMI";break;}
<       case TMDL_HDMITX_SINK_EDID: {return "As currently defined in EDID";break;}
<       default : {return "Unkonwn sink";break;}
<       }
< }
< 
< #if defined (TMFL_TDA19989) || defined (TMFL_TDA9984) 
< static char *tda_spy_aspect_ratio(int ar)
< {
<    switch (ar)
<       {
<       case TMDL_HDMITX_P_ASPECT_RATIO_UNDEFINED: {return "Undefined picture aspect rati";break;}
<       case TMDL_HDMITX_P_ASPECT_RATIO_6_5: {return "6:5 picture aspect ratio (PAR";break;}
<       case TMDL_HDMITX_P_ASPECT_RATIO_5_4: {return "5:4 PA";break;}
<       case TMDL_HDMITX_P_ASPECT_RATIO_4_3: {return "4:3 PA";break;}
<       case TMDL_HDMITX_P_ASPECT_RATIO_16_10: {return "16:10 PA";break;}
<       case TMDL_HDMITX_P_ASPECT_RATIO_5_3: {return "5:3 PA";break;}
<       case TMDL_HDMITX_P_ASPECT_RATIO_16_9: {return "16:9 PA";break;}
<       case TMDL_HDMITX_P_ASPECT_RATIO_9_5: {return "9:5 PA";break;}
<       default : {return "Unknown aspect ratio";break;}
<       }
< }
< 
< #if 0 /* no more used */
< static char *tda_spy_edid_status(int status)
< {
<    switch (status)
<       {
<       case TMDL_HDMITX_EDID_READ: {return "All blocks read";break;}
<       case TMDL_HDMITX_EDID_READ_INCOMPLETE: {return "All blocks read OK but buffer too small to return all of the";break;}
<       case TMDL_HDMITX_EDID_ERROR_CHK_BLOCK_0: {return "Block 0 checksum erro";break;}
<       case TMDL_HDMITX_EDID_ERROR_CHK: {return "Block 0 OK, checksum error in one or more other block";break;}
<       case TMDL_HDMITX_EDID_NOT_READ: {return "EDID not read";break;}
<       case TMDL_HDMITX_EDID_STATUS_INVALID: {return "Invalid ";break;}
<       default : {return "Unknown edid status";break;}
<       }
< }
< #endif
< 
< static char *tda_spy_vfmt(int fmt)
< {
<    switch (fmt)
<       {
<       case TMDL_ERR_DLHDMITX_COMPATIBILITY: {return "SW Interface compatibility";break;}
<       case TMDL_ERR_DLHDMITX_MAJOR_VERSION: {return "SW Major Version error";break;}
< 
<       case TMDL_HDMITX_VFMT_NULL: {return "Not a valid format...";break;}
<       case TMDL_HDMITX_VFMT_01_640x480p_60Hz: {return "Format 01 640  x 480p  60Hz";break;}
<       case TMDL_HDMITX_VFMT_02_720x480p_60Hz: {return "Format 02 720  x 480p  60Hz";break;}
<       case TMDL_HDMITX_VFMT_03_720x480p_60Hz: {return "Format 03 720  x 480p  60Hz";break;}
<       case TMDL_HDMITX_VFMT_04_1280x720p_60Hz: {return "Format 04 1280 x 720p  60Hz";break;}
<       case TMDL_HDMITX_VFMT_05_1920x1080i_60Hz: {return "Format 05 1920 x 1080i 60Hz";break;}
<       case TMDL_HDMITX_VFMT_06_720x480i_60Hz: {return "Format 06 720  x 480i  60Hz";break;}
<       case TMDL_HDMITX_VFMT_07_720x480i_60Hz: {return "Format 07 720  x 480i  60Hz";break;}
<       case TMDL_HDMITX_VFMT_08_720x240p_60Hz: {return "Format 08 720  x 240p  60Hz";break;}
<       case TMDL_HDMITX_VFMT_09_720x240p_60Hz: {return "Format 09 720  x 240p  60Hz";break;}
<       case TMDL_HDMITX_VFMT_10_720x480i_60Hz: {return "Format 10 720  x 480i  60Hz";break;}
<       case TMDL_HDMITX_VFMT_11_720x480i_60Hz: {return "Format 11 720  x 480i  60Hz";break;}
<       case TMDL_HDMITX_VFMT_12_720x240p_60Hz: {return "Format 12 720  x 240p  60Hz";break;}
<       case TMDL_HDMITX_VFMT_13_720x240p_60Hz: {return "Format 13 720  x 240p  60Hz";break;}
<       case TMDL_HDMITX_VFMT_14_1440x480p_60Hz: {return "Format 14 1440 x 480p  60Hz";break;}
<       case TMDL_HDMITX_VFMT_15_1440x480p_60Hz: {return "Format 15 1440 x 480p  60Hz";break;}
<       case TMDL_HDMITX_VFMT_16_1920x1080p_60Hz: {return "Format 16 1920 x 1080p 60Hz";break;}
<       case TMDL_HDMITX_VFMT_17_720x576p_50Hz: {return "Format 17 720  x 576p  50Hz";break;}
<       case TMDL_HDMITX_VFMT_18_720x576p_50Hz: {return "Format 18 720  x 576p  50Hz";break;}
<       case TMDL_HDMITX_VFMT_19_1280x720p_50Hz: {return "Format 19 1280 x 720p  50Hz";break;}
<       case TMDL_HDMITX_VFMT_20_1920x1080i_50Hz: {return "Format 20 1920 x 1080i 50Hz";break;}
<       case TMDL_HDMITX_VFMT_21_720x576i_50Hz: {return "Format 21 720  x 576i  50Hz";break;}
<       case TMDL_HDMITX_VFMT_22_720x576i_50Hz: {return "Format 22 720  x 576i  50Hz";break;}
<       case TMDL_HDMITX_VFMT_23_720x288p_50Hz: {return "Format 23 720  x 288p  50Hz";break;}
<       case TMDL_HDMITX_VFMT_24_720x288p_50Hz: {return "Format 24 720  x 288p  50Hz";break;}
<       case TMDL_HDMITX_VFMT_25_720x576i_50Hz: {return "Format 25 720  x 576i  50Hz";break;}
<       case TMDL_HDMITX_VFMT_26_720x576i_50Hz: {return "Format 26 720  x 576i  50Hz";break;}
<       case TMDL_HDMITX_VFMT_27_720x288p_50Hz: {return "Format 27 720  x 288p  50Hz";break;}
<       case TMDL_HDMITX_VFMT_28_720x288p_50Hz: {return "Format 28 720  x 288p  50Hz";break;}
<       case TMDL_HDMITX_VFMT_29_1440x576p_50Hz: {return "Format 29 1440 x 576p  50Hz";break;}
<       case TMDL_HDMITX_VFMT_30_1440x576p_50Hz: {return "Format 30 1440 x 576p  50Hz";break;}
<       case TMDL_HDMITX_VFMT_31_1920x1080p_50Hz: {return "Format 31 1920 x 1080p 50Hz";break;}
<       case TMDL_HDMITX_VFMT_32_1920x1080p_24Hz: {return "Format 32 1920 x 1080p 24Hz";break;}
<       case TMDL_HDMITX_VFMT_33_1920x1080p_25Hz: {return "Format 33 1920 x 1080p 25Hz";break;}
<       case TMDL_HDMITX_VFMT_34_1920x1080p_30Hz: {return "Format 34 1920 x 1080p 30Hz";break;}
<       case TMDL_HDMITX_VFMT_TV_NUM: {return "Number of TV formats & null";break;}
<       case TMDL_HDMITX_VFMT_PC_MIN: {return "Lowest valid PC format";break;}
<       case TMDL_HDMITX_VFMT_PC_800x600p_60Hz: {return "PC format 129";break;}
<       case TMDL_HDMITX_VFMT_PC_1152x960p_60Hz: {return "PC format 130";break;}
<       case TMDL_HDMITX_VFMT_PC_1024x768p_60Hz: {return "PC format 131";break;}
<       case TMDL_HDMITX_VFMT_PC_1280x768p_60Hz: {return "PC format 132";break;}
<       case TMDL_HDMITX_VFMT_PC_1280x1024p_60Hz: {return "PC format 133";break;}
<       case TMDL_HDMITX_VFMT_PC_1360x768p_60Hz: {return "PC format 134";break;}
<       case TMDL_HDMITX_VFMT_PC_1400x1050p_60Hz: {return "PC format 135";break;}
<       case TMDL_HDMITX_VFMT_PC_1600x1200p_60Hz: {return "PC format 136";break;}
<       case TMDL_HDMITX_VFMT_PC_1024x768p_70Hz: {return "PC format 137";break;}
<       case TMDL_HDMITX_VFMT_PC_640x480p_72Hz: {return "PC format 138";break;}
<       case TMDL_HDMITX_VFMT_PC_800x600p_72Hz: {return "PC format 139";break;}
<       case TMDL_HDMITX_VFMT_PC_640x480p_75Hz: {return "PC format 140";break;}
<       case TMDL_HDMITX_VFMT_PC_1024x768p_75Hz: {return "PC format 141";break;}
<       case TMDL_HDMITX_VFMT_PC_800x600p_75Hz: {return "PC format 142";break;}
<       case TMDL_HDMITX_VFMT_PC_1024x864p_75Hz: {return "PC format 143";break;}
<       case TMDL_HDMITX_VFMT_PC_1280x1024p_75Hz: {return "PC format 144";break;}
<       case TMDL_HDMITX_VFMT_PC_640x350p_85Hz: {return "PC format 145";break;}
<       case TMDL_HDMITX_VFMT_PC_640x400p_85Hz: {return "PC format 146";break;}
<       case TMDL_HDMITX_VFMT_PC_720x400p_85Hz: {return "PC format 147";break;}
<       case TMDL_HDMITX_VFMT_PC_640x480p_85Hz: {return "PC format 148";break;}
<       case TMDL_HDMITX_VFMT_PC_800x600p_85Hz: {return "PC format 149";break;}
<       case TMDL_HDMITX_VFMT_PC_1024x768p_85Hz: {return "PC format 150";break;}
<       case TMDL_HDMITX_VFMT_PC_1152x864p_85Hz: {return "PC format 151";break;}
<       case TMDL_HDMITX_VFMT_PC_1280x960p_85Hz: {return "PC format 152";break;}
<       case TMDL_HDMITX_VFMT_PC_1280x1024p_85Hz: {return "PC format 153";break;}
<       case TMDL_HDMITX_VFMT_PC_1024x768i_87Hz: {return "PC format 154";break;}
<       default : {return "Unknown video format";break;}
<       }
< }
< #endif
< 
< static char *tda_ioctl(int io)
< {
<    switch (io)
<       {
<       case TDA_VERBOSE_ON_CMD: {return "TDA_VERBOSE_ON_CMD";break;}
<       case TDA_VERBOSE_OFF_CMD: {return "TDA_VERBOSE_OFF_CMD";break;}
<       case TDA_BYEBYE_CMD: {return "TDA_BYEBYE_CMD";break;}
<       case TDA_GET_SW_VERSION_CMD: {return "TDA_GET_SW_VERSION_CMD";break;}
<       case TDA_SET_POWER_CMD: {return "TDA_SET_POWER_CMD";break;}
<       case TDA_GET_POWER_CMD: {return "TDA_GET_POWER_CMD";break;}
<       case TDA_SETUP_CMD: {return "TDA_SETUP_CMD";break;}
<       case TDA_GET_SETUP_CMD: {return "TDA_GET_SETUP_CMD";break;}
<       case TDA_WAIT_EVENT_CMD: {return "TDA_WAIT_EVENT_CMD";break;}
<       case TDA_ENABLE_EVENT_CMD: {return "TDA_ENABLE_EVENT_CMD";break;}
<       case TDA_DISABLE_EVENT_CMD: {return "TDA_DISABLE_EVENT_CMD";break;}
<       case TDA_GET_VIDEO_SPEC_CMD: {return "TDA_GET_VIDEO_SPEC_CMD";break;}
<       case TDA_SET_INPUT_OUTPUT_CMD: {return "TDA_SET_INPUT_OUTPUT_CMD";break;}
<       case TDA_SET_AUDIO_INPUT_CMD: {return "TDA_SET_AUDIO_INPUT_CMD";break;}
<       case TDA_SET_VIDEO_INFOFRAME_CMD: {return "TDA_SET_VIDEO_INFOFRAME_CMD";break;}
<       case TDA_SET_AUDIO_INFOFRAME_CMD: {return "TDA_SET_AUDIO_INFOFRAME_CMD";break;}
<       case TDA_SET_ACP_CMD: {return "TDA_SET_ACP_CMD";break;}
<       case TDA_SET_GCP_CMD: {return "TDA_SET_GCP_CMD";break;}
<       case TDA_SET_ISRC1_CMD: {return "TDA_SET_ISRC1_CMD";break;}
<       case TDA_SET_ISRC2_CMD: {return "TDA_SET_ISRC2_CMD";break;}
<       case TDA_SET_MPS_INFOFRAME_CMD: {return "TDA_SET_MPS_INFOFRAME_CMD";break;}
<       case TDA_SET_SPD_INFOFRAME_CMD: {return "TDA_SET_SPD_INFOFRAME_CMD";break;}
<       case TDA_SET_VS_INFOFRAME_CMD: {return "TDA_SET_VS_INFOFRAME_CMD";break;}
<       case TDA_SET_AUDIO_MUTE_CMD: {return "TDA_SET_AUDIO_MUTE_CMD";break;}
<       case TDA_RESET_AUDIO_CTS_CMD: {return "TDA_RESET_AUDIO_CTS_CMD";break;}
<       case TDA_GET_EDID_STATUS_CMD: {return "TDA_GET_EDID_STATUS_CMD";break;}
<       case TDA_GET_EDID_AUDIO_CAPS_CMD: {return "TDA_GET_EDID_AUDIO_CAPS_CMD";break;}
<       case TDA_GET_EDID_VIDEO_CAPS_CMD: {return "TDA_GET_EDID_VIDEO_CAPS_CMD";break;}
<       case TDA_GET_EDID_VIDEO_PREF_CMD: {return "TDA_GET_EDID_VIDEO_PREF_CMD";break;}
<       case TDA_GET_EDID_SINK_TYPE_CMD: {return "TDA_GET_EDID_SINK_TYPE_CMD";break;}
<       case TDA_GET_EDID_SOURCE_ADDRESS_CMD: {return "TDA_GET_EDID_SOURCE_ADDRESS_CMD";break;}
<       case TDA_SET_GAMMUT_CMD: {return "TDA_SET_GAMMUT_CMD";break;}
<       case TDA_GET_EDID_DTD_CMD: {return "TDA_GET_EDID_DTD_CMD";break;}
<       case TDA_GET_EDID_MD_CMD: {return "TDA_GET_EDID_MD_CMD";break;}
<       case TDA_GET_EDID_TV_ASPECT_RATIO_CMD: {return "TDA_GET_EDID_TV_ASPECT_RATIO_CMD";break;}
<       case TDA_GET_EDID_LATENCY_CMD: {return "TDA_GET_EDID_LATENCY_CMD";break;}
<       default : {return "unknown";break;}
<       }
< 
< 
< }
< 
< #if defined (TMFL_TDA19989) || defined (TMFL_TDA9984) 
< /*
<  *  
<  */
< static int tda_spy(int verbose)
< {
<    tda_instance *this=&our_instance;
<    int i,err=0;
< 
<    if (!verbose) {
<       return err;
<    }
< 
<    printk(KERN_INFO "\n<edid video caps>\n");
<    this->tda.edid_video_caps.max=EXAMPLE_MAX_SVD;
<    TRY(tmdlHdmiTxGetEdidVideoCaps(this->tda.instance,              \
<                                   this->tda.edid_video_caps.desc, \
<                                   this->tda.edid_video_caps.max,      \
<                                   &this->tda.edid_video_caps.written, \
<                                   &this->tda.edid_video_caps.flags));
<    printk(KERN_INFO "written:%d\n",this->tda.edid_video_caps.written);
<    printk(KERN_INFO "flags:0X%x\n",this->tda.edid_video_caps.flags);
<    if (this->tda.edid_video_caps.written > this->tda.edid_video_caps.max) {
<       printk(KERN_ERR "get %d video caps but was waiting for %d\n", \
<              this->tda.edid_video_caps.written,                     \
<              this->tda.edid_video_caps.max); 
<       this->tda.edid_video_caps.written = this->tda.edid_video_caps.max;
<    }
<    for(i=0; i<this->tda.edid_video_caps.written;i++) {
<       printk(KERN_INFO "videoFormat:%s\n",tda_spy_vfmt(this->tda.edid_video_caps.desc[i].videoFormat));
<       printk(KERN_INFO "nativeVideoFormat:%s\n",(this->tda.edid_video_caps.desc[i].nativeVideoFormat?"yes":"no"));
<    }
< 
<    printk(KERN_INFO "\n<edid video timings>\n");
<    TRY(tmdlHdmiTxGetEdidVideoPreferred(this->tda.instance, \
<                                        &this->tda.edid_video_timings));
<    printk(KERN_INFO "Pixel Clock/10 000:%d\n",this->tda.edid_video_timings.pixelClock);
<    printk(KERN_INFO "Horizontal Active Pixels:%d\n",this->tda.edid_video_timings.hActivePixels);
<    printk(KERN_INFO "Horizontal Blanking Pixels:%d\n",this->tda.edid_video_timings.hBlankPixels);
<    printk(KERN_INFO "Vertical Active Lines:%d\n",this->tda.edid_video_timings.vActiveLines);
<    printk(KERN_INFO "Vertical Blanking Lines:%d\n",this->tda.edid_video_timings.vBlankLines);
<    printk(KERN_INFO "Horizontal Sync Offset:%d\n",this->tda.edid_video_timings.hSyncOffset);
<    printk(KERN_INFO "Horiz. Sync Pulse Width:%d\n",this->tda.edid_video_timings.hSyncWidth);
<    printk(KERN_INFO "Vertical Sync Offset:%d\n",this->tda.edid_video_timings.vSyncOffset);
<    printk(KERN_INFO "Vertical Sync Pulse Width:%d\n",this->tda.edid_video_timings.vSyncWidth);
<    printk(KERN_INFO "Horizontal Image Size:%d\n",this->tda.edid_video_timings.hImageSize);
<    printk(KERN_INFO "Vertical Image Size:%d\n",this->tda.edid_video_timings.vImageSize);
<    printk(KERN_INFO "Horizontal Border:%d\n",this->tda.edid_video_timings.hBorderPixels);
<    printk(KERN_INFO "Vertical Border:%d\n",this->tda.edid_video_timings.vBorderPixels);
<    printk(KERN_INFO "Interlace/sync info:%x\n",this->tda.edid_video_timings.flags);
< 
<    printk(KERN_INFO "\n<sink type>\n");
<    TRY(tmdlHdmiTxGetEdidSinkType(this->tda.instance,    \
<                                  &this->tda.setio.sink));
<    printk(KERN_INFO "%s\n",tda_spy_sink(this->tda.setio.sink));
<    printk(KERN_INFO "\n<source address>\n");
<    TRY(tmdlHdmiTxGetEdidSourceAddress(this->tda.instance,   \
<                                       &this->tda.src_address));
<    printk(KERN_INFO "%x\n",this->tda.src_address);
<    printk(KERN_INFO "\n<detailled timing descriptors>\n");
<    this->tda.edid_dtd.max=EXAMPLE_MAX_SVD;
<    TRY(tmdlHdmiTxGetEdidDetailledTimingDescriptors(this->tda.instance,  \
<                                                    this->tda.edid_dtd.desc, \
<                                                    this->tda.edid_dtd.max, \
<                                                    &this->tda.edid_dtd.written));
<    printk(KERN_INFO "Interlace/sync info:%x\n",this->tda.edid_dtd.desc[i].flags);
<    printk(KERN_INFO "written:%d\n",this->tda.edid_dtd.written);
<    if (this->tda.edid_dtd.written > this->tda.edid_dtd.max) {
<       printk(KERN_ERR "get %d video caps but was waiting for %d\n", \
<              this->tda.edid_dtd.written,                     \
<              this->tda.edid_dtd.max); 
<       this->tda.edid_dtd.written = this->tda.edid_dtd.max;
<    }
<    for(i=0; i<this->tda.edid_dtd.written;i++) {
<       printk(KERN_INFO "Pixel Clock/10 000:%d\n",this->tda.edid_dtd.desc[i].pixelClock);
<       printk(KERN_INFO "Horizontal Active Pixels:%d\n",this->tda.edid_dtd.desc[i].hActivePixels);
<       printk(KERN_INFO "Horizontal Blanking Pixels:%d\n",this->tda.edid_dtd.desc[i].hBlankPixels);
<       printk(KERN_INFO "Vertical Active Lines:%d\n",this->tda.edid_dtd.desc[i].vActiveLines);
<       printk(KERN_INFO "Vertical Blanking Lines:%d\n",this->tda.edid_dtd.desc[i].vBlankLines);
<       printk(KERN_INFO "Horizontal Sync Offset:%d\n",this->tda.edid_dtd.desc[i].hSyncOffset);
<       printk(KERN_INFO "Horiz. Sync Pulse Width:%d\n",this->tda.edid_dtd.desc[i].hSyncWidth);
<       printk(KERN_INFO "Vertical Sync Offset:%d\n",this->tda.edid_dtd.desc[i].vSyncOffset);
<       printk(KERN_INFO "Vertical Sync Pulse Width:%d\n",this->tda.edid_dtd.desc[i].vSyncWidth);
<       printk(KERN_INFO "Horizontal Image Size:%d\n",this->tda.edid_dtd.desc[i].hImageSize);
<       printk(KERN_INFO "Vertical Image Size:%d\n",this->tda.edid_dtd.desc[i].vImageSize);
<       printk(KERN_INFO "Horizontal Border:%d\n",this->tda.edid_dtd.desc[i].hBorderPixels);
<       printk(KERN_INFO "Vertical Border:%d\n",this->tda.edid_dtd.desc[i].vBorderPixels);
<    }
< 
<    printk(KERN_INFO "\n<monitor descriptors>\n");
<    this->tda.edid_md.max=EXAMPLE_MAX_SVD;
<    TRY(tmdlHdmiTxGetEdidMonitorDescriptors(this->tda.instance,  \
<                                            this->tda.edid_md.desc1,    \
<                                            this->tda.edid_md.desc2,    \
<                                            this->tda.edid_md.other,    \
<                                            this->tda.edid_md.max,       \
<                                            &this->tda.edid_md.written));
<    printk(KERN_INFO "written:%d\n",this->tda.edid_md.written);
<    if (this->tda.edid_md.written > this->tda.edid_md.max) {
<       printk(KERN_ERR "get %d video caps but was waiting for %d\n", \
<              this->tda.edid_md.written,                     \
<              this->tda.edid_md.max); 
<       this->tda.edid_md.written = this->tda.edid_md.max;
<    }
<    for(i=0; i<this->tda.edid_md.written;i++) {
<       if (this->tda.edid_md.desc1[i].descRecord) {
<          this->tda.edid_md.desc1[i].monitorName[EDID_MONITOR_DESCRIPTOR_SIZE]=0;
<          printk(KERN_INFO "Monitor name:%s\n",this->tda.edid_md.desc1[i].monitorName);
<       }
<       if (this->tda.edid_md.desc1[i].descRecord) {
<          printk(KERN_INFO "Min vertical rate in Hz:%d\n",this->tda.edid_md.desc2[i].minVerticalRate);
<          printk(KERN_INFO "Max vertical rate in Hz:%d\n",this->tda.edid_md.desc2[i].maxVerticalRate);
<          printk(KERN_INFO "Min horizontal rate in Hz:%d\n",this->tda.edid_md.desc2[i].minHorizontalRate);
<          printk(KERN_INFO "Max horizontal rate in Hz:%d\n",this->tda.edid_md.desc2[i].maxHorizontalRate);
<          printk(KERN_INFO "Max suuported pixel clock rate in MHz:%d\n",this->tda.edid_md.desc2[i].maxSupportedPixelClk);
<       }
<    }
< 
<    printk(KERN_INFO "\n<TV picture ratio>\n");
<    TRY(tmdlHdmiTxGetEdidTVPictureRatio(this->tda.instance,  \
<                                        &this->tda.edid_tv_aspect_ratio));
<    printk(KERN_INFO "%s\n",tda_spy_aspect_ratio(this->tda.edid_tv_aspect_ratio));
< 
<    printk(KERN_INFO "\n<latency info>\n");
<    TRY(tmdlHdmiTxGetEdidLatencyInfo(this->tda.instance, \
<                                     &this->tda.edid_latency));
<    if (this->tda.edid_latency.latency_available) {
<       printk(KERN_INFO "Edid video:%d\n",this->tda.edid_latency.Edidvideo_latency);
<       printk(KERN_INFO "Edid audio:%d\n",this->tda.edid_latency.Edidaudio_latency);
<    }
<    if (this->tda.edid_latency.Ilatency_available) {
<       printk(KERN_INFO "Edid Ivideo:%d\n",this->tda.edid_latency.EdidIvideo_latency);
<       printk(KERN_INFO "Edid Iaudio:%d\n",this->tda.edid_latency.EdidIaudio_latency);
<    }
<  TRY_DONE:
<    return err;
< }
< #endif
< 
< /*
<  *
<  * PROCESSING
<  * ----------
<  * LEVEL 2
<  *
<  * - 
<  *
<  */
< 
< 
< /*
<  * On/Off HDCP
<  */
< void hdcp_onoff(tda_instance *this) {
< 
<    int err=0;
< 
< /*    printk("DBG %s status:%d enable:%d\n",__func__,this->tda.hdcp_status,this->tda.hdcp_enable); */
<    if (this->tda.rx_device_active) {
<       if (this->tda.hot_plug_detect == TMDL_HDMITX_HOTPLUG_ACTIVE) {
<          if (this->tda.power == tmPowerOn) {
<             if (this->tda.src_address != 0xFFFF) {
<                if (this->tda.hdcp_status!=TMDL_HDMITX_HDCP_CHECK_NUM) {/* ugly is bad */
<                   if (this->tda.hdcp_status == TMDL_HDMITX_HDCP_CHECK_NOT_STARTED) {
<                      if (this->tda.hdcp_enable) {
<                         TRY(tmdlHdmiTxSetHdcp(this->tda.instance,True));
< #if defined (TMFL_TDA19989) || defined (TMFL_TDA9984) 
<                         TRY(tmdlHdmiTxSetBScreen(this->tda.instance,TMDL_HDMITX_PATTERN_BLUE));
< #endif
<                      }
<                   }
<                   else if (this->tda.hdcp_status != TMDL_HDMITX_HDCP_CHECK_NOT_STARTED) {
<                      if (!this->tda.hdcp_enable) {
<                         TRY(tmdlHdmiTxSetHdcp(this->tda.instance,False));
<                      }
<                   }
<                }
<             }
<          }
<       }
<    }
< TRY_DONE:
<    (void)0;
< }
< 
< 
< /*
<  * Run video
<  */
< void show_video(tda_instance *this) {
< 
<    int err=0;
< 
<    if (this->tda.rx_device_active) {
<       if (this->tda.hot_plug_detect == TMDL_HDMITX_HOTPLUG_ACTIVE) {
<          if (this->tda.power == tmPowerOn) {
<             if (this->tda.src_address != 0xFFFF) {
<                TRY(tmdlHdmiTxSetInputOutput(this->tda.instance,         \
<                                             this->tda.setio.video_in,   \
<                                             this->tda.setio.video_out,  \
<                                             this->tda.setio.audio_in,   \
<                                             this->tda.setio.sink));
<                hdcp_onoff(this);
<             }
<          }
<       }
<    }
<  TRY_DONE:
<    (void)0;
< }
< 
< /*
<  *  TDA interrupt polling
<  */
< static void interrupt_polling(struct work_struct *dummy)
< {
<    tda_instance *this=&our_instance;
<    int err=0;
< 
<    /* Tx part */
<    TRY(tmdlHdmiTxHandleInterrupt(this->tda.instance));
< 
<    /* CEC part */
<    if (this->driver.cec_callback) this->driver.cec_callback(dummy);
< 
<    /* FIX : IT anti debounce */
<    TRY(tmdlHdmiTxHandleInterrupt(this->tda.instance));
< 
<  TRY_DONE:
< 
<    /* setup next polling */
< #ifndef IRQ
<    mod_timer(&this->driver.no_irq_timer,jiffies + ( CHECK_EVERY_XX_MS * HZ / 1000 ));
< #endif
< 
<    (void)0;
< }
< 
< /*
<  *  TDA interrupt polling
<  */
< static void hdcp_check(struct work_struct *dummy)
< {
<    int err=0;
<    tda_instance *this=&our_instance;
<    tmdlHdmiTxHdcpCheck_t hdcp_status;
< 
<    down(&this->driver.sem);
< 
<    if (this->tda.hdcp_status==TMDL_HDMITX_HDCP_CHECK_NUM) goto TRY_DONE; /* ugly is bad */
< 
<    TRY(tmdlHdmiTxHdcpCheck(this->tda.instance,HDCP_CHECK_EVERY_MS));
<    TRY(tmdlHdmiTxGetHdcpState(this->tda.instance, &hdcp_status));
< #if defined (TMFL_TDA19989) || defined (TMFL_TDA9984) 
<    if (this->tda.hdcp_status != hdcp_status) {
<       LOG(KERN_INFO,"HDCP status:%s\n",tda_spy_hdcp_status(hdcp_status));
<       this->tda.hdcp_status = hdcp_status;
<    }
< #endif
< #ifdef HDCP_TEST
<    /* TEST */
<    if (test++>500) {
<       test=0;
<       this->tda.hdcp_enable=1-this->tda.hdcp_enable;
<       printk("TEST hdcp:%d\n",this->tda.hdcp_enable);
<       hdcp_onoff(this);
<    }
< #endif
< 
<  TRY_DONE:
< 
<    /* setup next polling */
<    mod_timer(&this->driver.hdcp_check,jiffies + ( HDCP_CHECK_EVERY_MS * HZ / 1000 ));
< 
<    up(&this->driver.sem);
< }
< 
< void register_cec_interrupt(cec_callback_t fct)
< {
<    tda_instance *this=&our_instance;
< 
<    this->driver.cec_callback = fct;
< }
< EXPORT_SYMBOL(register_cec_interrupt);
< 
< void unregister_cec_interrupt(void)
< {
<    tda_instance *this=&our_instance;
< 
<    this->driver.cec_callback = NULL;
< }
< EXPORT_SYMBOL(unregister_cec_interrupt);
< 
< static DECLARE_WORK(wq_irq, interrupt_polling);
< void polling_timeout(unsigned long arg)
< {
<    /* derefered because ATOMIC context of timer does not support I2C_transfert */
<    schedule_work(&wq_irq);
< }
< 
< static DECLARE_WORK(wq_hdcp, hdcp_check);
< void hdcp_check_timeout(unsigned long arg)
< {
<    /* derefered because ATOMIC context of timer does not support I2C_transfert */
<    schedule_work(&wq_hdcp);
< }
< 
< #ifdef IRQ
< /*
<  *  TDA irq
<  */
< static irqreturn_t tda_irq(int irq, void *_udc)
< {
< 
<    /* do it now */
<    schedule_work(&wq_irq);
< 
<    return IRQ_HANDLED;
< }
< #endif
< 
< /*
<  *  TDA callback
<  */
< static void eventCallbackTx(tmdlHdmiTxEvent_t event)
< {
<    tda_instance *this=&our_instance;
<    int err=0;
<    unsigned short new_addr;
< #if defined (TMFL_TDA19989) || defined (TMFL_TDA9984) 
<    tda_hdcp_fail hdcp_fail;
< #endif
< 
<    this->tda.event=event;
<    if (TMDL_HDMITX_HDCP_INACTIVE != event) {
<       printk(KERN_INFO "hdmi %s\n",tda_spy_event(event));
<    }
< 
<    switch (event) {
<    case TMDL_HDMITX_EDID_RECEIVED:
<       TRY(tmdlHdmiTxGetEdidSourceAddress(this->tda.instance,        \
<                                          &new_addr));
<       LOG(KERN_INFO,"phy.@:%x\n",new_addr);
<       /*       if (this->tda.src_address == new_addr) { */
<       /*          break; */
<       /*       } */
<       this->tda.src_address = new_addr;
< #if defined (TMFL_TDA19989) || defined (TMFL_TDA9984) 
<       tda_spy(this->param.verbose>1);
< #endif
<       /* 
<          Customer may add stuff to analyse EDID (see tda_spy())
<          and select automatically some video/audio settings.
<          By default, let go on with next case and activate
<          default video/audio settings with tmdlHdmiTxSetInputOutput()
<       */
< 
<       TRY(tmdlHdmiTxGetEdidSinkType(this->tda.instance,     \
<                                     &this->tda.setio.sink));
<       if (TMDL_HDMITX_SINK_HDMI != this->tda.setio.sink) {
<          printk(KERN_INFO "/!\\ CAUTION /!\\ sink is not HDMI but %s\n",tda_spy_sink(this->tda.setio.sink));
<       }
<       
<       msleep(100);
<    case TMDL_HDMITX_RX_DEVICE_ACTIVE:
<       this->tda.rx_device_active = 1;
<       show_video(this);
<       break;
<    case TMDL_HDMITX_RX_DEVICE_INACTIVE: 
<       this->tda.rx_device_active = 0;
<       break;
<    case TMDL_HDMITX_HPD_ACTIVE: 
<       this->tda.hot_plug_detect = TMDL_HDMITX_HOTPLUG_ACTIVE;
<       show_video(this);
<       break;
<    case TMDL_HDMITX_HPD_INACTIVE: 
<       this->tda.hot_plug_detect = TMDL_HDMITX_HOTPLUG_INACTIVE;
<       this->tda.src_address = 0xFFFF;
<       break;
< #if defined (TMFL_TDA19989) || defined (TMFL_TDA9984) 
<    case TMDL_HDMITX_HDCP_INACTIVE:
<       tmdlHdmiTxGetHdcpFailStatus(this->tda.instance, \
<                                   &hdcp_fail, \
<                                   &this->tda.hdcp_raw_status);
<       if (this->tda.hdcp_fail != hdcp_fail) {
<          if (this->tda.hdcp_fail) {
<             LOG(KERN_INFO,"%s (%d)\n",tda_spy_hsdc_fail_status(this->tda.hdcp_fail),this->tda.hdcp_raw_status);
<          }
<          this->tda.hdcp_fail = hdcp_fail;
<          tmdlHdmiTxSetBScreen(this->tda.instance,TMDL_HDMITX_PATTERN_BLUE);
<       }
<       break;
<    case TMDL_HDMITX_RX_KEYS_RECEIVED:
<       tmdlHdmiTxRemoveBScreen(this->tda.instance);
<       break;
< #endif
<    default:
<       break;
<    }
< 
<    this->driver.poll_done=true;
<    wake_up_interruptible(&this->driver.wait);
<    
<  TRY_DONE:
<    (void)0;
< }
< 
< /*
<  *  hdmi Tx init
<  */
< static int hdmi_tx_init(tda_instance *this)
< {
<    int err=0;
< 
<    LOG(KERN_INFO,"called\n");
< 
< 
<    /*Initialize HDMI Transmiter*/
<    TRY(tmdlHdmiTxOpen(&this->tda.instance));
<    /* Register the HDMI TX events callbacks */
<    TRY(tmdlHdmiTxRegisterCallbacks(this->tda.instance,(ptmdlHdmiTxCallback_t)eventCallbackTx));
<    /* EnableEvent, all by default */
<    TRY(tmdlHdmiTxEnableEvent(this->tda.instance,TMDL_HDMITX_HDCP_ACTIVE));
<    TRY(tmdlHdmiTxEnableEvent(this->tda.instance,TMDL_HDMITX_HDCP_INACTIVE));
<    TRY(tmdlHdmiTxEnableEvent(this->tda.instance,TMDL_HDMITX_HPD_ACTIVE));
<    TRY(tmdlHdmiTxEnableEvent(this->tda.instance,TMDL_HDMITX_HPD_INACTIVE));
<    TRY(tmdlHdmiTxEnableEvent(this->tda.instance,TMDL_HDMITX_RX_KEYS_RECEIVED));
<    TRY(tmdlHdmiTxEnableEvent(this->tda.instance,TMDL_HDMITX_RX_DEVICE_ACTIVE));
<    TRY(tmdlHdmiTxEnableEvent(this->tda.instance,TMDL_HDMITX_RX_DEVICE_INACTIVE));
<    TRY(tmdlHdmiTxEnableEvent(this->tda.instance,TMDL_HDMITX_EDID_RECEIVED));
< 
<    /* Size of the application EDID buffer */
<    this->tda.setup.edidBufferSize=EDID_BLOCK_COUNT * EDID_BLOCK_SIZE;
<    /* Buffer to store the application EDID data */
<    this->tda.setup.pEdidBuffer=this->tda.raw_edid;
<    /* To Enable/disable repeater feature, nor relevant here */
<    this->tda.setup.repeaterEnable=false;
<    /* To enable/disable simplayHD feature: blue screen when not authenticated */
<    this->tda.setup.simplayHd=false;
<    
< 
<    /* Provides HDMI TX instance configuration */
<    TRY(tmdlHdmiTxInstanceSetup(this->tda.instance,&this->tda.setup));
<    /* Get IC version */
<    TRY(tmdlHdmiTxGetCapabilities(&this->tda.capabilities));
< 
<    /* Main settings */
<    this->tda.setio.video_out.mode = TMDL_HDMITX_VOUTMODE_RGB444;
<    this->tda.setio.video_out.colorDepth = TMDL_HDMITX_COLORDEPTH_24;
< #ifdef TMFL_TDA19989
<    this->tda.setio.video_out.dviVqr = TMDL_HDMITX_VQR_DEFAULT; /* Use HDMI rules for DVI output */
< #endif
< /*    this->tda.setio.video_out.format = TMDL_HDMITX_VFMT_31_1920x1080p_50Hz; */
< /*    this->tda.setio.video_out.format = TMDL_HDMITX_VFMT_PC_640x480p_60Hz; */
< /*    this->tda.setio.video_out.format = TMDL_HDMITX_VFMT_PC_640x480p_72Hz; */
< /*    this->tda.setio.video_out.format = TMDL_HDMITX_VFMT_04_1280x720p_60Hz; */
< /*    this->tda.setio.video_out.format = TMDL_HDMITX_VFMT_19_1280x720p_50Hz; */
<    this->tda.setio.video_out.format = TMDL_HDMITX_VFMT_02_720x480p_60Hz;
< 
<    this->tda.setio.video_in.mode = TMDL_HDMITX_VINMODE_RGB444;
<    /*    this->tda.setio.video_in.mode = TMDL_HDMITX_VINMODE_YUV422; */
<    this->tda.setio.video_in.format = this->tda.setio.video_out.format;
<    this->tda.setio.video_in.pixelRate = TMDL_HDMITX_PIXRATE_SINGLE;
<    this->tda.setio.video_in.syncSource = TMDL_HDMITX_SYNCSRC_EXT_VS; /* we use HS,VS as synchronisation source */
< 
<    this->tda.setio.audio_in.format = TMDL_HDMITX_AFMT_I2S;
<    this->tda.setio.audio_in.rate = TMDL_HDMITX_AFS_48K;
<    this->tda.setio.audio_in.i2sFormat = TMDL_HDMITX_I2SFOR_PHILIPS_L;
<    this->tda.setio.audio_in.i2sQualifier = TMDL_HDMITX_I2SQ_32BITS;
<    this->tda.setio.audio_in.dstRate = TMDL_HDMITX_DSTRATE_SINGLE; /* not relevant here */
<    this->tda.setio.audio_in.channelAllocation = 0; /* audio channel allocation (Ref to CEA-861D p85) */
< 
<    this->tda.setio.sink = TMDL_HDMITX_SINK_HDMI; /* skip edid reading */
<    /*    this->tda.src_address = 0x1000; /\* debug *\/ */
<    this->tda.src_address = NO_PHY_ADDR; /* it's unref */
< 
<  TRY_DONE:
<    return err;
< }
< 
< void reset_hdmi(int hdcp_module)
< {
<    tda_instance *this=&our_instance;
<    int err=0;
< 
<    down(&this->driver.sem);
< 
<    /* PATCH because of SetPowerState that calls SetHdcp that has just been removed by nwolc :( */
<    if (hdcp_module==2) {
<       tmdlHdmiTxSetHdcp(this->tda.instance,0);
<       goto TRY_DONE;
<    }
< 
<    TRY(tmdlHdmiTxSetPowerState(this->tda.instance,tmPowerStandby));
<    tmdlHdmiTxClose(this->tda.instance);
<    /* reset */
<    hdmi_tx_init(this);
<    /* recover previous power state */
<    TRY(tmdlHdmiTxSetPowerState(this->tda.instance,this->tda.power));
<    tmdlHdmiTxGetHPDStatus(this->tda.instance,&this->tda.hot_plug_detect); /* check if activ for timer */
<    show_video(this);
< 
<    /* wake up or shut down hdcp checking */
<    if (hdcp_module) {
<       this->driver.hdcp_check.expires = jiffies +  ( HDCP_CHECK_EVERY_MS * HZ / 1000 );
<       add_timer(&this->driver.hdcp_check);
<       this->tda.hdcp_status = TMDL_HDMITX_HDCP_CHECK_NOT_STARTED; /* ugly is bad ! */ 
<       this->tda.hdcp_enable = 1; /* FIXME : fallback 4 HDCP on/off is ok */
< #if defined (TMFL_TDA19989) || defined (TMFL_TDA9984) 
<       tmdlHdmiTxSetBScreen(this->tda.instance,TMDL_HDMITX_PATTERN_BLUE);
< #endif
<    }
<    else {
<       del_timer(&this->driver.hdcp_check);
<       this->tda.hdcp_status = TMDL_HDMITX_HDCP_CHECK_NUM; /* ugly is bad ! */ 
<       this->tda.hdcp_enable = 0; /* FIXME : fallback 4 HDCP on/off is ok */
<    }
< 
<  TRY_DONE:
<    up(&this->driver.sem);
< }
< EXPORT_SYMBOL(reset_hdmi);
< 
< /*
<  *  
<  */
< short edid_phy_addr(void)
< {
<    tda_instance *this=&our_instance;
< 
<    return this->tda.src_address;
< }
< EXPORT_SYMBOL(edid_phy_addr);
< 
< /*
<  *  
<  */
< tda_power get_hdmi_status(void)
< { 
<    tda_instance *this=&our_instance;
<    
<    return this->tda.power;
< }
< EXPORT_SYMBOL(get_hdmi_status);
< 
< /*
<  *  
<  */
< tda_power get_hpd_status(void)
< { 
<    tda_instance *this=&our_instance;
<    
<    return (this->tda.hot_plug_detect == TMDL_HDMITX_HOTPLUG_ACTIVE);
< }
< EXPORT_SYMBOL(get_hpd_status);
< 
< /*
<  *  
<  */
< int edid_received(void)
< { 
<    tda_instance *this=&our_instance;
<    
<    return (this->tda.event == TMDL_HDMITX_EDID_RECEIVED);
< }
< EXPORT_SYMBOL(edid_received);
< 
< /*
<  *  
<  */
< int hdmi_enable(void)
< {
<    tda_instance *this=&our_instance;
<    int err=0;
< 
<    LOG(KERN_INFO,"called\n");
< 
<    down(&this->driver.sem);
< 
<    this->tda.power = tmPowerOn;
<    TRY(tmdlHdmiTxSetPowerState(this->tda.instance,this->tda.power));
<    if (err==TM_ERR_NO_RESOURCES) {
<       LOG(KERN_INFO,"Busy...\n");
<       TRY(tmdlHdmiTxHandleInterrupt(this->tda.instance));
<       TRY(tmdlHdmiTxHandleInterrupt(this->tda.instance));
<       TRY(tmdlHdmiTxHandleInterrupt(this->tda.instance));
<    }
<    tmdlHdmiTxGetHPDStatus(this->tda.instance,&this->tda.hot_plug_detect);
<    show_video(this); /* FIXME : mind usecases without HPD and RX_SEND... */
<    
<  TRY_DONE:
<    up(&this->driver.sem);
<    return err;
< }
< EXPORT_SYMBOL(hdmi_enable);
< 
< /*
<  *  
<  */
< int hdmi_disable(int event_tracking)
< { 
<    tda_instance *this=&our_instance;
<    int err=0;
<    
<    LOG(KERN_INFO,"called\n");
< 
<    down(&this->driver.sem);
< 
<    this->tda.power = (event_tracking?tmPowerSuspend:tmPowerStandby);
<    TRY(tmdlHdmiTxSetPowerState(this->tda.instance,this->tda.power));
< 
<  TRY_DONE:
<    up(&this->driver.sem);
<    return err;
< }
< EXPORT_SYMBOL(hdmi_disable);
< 
< /*
<  *
<  * ENTRY POINTS
<  * ------------
<  * LEVEL 3
<  *
<  * - 
<  *
<  */
< 
< #ifdef ANDROID_DSS
< /*
<  *  DSS driver :: probe
<  */
< static int hdmi_panel_probe(struct omap_dss_device *dssdev)
< {
<    tda_instance *this=&our_instance;
< 
<    LOG(KERN_INFO," called\n");
< 
<    sysdss=dssdev;
< 
<    /* 	OMAP_DSS_LCD_IVS		= 1<<0, */
<    /* 	OMAP_DSS_LCD_IHS		= 1<<1, */
<    /* 	OMAP_DSS_LCD_IPC		= 1<<2, */
<    /* 	OMAP_DSS_LCD_IEO		= 1<<3, */
<    /* 	OMAP_DSS_LCD_RF			= 1<<4, */
<    /* 	OMAP_DSS_LCD_ONOFF		= 1<<5, */
<    /* 	OMAP_DSS_LCD_TFT		= 1<<20, */
< 
<    dssdev->panel.config = OMAP_DSS_LCD_ONOFF | OMAP_DSS_LCD_IPC |  \
<       OMAP_DSS_LCD_TFT | OMAP_DSS_LCD_IVS | OMAP_DSS_LCD_IHS;
<    dssdev->panel.timings = video_720x480at60Hz_panel_timings;
<    (void)video_1280x720at60Hz_panel_timings;
<    (void)video_720x480at60Hz_panel_timings;
<    (void)video_1280x720at50Hz_panel_timings;
<    (void)video_800x480at60Hz_panel_timings;
<    (void)video_1280x720at50Hz_panel_timings;
<    (void)video_1920x1080at50Hz_panel_timings;
<    (void)video_640x480at72Hz_panel_timings;
<    (void)video_640x480at60Hz_panel_timings;
< 
<    return 0;
< }
< 
< /*
<  *  DSS driver :: enable
<  */
< static void hdmi_panel_remove(struct omap_dss_device *dssdev)
< {
< }
< 
< /*
<  *  DSS driver :: enable
<  */
< static int hdmi_panel_enable(struct omap_dss_device *dssdev)
< {
<    int r = 0;
< 
<    if (dssdev->platform_enable)
<       r = dssdev->platform_enable(dssdev);
<    
<    if (r)
<       goto ERROR0;
< 
<    r = hdmi_enable();
<    if (r)
<       goto ERROR0;
<    /* wait couple of vsyncs until enabling the LCD */
<    msleep(50);
< 
<    return 0;
<  ERROR0:
<    return r;
< }
< 
< /*
<  *  DSS driver :: disable
<  */
< static void hdmi_panel_disable(struct omap_dss_device *dssdev)
< {
<    hdmi_disable(0);
< 
<    /* wait couple of vsyncs until enabling the hdmi */
<    msleep(50);
< 
<    if (dssdev->platform_disable)
<       dssdev->platform_disable(dssdev);
< }
< 
< /*
<  *  DSS driver :: suspend
<  */
< static int hdmi_panel_suspend(struct omap_dss_device *dssdev)
< {
<    hdmi_panel_disable(dssdev);
<    return 0;
< }
< 
< /*
<  *  DSS driver :: resume
<  */
< static int hdmi_panel_resume(struct omap_dss_device *dssdev)
< {
<    return hdmi_panel_enable(dssdev);
< }
< 
< /*
<  *  DSS driver (frontend with omapzoom)
<  *  -----------------------------------
<  */
< static struct omap_dss_driver hdmi_driver = {
<    .probe = hdmi_panel_probe,
<    .remove = hdmi_panel_remove,
<    .enable = hdmi_panel_enable,
<    .disable = hdmi_panel_disable,
<    .suspend = hdmi_panel_suspend,
<    .resume = hdmi_panel_resume,
<    .driver = {
<       .name = "hdmi_panel",
<       .owner = THIS_MODULE,
<    }
< };
< #endif
< 
< /*
<  *  ioctl driver :: opening
<  */
< 
< static int this_cdev_open(struct inode *pInode, struct file *pFile)
< {
<    tda_instance *this;
<    int minor=iminor(pInode);
< 
<    if(minor >= MAX_MINOR) {
<       printk(KERN_ERR "hdmitx:%s:only one tda can be open\n",__func__);
<       return -EINVAL;
<    }
< 
<    if ((pFile->private_data != NULL) && (pFile->private_data != &our_instance)) {
<       printk(KERN_ERR "hdmitx:%s:pFile missmatch\n",__func__);
<    }
<    this = pFile->private_data = &our_instance;
<    down(&this->driver.sem);
< 
<    LOG(KERN_INFO,"major:%d minor:%d user:%d\n", imajor(pInode), iminor(pInode), this->driver.user_counter);
< 
<    if ((this->driver.user_counter++) && (this->driver.minor == minor)) {
<       /* init already done */
<       up(&this->driver.sem);
<       return 0;
<    }
<    this->driver.minor = minor;
< 
< 
<    up(&this->driver.sem);
<    return 0;
< }
< 
< /*
<  *  ioctl driver :: ioctl
<  */
< static int this_cdev_ioctl(struct inode *pInode, struct file *pFile, unsigned int cmd, unsigned long arg)
< {
<    tda_instance* this = pFile->private_data;
<    int err=0;
< 
<    LOG(KERN_INFO,":%s\n",tda_ioctl(_IOC_NR(cmd)));
< 
<    BUG_ON(this->driver.minor!=iminor(pInode));
<    if (_IOC_TYPE(cmd) != TDA_IOCTL_BASE) {
<       printk(KERN_INFO "hdmitx:%s:unknown ioctl type: %x\n",__func__,_IOC_TYPE(cmd));
<       return -ENOIOCTLCMD;
<    }
< 
<    if (_IOC_DIR(cmd) & _IOC_READ) 
<       err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd)) || !arg;
<    else if (_IOC_DIR(cmd) & _IOC_WRITE)
<       err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd)) || !arg;
<    if (err) {
<       printk(KERN_ERR "hdmitx:%s:argument access denied (check address vs value)\n",__func__);
<       printk(KERN_ERR "_IOC_DIR:%d arg:%lx\n",_IOC_DIR(cmd),arg);
<       return -EFAULT;
<    }
<    
<    down(&this->driver.sem);
< 
<    /* Check DevLib consistancy here */
< 
<    switch ( _IOC_NR(cmd) )
<       {
<       case TDA_VERBOSE_ON_CMD:
<          {
<             this->param.verbose=1;
<             printk(KERN_INFO "hdmitx:verbose on\n");
<             break;
<          }
< 
<       case TDA_VERBOSE_OFF_CMD:
<          {
<             printk(KERN_INFO "hdmitx:verbose off\n");
<             this->param.verbose=0;
<             break;
<          }
< 
<       case TDA_BYEBYE_CMD:
<          {
<             LOG(KERN_INFO,"release event handeling request\n");
<             this->tda.event=RELEASE;
<             this->driver.poll_done = true;
<             wake_up_interruptible(&this->driver.wait);
<             break;
<          }
< 
<       case TDA_GET_SW_VERSION_CMD:
<          {
<             TRY(tmdlHdmiTxGetSWVersion(&this->tda.version));
<             BUG_ON(copy_to_user((tda_version*)arg,&this->tda.version,sizeof(tda_version)) != 0);
<             break;
<          }
< 
<       case TDA_SET_POWER_CMD:
<          {
<             BUG_ON(copy_from_user(&this->tda.power,(tda_power*)arg,sizeof(tda_power)) != 0);
<             TRY(tmdlHdmiTxSetPowerState(this->tda.instance, \
<                                         this->tda.power));
<             break;
<          }
< 
<       case TDA_GET_POWER_CMD:
<          {
<             TRY(tmdlHdmiTxGetPowerState(this->tda.instance, \
<                                         &this->tda.power));
<             BUG_ON(copy_to_user((tda_power*)arg,&this->tda.power,sizeof(tda_power)) != 0);
<             break;
<          }
< 
<       case TDA_SETUP_CMD:
<          {
<             BUG_ON(copy_from_user(&this->tda.setup,(tda_setup_info*)arg,sizeof(tda_setup_info)) != 0);
<             TRY(tmdlHdmiTxInstanceSetup(this->tda.instance, \
<                                         &this->tda.setup));
<             break;
<          }
< 
<       case TDA_GET_SETUP_CMD:
<          {
<             TRY(tmdlHdmiTxGetInstanceSetup(this->tda.instance, \
<                                            &this->tda.setup));
<             BUG_ON(copy_to_user((tda_setup*)arg,&this->tda.setup,sizeof(tda_setup)) != 0);
<             break;
<          }
< 
<       case TDA_WAIT_EVENT_CMD:
<          {
<             this->driver.poll_done = false;
<             up(&this->driver.sem);
<             if (wait_event_interruptible(this->driver.wait,this->driver.poll_done)) return -ERESTARTSYS;
<             down(&this->driver.sem);
<             BUG_ON(copy_to_user((tda_event*)arg,&this->tda.event,sizeof(tda_event)) != 0);
<             break;
<          }
< 
<       case TDA_ENABLE_EVENT_CMD:
<          {
<             tmdlHdmiTxEvent_t event;
<             BUG_ON(copy_from_user(&event,(tmdlHdmiTxEvent_t*)arg,sizeof(tmdlHdmiTxEvent_t)) != 0);
<             TRY(tmdlHdmiTxEnableEvent(this->tda.instance,event));
<             break;
<          }
< 
<       case TDA_DISABLE_EVENT_CMD:
<          {
<             tmdlHdmiTxEvent_t event;
<             BUG_ON(copy_from_user(&event,(tmdlHdmiTxEvent_t*)arg,sizeof(tmdlHdmiTxEvent_t)) != 0);
<             TRY(tmdlHdmiTxDisableEvent(this->tda.instance,event));
<             break;
<          }
< 
<       case TDA_GET_VIDEO_SPEC_CMD:
<          {
<             TRY(tmdlHdmiTxGetVideoFormatSpecs(this->tda.instance, \
<                                               this->tda.video_fmt.id, \
<                                               &this->tda.video_fmt.spec));
<             BUG_ON(copy_to_user((tda_video_format*)arg,&this->tda.video_fmt,sizeof(tda_video_format)) != 0);
<             break;
<          }
< 
<       case TDA_SET_INPUT_OUTPUT_CMD:
<          {
<             BUG_ON(copy_from_user(&this->tda.setio,(tda_set_in_out*)arg,sizeof(tda_set_in_out)) != 0);
< 
<             TRY(tmdlHdmiTxSetInputOutput(this->tda.instance, \
<                                          this->tda.setio.video_in, \
<                                          this->tda.setio.video_out, \
<                                          this->tda.setio.audio_in, \
<                                          this->tda.setio.sink));
<             break;
<          }
< 
<       case TDA_SET_AUDIO_INPUT_CMD:
<          {
<             BUG_ON(copy_from_user(&this->tda.setio.audio_in,(tda_set_audio_in*)arg,sizeof(tda_set_audio_in)) != 0);
<             TRY(tmdlHdmiTxSetAudioInput(this->tda.instance, \
<                                         this->tda.setio.audio_in, \
<                                         this->tda.setio.sink));
<             break;
<          }
< 
<       case TDA_SET_VIDEO_INFOFRAME_CMD:
<          {
<             BUG_ON(copy_from_user(&this->tda.video_infoframe,(tda_video_infoframe*)arg,sizeof(tda_video_infoframe)) != 0);
<             TRY(tmdlHdmiTxSetVideoInfoframe(this->tda.instance, \
<                                             this->tda.video_infoframe.enable, \
<                                             &this->tda.video_infoframe.data));
<             break;
<          }
< 
<       case TDA_SET_AUDIO_INFOFRAME_CMD:
<          {
<             BUG_ON(copy_from_user(&this->tda.audio_infoframe,(tda_audio_infoframe*)arg,sizeof(tda_audio_infoframe)) != 0);
<             TRY(tmdlHdmiTxSetAudioInfoframe(this->tda.instance, \
<                                             this->tda.audio_infoframe.enable, \
<                                             &this->tda.audio_infoframe.data));
<             break;
<          }
< 
<       case TDA_SET_ACP_CMD:
<          {
<             BUG_ON(copy_from_user(&this->tda.acp,(tda_acp*)arg,sizeof(tda_acp)) != 0);
<             TRY(tmdlHdmiTxSetACPPacket(this->tda.instance, \
<                                        this->tda.acp.enable, \
<                                        &this->tda.acp.data));
<             break;
<          }
< 
<       case TDA_SET_GCP_CMD:
<          {
<             BUG_ON(copy_from_user(&this->tda.gcp,(tda_gcp*)arg,sizeof(tda_gcp)) != 0);
<             TRY(tmdlHdmiTxSetGeneralControlPacket(this->tda.instance, \
<                                                   this->tda.gcp.enable, \
<                                                   &this->tda.gcp.data));
<             break;
<          }
< 
<       case TDA_SET_ISRC1_CMD:
<          {
<             BUG_ON(copy_from_user(&this->tda.isrc1,(tda_isrc1*)arg,sizeof(tda_isrc1)) != 0);
<             TRY(tmdlHdmiTxSetISRC1Packet(this->tda.instance, \
<                                          this->tda.isrc1.enable, \
<                                          &this->tda.isrc1.data));
<             break;
<          }
< 
<       case TDA_SET_MPS_INFOFRAME_CMD:
<          {
<             BUG_ON(copy_from_user(&this->tda.mps_infoframe,(tda_mps_infoframe*)arg,sizeof(tda_mps_infoframe)) != 0);
<             TRY(tmdlHdmiTxSetMPSInfoframe(this->tda.instance, \
<                                           this->tda.mps_infoframe.enable, \
<                                           &this->tda.mps_infoframe.data));
<             break;
<          }
< 
<       case TDA_SET_SPD_INFOFRAME_CMD:
<          {
<             BUG_ON(copy_from_user(&this->tda.spd_infoframe,(tda_spd_infoframe*)arg,sizeof(tda_spd_infoframe)) != 0);
<             TRY(tmdlHdmiTxSetSpdInfoframe(this->tda.instance, \
<                                           this->tda.spd_infoframe.enable, \
<                                           &this->tda.spd_infoframe.data));
<             break;
<          }
< 
<       case TDA_SET_VS_INFOFRAME_CMD:
<          {
<             BUG_ON(copy_from_user(&this->tda.vs_infoframe,(tda_vs_infoframe*)arg,sizeof(tda_vs_infoframe)) != 0);
<             TRY(tmdlHdmiTxSetVsInfoframe(this->tda.instance, \
<                                          this->tda.vs_infoframe.enable, \
<                                          &this->tda.vs_infoframe.data));
<             break;
<          }
< 
<       case TDA_SET_AUDIO_MUTE_CMD:
<          {
<             BUG_ON(copy_from_user(&this->tda.audio_mute,(bool*)arg,sizeof(bool)) != 0);
<             TRY(tmdlHdmiTxSetAudioMute(this->tda.instance,			\
<                                        this->tda.audio_mute));
<             break;
<          }
< 
<       case TDA_RESET_AUDIO_CTS_CMD:
<          {
<             TRY(tmdlHdmiTxResetAudioCts(this->tda.instance));
<             break;
<          }
< 
<       case TDA_GET_EDID_STATUS_CMD:
<          {
<             TRY(tmdlHdmiTxGetEdidStatus(this->tda.instance, \
<                                         &this->tda.edid.status, \
<                                         &this->tda.edid.block_count));
<             BUG_ON(copy_to_user((tda_edid*)arg,&this->tda.edid,sizeof(tda_edid)) != 0);
<             break;
<          }
< 
<       case TDA_GET_EDID_AUDIO_CAPS_CMD:
<          {
<             TRY(tmdlHdmiTxGetEdidAudioCaps(this->tda.instance, \
<                                            this->tda.edid_audio_caps.desc, \
<                                            this->tda.edid_audio_caps.max, \
<                                            &this->tda.edid_audio_caps.written, \
<                                            &this->tda.edid_audio_caps.flags));
<             BUG_ON(copy_to_user((tda_edid_audio_caps*)arg,&this->tda.edid_audio_caps,sizeof(tda_edid_audio_caps)) != 0);
<             break;
<          }
< 
<       case TDA_GET_EDID_VIDEO_CAPS_CMD:
<          {
<             TRY(tmdlHdmiTxGetEdidVideoCaps(this->tda.instance, \
<                                            this->tda.edid_video_caps.desc, \
<                                            this->tda.edid_video_caps.max, \
<                                            &this->tda.edid_video_caps.written, \
<                                            &this->tda.edid_video_caps.flags));
<             BUG_ON(copy_to_user((tda_edid_video_caps*)arg,&this->tda.edid_video_caps,sizeof(tda_edid_video_caps)) != 0);
<             break;
<          }
< 
<       case TDA_GET_EDID_VIDEO_PREF_CMD:
<          {
<             TRY(tmdlHdmiTxGetEdidVideoPreferred(this->tda.instance, \
<                                                 &this->tda.edid_video_timings));
<             BUG_ON(copy_to_user((tda_edid_video_timings*)arg,&this->tda.edid_video_timings,sizeof(tda_edid_video_timings)) != 0);
<             break;
<          }
< 
<       case TDA_GET_EDID_SINK_TYPE_CMD:
<          {
<             TRY(tmdlHdmiTxGetEdidSinkType(this->tda.instance, \
<                                           &this->tda.setio.sink));
<             BUG_ON(copy_to_user((tda_sink*)arg,&this->tda.setio.sink,sizeof(tda_sink)) != 0);
<             break;
<          }
< 
<       case TDA_GET_EDID_SOURCE_ADDRESS_CMD:
<          {
<             TRY(tmdlHdmiTxGetEdidSourceAddress(this->tda.instance, \
<                                                &this->tda.src_address));
<             BUG_ON(copy_to_user((unsigned short*)arg,&this->tda.src_address,sizeof(unsigned short)) != 0);
<             break;
<          }
< 
<       case TDA_SET_GAMMUT_CMD:
<          {
<             BUG_ON(copy_from_user(&this->tda.gammut,(tda_gammut*)arg,sizeof(tda_gammut)) != 0);
<             TRY(tmdlHdmiTxSetGamutPacket(this->tda.instance, \
<                                          this->tda.gammut.enable, \
<                                          &this->tda.gammut.data));
<             break;
<          }
< 	 
<       case TDA_GET_EDID_DTD_CMD:
<          {
<             TRY(tmdlHdmiTxGetEdidDetailledTimingDescriptors(this->tda.instance, \
<                                                             this->tda.edid_dtd.desc, \
<                                                             this->tda.edid_dtd.max, \
<                                                             &this->tda.edid_dtd.written));
<             BUG_ON(copy_to_user((tda_edid_dtd*)arg,&this->tda.edid_dtd,sizeof(tda_edid_dtd)) != 0);
<             break;
<          }
<      
< #if defined (TMFL_TDA19989) || defined (TMFL_TDA9984) 
<       case TDA_GET_EDID_MD_CMD:
<          {
<             TRY(tmdlHdmiTxGetEdidMonitorDescriptors(this->tda.instance, \
<                                                     this->tda.edid_md.desc1, \
<                                                     this->tda.edid_md.desc2, \
<                                                     this->tda.edid_md.other, \
<                                                     this->tda.edid_md.max, \
<                                                     &this->tda.edid_md.written));
<             BUG_ON(copy_to_user((tda_edid_md*)arg,&this->tda.edid_md,sizeof(tda_edid_md)) != 0);
<             break;
<          }
< 
<       case TDA_GET_EDID_TV_ASPECT_RATIO_CMD:
<          {
<             TRY(tmdlHdmiTxGetEdidTVPictureRatio(this->tda.instance, \
<                                                 &this->tda.edid_tv_aspect_ratio));
<             BUG_ON(copy_to_user((tda_edid_tv_aspect_ratio*)arg,&this->tda.edid_tv_aspect_ratio,sizeof(tda_edid_tv_aspect_ratio)) != 0);
<             break;
<          }
< 
<       case TDA_GET_EDID_LATENCY_CMD:
<          {
<             TRY(tmdlHdmiTxGetEdidLatencyInfo(this->tda.instance, \
<                                              &this->tda.edid_latency));
<             BUG_ON(copy_to_user((tda_edid_latency*)arg,&this->tda.edid_latency,sizeof(tda_edid_latency)) != 0);
<             break;
<          }
< 
<       case TDA_SET_HDCP_CMD:
<          {
<             BUG_ON(copy_from_user(&this->tda.hdcp_enable,(bool*)arg,sizeof(bool)) != 0);
<             break;
<          }
< 
<       case TDA_GET_HDCP_STATUS_CMD:
<          {
<             BUG_ON(copy_to_user((tda_edid_latency*)arg,&this->tda.hdcp_status,sizeof(tda_hdcp_status)) != 0);
<             break;
<          }
< #endif
< 
<       default:
<          {
<             /* unrecognized ioctl */	
<             printk(KERN_INFO "hdmitx:%s:unknown ioctl number: %x\n",__func__,cmd);
<             up(&this->driver.sem);
<             return -ENOIOCTLCMD;
<          }
<       }
< 
<  TRY_DONE:
<    up(&this->driver.sem);
<    return err;
< }
< 
< /*
<  *  ioctl driver :: releasing
<  */
< static int this_cdev_release(struct inode *pInode, struct file *pFile)
< {
<    tda_instance* this = pFile->private_data;
<    int minor = iminor(pInode);
< 
<    LOG(KERN_INFO,"called\n");
< 
<    if(minor >= MAX_MINOR) {
<       LOG(KERN_ERR,"minor too big!\n");
<       return -EINVAL;
<    }
< 
<    BUG_ON(this->driver.minor!=iminor(pInode));
<    down(&this->driver.sem);
< 
<    this->driver.user_counter--;
<    if(this->driver.user_counter == 0) {
<       pFile->private_data = NULL;
<    }
<    else {
<       LOG(KERN_INFO,"Still %d users pending\n",this->driver.user_counter);
<    }
< 
<    up(&this->driver.sem);
<    return 0;
< }
< 
< /*
<  *  I2C client :: creation
<  */
< static int this_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
< {
<    tda_instance *this=&our_instance;
<    int err=0;
< 
<    LOG(KERN_INFO,"called\n");
< 
<    /*
<      I2C setup
<    */
<    if (this->driver.i2c_client) {
<       dev_err(&this->driver.i2c_client->dev, "<%s> HDMI Device already created \n",
<               __func__);
<       return -ENODEV;
<    }
< 
<    this->driver.i2c_client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
<    if (!this->driver.i2c_client) {
<       return -ENOMEM;
<    }
<    memset(this->driver.i2c_client, 0, sizeof(struct i2c_client));
< 
<    strncpy(this->driver.i2c_client->name, TX_NAME, I2C_NAME_SIZE);
<    this->driver.i2c_client->addr = TDA998X_I2C_SLAVEADDRESS;
<    this->driver.i2c_client->adapter = client->adapter;
< 
<    i2c_set_clientdata(client, this->driver.i2c_client);
< 
<    /* I2C ok, then let's startup TDA */
<    err = hdmi_tx_init(this);
<    if (err) goto i2c_out;
<    this->tda.hdcp_enable = 0;
<    /* Standby the HDMI TX instance */
<    this->tda.power = tmPowerStandby;
<    tmdlHdmiTxSetPowerState(this->tda.instance,this->tda.power);
<    /* update HPD */
<    tmdlHdmiTxGetHPDStatus(this->tda.instance,&this->tda.hot_plug_detect);
< 
< #ifdef ANDROID_DSS
<    /* probe DSS */
<    err = omap_dss_register_driver(&hdmi_driver);
< #endif
<    if (err) goto i2c_tx_out;
< 
<    /* prepare event */
<    this->driver.poll_done = true; /* currently idle */
<    init_waitqueue_head(&this->driver.wait);
< 
< #ifdef IRQ
<    /* FRO calibration */
<    err=gpio_request(TDA_IRQ_CALIB,"tda998x calibration");
<    if (err < 0) {
<       printk(KERN_ERR "hdmitx:%s:cannot use GPIO 107\n",__func__);
<       goto i2c_out;
<    }
<    /* turn GPIO into IRQ */
<    gpio_direction_input(TDA_IRQ_CALIB);
<    msleep(1);
<    if (request_irq(gpio_to_irq(TDA_IRQ_CALIB), \
<                    tda_irq, IRQF_TRIGGER_FALLING|IRQF_DISABLED, "TDA IRQ", NULL)) {
<       printk(KERN_ERR "hdmitx:%s:Cannot request irq, err:%d\n",__func__,err);
<       gpio_free(TDA_IRQ_CALIB);
<       goto i2c_out;
<    }
< #else
<    init_timer(&this->driver.no_irq_timer);
<    this->driver.no_irq_timer.function=polling_timeout;
<    this->driver.no_irq_timer.data=0;
<    this->driver.no_irq_timer.expires = jiffies + HZ; /* start polling in one sec */
<    add_timer(&this->driver.no_irq_timer);
< #endif
< 
<    /* setup hdcp check timer */
<    init_timer(&this->driver.hdcp_check);
<    this->driver.hdcp_check.function=hdcp_check_timeout;
<    this->driver.hdcp_check.data=0;
< 
<    tmdlHdmiTxGetSWVersion(&this->tda.version);
<    printk(KERN_INFO "HDMI TX SW Version:%lu.%lu compatibility:%lu\n",   \
<           this->tda.version.majorVersionNr,\
<           this->tda.version.minorVersionNr,\
<           this->tda.version.compatibilityNr);
<    return 0;
< 
<  i2c_tx_out:
<    LOG(KERN_INFO,"tmdlHdmiTx closed\n");
<    /* close DevLib */
<    err=tmdlHdmiTxClose(this->tda.instance);
< 
<  i2c_out:
<    LOG(KERN_INFO,"this->driver.i2c_client removed\n");
<    kfree(this->driver.i2c_client);
<    this->driver.i2c_client = NULL;
< 
<    return err;
< }
< 
< /*
<  *  I2C client :: destroy
<  */
< static int this_i2c_remove(struct i2c_client *client)
< {
<    tda_instance *this=&our_instance;
<    int err=0;
< 
<    LOG(KERN_INFO,"called\n");
< 
< #ifdef ANDROID_DSS
<    /* unplug DSS */
<    omap_dss_unregister_driver(&hdmi_driver);
< #endif
< 
<    if (!client->adapter) {
<       dev_err(&this->driver.i2c_client->dev, "<%s> No HDMI Device \n",
<               __func__);
<       return -ENODEV;
<    }
<    kfree(this->driver.i2c_client);
<    this->driver.i2c_client = NULL;
< 
<    return err;
< }
< 
< /*
<  *  I2C client driver (backend)
<  *  -----------------
<  */
< static const struct i2c_device_id this_i2c_id[] = {
<    { TX_NAME, 0 },
<    { },
< };
< 
< MODULE_DEVICE_TABLE(i2c, this_i2c_id);
< 
< static struct i2c_driver this_i2c_driver = {
<    .driver = {
<       .owner = THIS_MODULE,
<       .name = TX_NAME,
<    },
<    .probe = this_i2c_probe,
<    .remove = this_i2c_remove,
<    .id_table = this_i2c_id,
< };
< 
< /*
<  *  ioctl driver (userland frontend)
<  *  ------------
<  */
< static struct file_operations this_cdev_fops = {
<  owner:    THIS_MODULE,
<  open:     this_cdev_open,
<  release:  this_cdev_release,
<  ioctl:    this_cdev_ioctl,
< };
< 
< /*
<  *  Module :: start up
<  */
< static int __init tx_init(void)
< {
<    tda_instance *this=&our_instance;
<    dev_t dev=0;
<    int err=0;
< 
<    /* 
<       general device context
<    */
<    memset(this,0,sizeof(tda_instance)); 
<    this->param.verbose = param_verbose;
<    this->param.major = param_major;
<    this->param.minor = param_minor;
< 
<    /* Hello word */
<    printk(KERN_INFO "%s(%s) %d.%d.%d compiled: %s %s %s\n", HDMITX_NAME, TDA_NAME, 
<           TDA_VERSION_MAJOR,
<           TDA_VERSION_MINOR,
<           TDA_VERSION_PATCHLEVEL, 
<           __DATE__, __TIME__, TDA_VERSION_EXTRA);
<    if (this->param.verbose) LOG(KERN_INFO,".verbose mode\n");
< 
<    /*
<      plug I2C (backend : Hw interfacing)
<    */
<    err = i2c_add_driver(&this_i2c_driver);
<    if (err < 0) {
<       printk(KERN_ERR "Driver registration failed\n");
<       return -ENODEV;
<    }
< 
<    if (this->driver.i2c_client == NULL) {
<       printk(KERN_ERR "this->driver.i2c_client not allocated\n");
<       /* unregister i2c */
<       err = -ENODEV;
<       goto init_out;
<    }
< 
<    /*
<      cdev init (userland frontend)
<    */
< 
<    /* arbitray range of device numbers */
<    if (this->param.major) {
<       /* user force major number @ insmod */
<       dev = MKDEV(this->param.major, this->param.minor);
<       err = register_chrdev_region(dev,MAX_MINOR,HDMITX_NAME);
<       if (err) {
<          printk(KERN_ERR "unable to register %s, dev=%d %s\n",HDMITX_NAME,dev,ERR_TO_STR(err));
<          goto init_out;
<       }
<    } else {
<       /* fully dynamic major number */
<       err = alloc_chrdev_region(&dev, this->param.minor, MAX_MINOR,HDMITX_NAME);
<       if (err) {
<          printk(KERN_ERR "unable to alloc chrdev region for %s, dev=%d %s\n",HDMITX_NAME,dev,ERR_TO_STR(err));
<          goto init_out;
<       }
<       this->param.major = MAJOR(dev);
<       this->param.minor = MINOR(dev);
<       /*       create_dev("/dev/hdmitx",dev); */
<       LOG(KERN_INFO,"/dev/hdmitx created major:%d minor:%d\n",this->param.major, this->param.minor);
<    }
< 
<    cdev_init(this_cdev, &this_cdev_fops);
<    this_cdev->owner = THIS_MODULE;
< 
<    this->driver.class = class_create(THIS_MODULE, HDMITX_NAME);
<    if (IS_ERR(this->driver.class)) {
<       printk(KERN_INFO "Error creating mmap device class.\n");
<       err =-EIO;
<       goto init_out;
<    }
<    this->driver.dev=device_create(this->driver.class, NULL /* parent */, dev, NULL, HDMITX_NAME);
< 
<    this->driver.devno = dev;
<    err = cdev_add(this_cdev, this->driver.devno, MAX_MINOR);
<    if (err){
<       printk(KERN_INFO "unable to add device for %s, ipp_driver.devno=%d %s\n",HDMITX_NAME,this->driver.devno,ERR_TO_STR(err));
<       device_destroy(this->driver.class,this->driver.devno);
<       class_destroy(this->driver.class);
<       unregister_chrdev_region(this->driver.devno, MAX_MINOR);
<       goto init_out;
<    }   
< 
<    /* 
<       general device context
<    */
<    init_MUTEX(&this->driver.sem);
<    hdmi_enable();
<    return 0;
< 
<  init_out:
<    i2c_del_driver(&this_i2c_driver);
<    return err;
< }
< 
< /*
<  *  Module :: shut down
<  */
< static void __exit tx_exit(void)
< {
<    tda_instance *this=&our_instance;
< 
<    LOG(KERN_INFO,"called\n");
< 
< #ifdef IRQ
<    free_irq(gpio_to_irq(TDA_IRQ_CALIB), NULL);
<    gpio_free(TDA_IRQ_CALIB);
< #else
<    del_timer(&this->driver.no_irq_timer);
< #endif
< 
<    del_timer(&this->driver.hdcp_check);
<    msleep(100);
< 
<    /* close DevLib */
<    tmdlHdmiTxClose(this->tda.instance);
< 
<    /* unregister cdevice */
<    cdev_del(this_cdev); 
<    unregister_chrdev_region(this->driver.devno, MAX_MINOR);
<    
<    /* unregister device */
<    device_destroy(this->driver.class,this->driver.devno);
<    class_destroy(this->driver.class);
< 
<    /* unregister i2c */
<    i2c_del_driver(&this_i2c_driver);
< }
< 
< 
< /*
<  *  Module
<  *  ------
<  */
< /* late_initcall(tx_init); */
< module_init(tx_init);
< module_exit(tx_exit);
< 
< /*
<  *  Disclamer
<  *  ---------
<  */
< MODULE_LICENSE("GPL");
< MODULE_AUTHOR("Andre Lepine <andre.lepine@nxp.com>");
< MODULE_DESCRIPTION(HDMITX_NAME " driver");
---
> /*****************************************************************************/
> /* Copyright (c) 2009 NXP Semiconductors BV                                  */
> /*                                                                           */
> /* This program is free software; you can redistribute it and/or modify      */
> /* it under the terms of the GNU General Public License as published by      */
> /* the Free Software Foundation, using version 2 of the License.             */
> /*                                                                           */
> /* This program is distributed in the hope that it will be useful,           */
> /* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
> /* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              */
> /* GNU General Public License for more details.                              */
> /*                                                                           */
> /* You should have received a copy of the GNU General Public License         */
> /* along with this program; if not, write to the Free Software               */
> /* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307       */
> /* USA.                                                                      */
> /*                                                                           */
> /*****************************************************************************/
> 
> #define _tx_c_
> 
> #include <linux/kernel.h>
> #include <linux/init.h>
> #include <linux/module.h>
> #include <linux/cdev.h>  
> #include <linux/fs.h>
> #include <linux/ioctl.h>
> #include <linux/i2c.h>
> #include <linux/delay.h>
> #include <linux/workqueue.h>
> #include <linux/interrupt.h>
> #include <asm/uaccess.h>
> #include <mach/gpio.h>
> //[jaeseong.gim] -header
> //#include <mach/display.h>
> 
> /* HDMI DevLib */
> #include "tmNxCompId.h"
> #include "tmdlHdmiTx_Types.h"
> #include "tmdlHdmiTx_Functions.h"
> 
> /* local */
> #include "tda998x_version.h"
> #include "tda998x.h"
> #include "tda998x_ioctl.h"
> 
> //[jaeseong.gim] +header
> #include <../msm/msm_fb.h>
> #include <linux/display.h>
> #include <linux/types.h>
> #include <linux/bitops.h>
> 
> 
> #ifdef ANDROID_DSS
> /* DSS hack */
> #include <../omap2/dss/dss.h>
> #endif
> 
> /*
>  *
>  * DEFINITION
>  * ----------
>  * LEVEL 0
>  *
>  */
> 
> /*
>  *  Global
>  */
> 
> tda_instance our_instance;
> static struct cdev our_cdev, *this_cdev=&our_cdev;
> #ifdef ANDROID_DSS
> static struct omap_video_timings video_720x480at60Hz_panel_timings = {
>    .x_res          = 720,
>    .y_res          = 480,
>    .pixel_clock    = 27027,
>    .hfp            = 16,
>    .hbp            = 60,
>    .hsw            = 62,
>    .vfp            = 9,
>    .vbp            = 30,
>    .vsw            = 6,
> };
> static struct omap_video_timings video_1280x720at50Hz_panel_timings = {
>    .x_res          = 1280,
>    .y_res          = 720,
>    .pixel_clock    = 74250,
> #ifdef ZOOMII_PATCH
>    .hfp            = 400,
>    .hbp            = 260,
> #else
>    .hfp            = 440,
>    .hbp            = 220,
> #endif
>    .hsw            = 40,
>    .vfp            = 5,
>    .vbp            = 20,
>    .vsw            = 5,
> };
> static struct omap_video_timings video_1280x720at60Hz_panel_timings = {
>    .x_res          = 1280,
>    .y_res          = 720,
>    .pixel_clock    = 74250,
> #ifdef ZOOMII_PATCH
>    .hfp            = 70,
>    .hbp            = 260,
> #else
>    .hfp            = 110,
>    .hbp            = 220,
> #endif
>    .hsw            = 40,
>    .vfp            = 5,
>    .vbp            = 20,
>    .vsw            = 5,
> };
> static struct omap_video_timings video_800x480at60Hz_panel_timings = {
>    /*    .x_res = 800 /\* 1280 *\/, */
>    /*    .y_res = 480 /\* 720 *\/, */
>    /*    .pixel_clock = 21800 /\* 21800 23800 25700 *\/, */
>    .x_res = 800,
>    .y_res = 480,
>    .pixel_clock = 21800,
>    .hfp = 6,
>    .hsw = 1,
>    .hbp = 4,
>    .vfp = 3,
>    .vsw = 1,
>    .vbp = 4,
> };
> 
> struct omap_dss_device *sysdss;
> #endif
> 
> #if 1
> //jaeseong.gim
> 
> /*
> 
> panel_info={
>    .xres = 800,
>    .yres = 480,
> 	.type = DTV_PANEL,
> 	.pdest = DISPLAY_2,
> 	.wait_cycle = 0,
> 	.bpp = 24, //test
> 	.fb_num = 2,
> 	.clk_rate = 21800000,
>    //.hfp = 6,
>    //.hsw = 1,
>    //.hbp = 4,
>    //.vfp = 3,
>    //.vsw = 1,
>    //.vbp = 4,
> },
> panel_info={
> 	.xres          = 1280,
> 	.yres          = 720,
> 	.type = DTV_PANEL,
> 	.pdest = DISPLAY_2,
> 	.wait_cycle = 0,
> 	.bpp = 24, //test
> 	.fb_num = 2,
> 	.clk_rate = 74250000,
> };
> */
> 
> 
> 
> 
> struct msm_fb_panel_data hdmi_panel_data={
> 	.panel_info={
> 		.xres          = 1280,
> 		.yres          = 720,
> 		.type = DTV_PANEL,
> 		.pdest = DISPLAY_2,
> 		.wait_cycle = 0,
> 		.bpp = 24, //test
> 		.fb_num = 2,
> 		.clk_rate = 74250000,
> 		//.xres = 640,
> 		//.yres = 480,
> 		//.type = DTV_PANEL,
> 		//.pdest = DISPLAY_2,
> 		//.wait_cycle = 0,
> 		//.bpp = 24, //test
> 		//.fb_num = 2,
> 		//.clk_rate = 21800000,
> 	},
> };
> 
> 
> struct platform_device hdmi_device={
> 	.id=2,
> 	.dev={
> 		.platform_data=&hdmi_panel_data,
> 	},
> };
> 
> 
> 
> #endif
> 
> 
> 
> 
> /* #define HDCP_TEST 1 */
> #ifdef HDCP_TEST
> /* TEST */
> int test = 0;
> #endif
> 
> /*
>  *  Module params
>  */
> 
> //[jaeseong.gim] 0->1
> static int param_verbose=1,param_major=0,param_minor=0;
> module_param_named(verbose,param_verbose,int,S_IRUGO | S_IWUSR);
> MODULE_PARM_DESC(verbose, "Make the driver verbose");
> module_param_named(major, param_major, int, S_IRUGO);
> MODULE_PARM_DESC(major, "The major number of the device mapper");
> 
> /*
>  *
>  * TOOLBOX
>  * -------
>  * LEVEL 1
>  *
>  * - i2c read/write
>  * - chip Id check
>  * - i2c client info
>  * 
>  */
> 
> 
> /* 
>  *  no mknod nor busybox, so patch it
>  */
> /* static int create_dev(char *name, dev_t dev) */
> /* { */
> /*    sys_unlink(name); */
> /*    return sys_mknod((const char __user *) name, S_IFCHR|0666 /\* S_IFCHR | S_IRUSR | S_IWUSR *\/, new_encode_dev(dev)); */
> /* } */
> 
> /* 
>  *  Get main and unique I2C Client driver handle
>  */
> struct i2c_client *GetThisI2cClient(void)
> {
>    tda_instance *this=&our_instance;
>    return this->driver.i2c_client;
> }
> 
> /*
>  * error handling
>  */
> char *hdmi_tx_err_string(int err)
> {
>    switch (err & 0x0FFF)
>       {
>       case TM_ERR_COMPATIBILITY: {return "SW Interface compatibility";break;}
>       case TM_ERR_MAJOR_VERSION: {return "SW Major Version error";break;}
>       case TM_ERR_COMP_VERSION: {return "SW component version error";break;}
>       case TM_ERR_BAD_UNIT_NUMBER: {return "Invalid device unit number";break;}
>       case TM_ERR_BAD_INSTANCE: {return "Bad input instance value  ";break;}
>       case TM_ERR_BAD_HANDLE: {return "Bad input handle";break;}
>       case TM_ERR_BAD_PARAMETER: {return "Invalid input parameter";break;}
>       case TM_ERR_NO_RESOURCES: {return "Resource is not available ";break;}
>       case TM_ERR_RESOURCE_OWNED: {return "Resource is already in use";break;}
>       case TM_ERR_RESOURCE_NOT_OWNED: {return "Caller does not own resource";break;}
>       case TM_ERR_INCONSISTENT_PARAMS: {return "Inconsistent input params";break;}
>       case TM_ERR_NOT_INITIALIZED: {return "Component is not initialised";break;}
>       case TM_ERR_NOT_SUPPORTED: {return "Function is not supported";break;}
>       case TM_ERR_INIT_FAILED: {return "Initialization failed";break;}
>       case TM_ERR_BUSY: {return "Component is busy";break;}
>       case TMDL_ERR_DLHDMITX_I2C_READ: {return "Read error";break;}
>       case TMDL_ERR_DLHDMITX_I2C_WRITE: {return "Write error";break;}
>       case TM_ERR_FULL: {return "Queue is full";break;}
>       case TM_ERR_NOT_STARTED: {return "Function is not started";break;}
>       case TM_ERR_ALREADY_STARTED: {return "Function is already starte";break;}
>       case TM_ERR_ASSERTION: {return "Assertion failure";break;}
>       case TM_ERR_INVALID_STATE: {return "Invalid state for function";break;}
>       case TM_ERR_OPERATION_NOT_PERMITTED: {return "Corresponds to posix EPERM";break;}
>       case TMDL_ERR_DLHDMITX_RESOLUTION_UNKNOWN: {return "Bad format";break;}
>       case TM_OK: {return "OK";break;}
>       case 0xDEAD0001: {return "No EDID received";break;}
>       default : {printk(KERN_INFO "(err:%x) ",err);return "unknown";break;}
>       }
> }
> 
> static char *tda_spy_event(int event)
> {
>    switch (event)
>       {
>       case TMDL_HDMITX_HDCP_ACTIVE: {return "HDCP active";break;}
>       case TMDL_HDMITX_HDCP_INACTIVE: {return "HDCP inactive";break;}
>       case TMDL_HDMITX_HPD_ACTIVE: {return "HPD active";break;}
>       case TMDL_HDMITX_HPD_INACTIVE: {return "HPD inactive";break;}
>       case TMDL_HDMITX_RX_KEYS_RECEIVED: {return "Rx keys received";break;}
>       case TMDL_HDMITX_RX_DEVICE_ACTIVE: {return "Rx device active";break;}
>       case TMDL_HDMITX_RX_DEVICE_INACTIVE: {return "Rx device inactive";break;}
>       case TMDL_HDMITX_EDID_RECEIVED: {return "EDID received";break;}
>       default : {return "Unkonwn format";break;}
>       }
> }
> 
> static char *tda_spy_hsdc_fail_status(int fail)
> {
>    switch (fail)
>       {
>       case TMDL_HDMITX_HDCP_OK: {return "ok";break;}
>       case  TMDL_HDMITX_HDCP_BKSV_RCV_FAIL: {return "Source does not receive Sink BKsv ";break;}
>       case TMDL_HDMITX_HDCP_BKSV_CHECK_FAIL: {return "BKsv does not contain 20 zeros and 20 ones";break;}
>       case TMDL_HDMITX_HDCP_BCAPS_RCV_FAIL: {return "Source does not receive Sink Bcaps";break;}
>       case TMDL_HDMITX_HDCP_AKSV_SEND_FAIL: {return "Source does not send AKsv";break;}
>       case TMDL_HDMITX_HDCP_R0_RCV_FAIL: {return "Source does not receive R'0";break;}
>       case TMDL_HDMITX_HDCP_R0_CHECK_FAIL: {return "R0 = R'0 check fail";break;}
>       case TMDL_HDMITX_HDCP_BKSV_NOT_SECURE: {return "bksv not secure";break;}
>       case TMDL_HDMITX_HDCP_RI_RCV_FAIL: {return "Source does not receive R'i";break;}
>       case TMDL_HDMITX_HDCP_RPT_RI_RCV_FAIL: {return "Source does not receive R'i repeater mode";break;}
>       case TMDL_HDMITX_HDCP_RI_CHECK_FAIL: {return "RI = R'I check fail";break;}
>       case TMDL_HDMITX_HDCP_RPT_RI_CHECK_FAIL: {return "RI = R'I check fail repeater mode";break;}
>       case TMDL_HDMITX_HDCP_RPT_BCAPS_RCV_FAIL: {return "Source does not receive Sink Bcaps repeater mode";break;}
>       case TMDL_HDMITX_HDCP_RPT_BCAPS_READY_TIMEOUT: {return "bcaps ready timeout";break;}
>       case TMDL_HDMITX_HDCP_RPT_V_RCV_FAIL: {return "Source does not receive V";break;}
>       case TMDL_HDMITX_HDCP_RPT_BSTATUS_RCV_FAIL: {return "Source does not receive BSTATUS repeater mode";break;}
>       case TMDL_HDMITX_HDCP_RPT_KSVLIST_RCV_FAIL: {return "Source does not receive Ksv list in repeater mode";break;}
>       case TMDL_HDMITX_HDCP_RPT_KSVLIST_NOT_SECURE: {return "ksvlist not secure";break;}
>       default: {return "";break;}
>       }
> }
> 
> #ifdef TMFL_TDA19989
> static char *tda_spy_sink(int sink)
> {
>    switch (sink)
>       {
>       case TMDL_HDMITX_SINK_DVI: {return "DVI";break;}
>       case TMDL_HDMITX_SINK_HDMI: {return "HDMI";break;}
>       case TMDL_HDMITX_SINK_EDID: {return "As currently defined in EDID";break;}
>       default : {return "Unkonwn sink";break;}
>       }
> }
> 
> static char *tda_spy_aspect_ratio(int ar)
> {
>    switch (ar)
>       {
>       case TMDL_HDMITX_P_ASPECT_RATIO_UNDEFINED: {return "Undefined picture aspect rati";break;}
>       case TMDL_HDMITX_P_ASPECT_RATIO_6_5: {return "6:5 picture aspect ratio (PAR";break;}
>       case TMDL_HDMITX_P_ASPECT_RATIO_5_4: {return "5:4 PA";break;}
>       case TMDL_HDMITX_P_ASPECT_RATIO_4_3: {return "4:3 PA";break;}
>       case TMDL_HDMITX_P_ASPECT_RATIO_16_10: {return "16:10 PA";break;}
>       case TMDL_HDMITX_P_ASPECT_RATIO_5_3: {return "5:3 PA";break;}
>       case TMDL_HDMITX_P_ASPECT_RATIO_16_9: {return "16:9 PA";break;}
>       case TMDL_HDMITX_P_ASPECT_RATIO_9_5: {return "9:5 PA";break;}
>       default : {return "Unknown aspect ratio";break;}
>       }
> }
> 
> #if 0 /* no more used */
> static char *tda_spy_edid_status(int status)
> {
>    switch (status)
>       {
>       case TMDL_HDMITX_EDID_READ: {return "All blocks read";break;}
>       case TMDL_HDMITX_EDID_READ_INCOMPLETE: {return "All blocks read OK but buffer too small to return all of the";break;}
>       case TMDL_HDMITX_EDID_ERROR_CHK_BLOCK_0: {return "Block 0 checksum erro";break;}
>       case TMDL_HDMITX_EDID_ERROR_CHK: {return "Block 0 OK, checksum error in one or more other block";break;}
>       case TMDL_HDMITX_EDID_NOT_READ: {return "EDID not read";break;}
>       case TMDL_HDMITX_EDID_STATUS_INVALID: {return "Invalid ";break;}
>       default : {return "Unknown edid status";break;}
>       }
> }
> #endif
> 
> static char *tda_spy_hdcp_status(int status)
> {
>    switch (status)
>       {
>       case TMDL_HDMITX_HDCP_CHECK_NOT_STARTED: {return "Check not started";break;}
>       case TMDL_HDMITX_HDCP_CHECK_IN_PROGRESS: {return "No failures, more to do";break;}
>       case TMDL_HDMITX_HDCP_CHECK_PASS: {return "Final check has passed";break;}
>       case TMDL_HDMITX_HDCP_CHECK_FAIL_FIRST: {return "First check failure code\nDriver not AUTHENTICATED";break;}
>       case TMDL_HDMITX_HDCP_CHECK_FAIL_DEVICE_T0: {return "A T0 interrupt occurred";break;}
>       case TMDL_HDMITX_HDCP_CHECK_FAIL_DEVICE_RI: {return "Device RI changed";break;}
>       case TMDL_HDMITX_HDCP_CHECK_FAIL_DEVICE_FSM: {return "Device FSM not 10h";break;}
>       default : {return "Unknown hdcp status";break;}
>       }
> }
> 
> static char *tda_spy_vfmt(int fmt)
> {
>    switch (fmt)
>       {
>       case TMDL_ERR_DLHDMITX_COMPATIBILITY: {return "SW Interface compatibility";break;}
>       case TMDL_ERR_DLHDMITX_MAJOR_VERSION: {return "SW Major Version error";break;}
> 
>       case TMDL_HDMITX_VFMT_NULL: {return "Not a valid format...";break;}
>       case TMDL_HDMITX_VFMT_01_640x480p_60Hz: {return "Format 01 640  x 480p  60Hz";break;}
>       case TMDL_HDMITX_VFMT_02_720x480p_60Hz: {return "Format 02 720  x 480p  60Hz";break;}
>       case TMDL_HDMITX_VFMT_03_720x480p_60Hz: {return "Format 03 720  x 480p  60Hz";break;}
>       case TMDL_HDMITX_VFMT_04_1280x720p_60Hz: {return "Format 04 1280 x 720p  60Hz";break;}
>       case TMDL_HDMITX_VFMT_05_1920x1080i_60Hz: {return "Format 05 1920 x 1080i 60Hz";break;}
>       case TMDL_HDMITX_VFMT_06_720x480i_60Hz: {return "Format 06 720  x 480i  60Hz";break;}
>       case TMDL_HDMITX_VFMT_07_720x480i_60Hz: {return "Format 07 720  x 480i  60Hz";break;}
>       case TMDL_HDMITX_VFMT_08_720x240p_60Hz: {return "Format 08 720  x 240p  60Hz";break;}
>       case TMDL_HDMITX_VFMT_09_720x240p_60Hz: {return "Format 09 720  x 240p  60Hz";break;}
>       case TMDL_HDMITX_VFMT_10_720x480i_60Hz: {return "Format 10 720  x 480i  60Hz";break;}
>       case TMDL_HDMITX_VFMT_11_720x480i_60Hz: {return "Format 11 720  x 480i  60Hz";break;}
>       case TMDL_HDMITX_VFMT_12_720x240p_60Hz: {return "Format 12 720  x 240p  60Hz";break;}
>       case TMDL_HDMITX_VFMT_13_720x240p_60Hz: {return "Format 13 720  x 240p  60Hz";break;}
>       case TMDL_HDMITX_VFMT_14_1440x480p_60Hz: {return "Format 14 1440 x 480p  60Hz";break;}
>       case TMDL_HDMITX_VFMT_15_1440x480p_60Hz: {return "Format 15 1440 x 480p  60Hz";break;}
>       case TMDL_HDMITX_VFMT_16_1920x1080p_60Hz: {return "Format 16 1920 x 1080p 60Hz";break;}
>       case TMDL_HDMITX_VFMT_17_720x576p_50Hz: {return "Format 17 720  x 576p  50Hz";break;}
>       case TMDL_HDMITX_VFMT_18_720x576p_50Hz: {return "Format 18 720  x 576p  50Hz";break;}
>       case TMDL_HDMITX_VFMT_19_1280x720p_50Hz: {return "Format 19 1280 x 720p  50Hz";break;}
>       case TMDL_HDMITX_VFMT_20_1920x1080i_50Hz: {return "Format 20 1920 x 1080i 50Hz";break;}
>       case TMDL_HDMITX_VFMT_21_720x576i_50Hz: {return "Format 21 720  x 576i  50Hz";break;}
>       case TMDL_HDMITX_VFMT_22_720x576i_50Hz: {return "Format 22 720  x 576i  50Hz";break;}
>       case TMDL_HDMITX_VFMT_23_720x288p_50Hz: {return "Format 23 720  x 288p  50Hz";break;}
>       case TMDL_HDMITX_VFMT_24_720x288p_50Hz: {return "Format 24 720  x 288p  50Hz";break;}
>       case TMDL_HDMITX_VFMT_25_720x576i_50Hz: {return "Format 25 720  x 576i  50Hz";break;}
>       case TMDL_HDMITX_VFMT_26_720x576i_50Hz: {return "Format 26 720  x 576i  50Hz";break;}
>       case TMDL_HDMITX_VFMT_27_720x288p_50Hz: {return "Format 27 720  x 288p  50Hz";break;}
>       case TMDL_HDMITX_VFMT_28_720x288p_50Hz: {return "Format 28 720  x 288p  50Hz";break;}
>       case TMDL_HDMITX_VFMT_29_1440x576p_50Hz: {return "Format 29 1440 x 576p  50Hz";break;}
>       case TMDL_HDMITX_VFMT_30_1440x576p_50Hz: {return "Format 30 1440 x 576p  50Hz";break;}
>       case TMDL_HDMITX_VFMT_31_1920x1080p_50Hz: {return "Format 31 1920 x 1080p 50Hz";break;}
>       case TMDL_HDMITX_VFMT_32_1920x1080p_24Hz: {return "Format 32 1920 x 1080p 24Hz";break;}
>       case TMDL_HDMITX_VFMT_33_1920x1080p_25Hz: {return "Format 33 1920 x 1080p 25Hz";break;}
>       case TMDL_HDMITX_VFMT_34_1920x1080p_30Hz: {return "Format 34 1920 x 1080p 30Hz";break;}
>       case TMDL_HDMITX_VFMT_TV_NUM: {return "Number of TV formats & null";break;}
>       case TMDL_HDMITX_VFMT_PC_MIN: {return "Lowest valid PC format";break;}
>       case TMDL_HDMITX_VFMT_PC_800x600p_60Hz: {return "PC format 129";break;}
>       case TMDL_HDMITX_VFMT_PC_1152x960p_60Hz: {return "PC format 130";break;}
>       case TMDL_HDMITX_VFMT_PC_1024x768p_60Hz: {return "PC format 131";break;}
>       case TMDL_HDMITX_VFMT_PC_1280x768p_60Hz: {return "PC format 132";break;}
>       case TMDL_HDMITX_VFMT_PC_1280x1024p_60Hz: {return "PC format 133";break;}
>       case TMDL_HDMITX_VFMT_PC_1360x768p_60Hz: {return "PC format 134";break;}
>       case TMDL_HDMITX_VFMT_PC_1400x1050p_60Hz: {return "PC format 135";break;}
>       case TMDL_HDMITX_VFMT_PC_1600x1200p_60Hz: {return "PC format 136";break;}
>       case TMDL_HDMITX_VFMT_PC_1024x768p_70Hz: {return "PC format 137";break;}
>       case TMDL_HDMITX_VFMT_PC_640x480p_72Hz: {return "PC format 138";break;}
>       case TMDL_HDMITX_VFMT_PC_800x600p_72Hz: {return "PC format 139";break;}
>       case TMDL_HDMITX_VFMT_PC_640x480p_75Hz: {return "PC format 140";break;}
>       case TMDL_HDMITX_VFMT_PC_1024x768p_75Hz: {return "PC format 141";break;}
>       case TMDL_HDMITX_VFMT_PC_800x600p_75Hz: {return "PC format 142";break;}
>       case TMDL_HDMITX_VFMT_PC_1024x864p_75Hz: {return "PC format 143";break;}
>       case TMDL_HDMITX_VFMT_PC_1280x1024p_75Hz: {return "PC format 144";break;}
>       case TMDL_HDMITX_VFMT_PC_640x350p_85Hz: {return "PC format 145";break;}
>       case TMDL_HDMITX_VFMT_PC_640x400p_85Hz: {return "PC format 146";break;}
>       case TMDL_HDMITX_VFMT_PC_720x400p_85Hz: {return "PC format 147";break;}
>       case TMDL_HDMITX_VFMT_PC_640x480p_85Hz: {return "PC format 148";break;}
>       case TMDL_HDMITX_VFMT_PC_800x600p_85Hz: {return "PC format 149";break;}
>       case TMDL_HDMITX_VFMT_PC_1024x768p_85Hz: {return "PC format 150";break;}
>       case TMDL_HDMITX_VFMT_PC_1152x864p_85Hz: {return "PC format 151";break;}
>       case TMDL_HDMITX_VFMT_PC_1280x960p_85Hz: {return "PC format 152";break;}
>       case TMDL_HDMITX_VFMT_PC_1280x1024p_85Hz: {return "PC format 153";break;}
>       case TMDL_HDMITX_VFMT_PC_1024x768i_87Hz: {return "PC format 154";break;}
>       default : {return "Unknown video format";break;}
>       }
> }
> #endif
> 
> static char *tda_ioctl(int io)
> {
>    switch (io)
>       {
>       case TDA_VERBOSE_ON_CMD: {return "TDA_VERBOSE_ON_CMD";break;}
>       case TDA_VERBOSE_OFF_CMD: {return "TDA_VERBOSE_OFF_CMD";break;}
>       case TDA_BYEBYE_CMD: {return "TDA_BYEBYE_CMD";break;}
>       case TDA_GET_SW_VERSION_CMD: {return "TDA_GET_SW_VERSION_CMD";break;}
>       case TDA_SET_POWER_CMD: {return "TDA_SET_POWER_CMD";break;}
>       case TDA_GET_POWER_CMD: {return "TDA_GET_POWER_CMD";break;}
>       case TDA_SETUP_CMD: {return "TDA_SETUP_CMD";break;}
>       case TDA_GET_SETUP_CMD: {return "TDA_GET_SETUP_CMD";break;}
>       case TDA_WAIT_EVENT_CMD: {return "TDA_WAIT_EVENT_CMD";break;}
>       case TDA_ENABLE_EVENT_CMD: {return "TDA_ENABLE_EVENT_CMD";break;}
>       case TDA_DISABLE_EVENT_CMD: {return "TDA_DISABLE_EVENT_CMD";break;}
>       case TDA_GET_VIDEO_SPEC_CMD: {return "TDA_GET_VIDEO_SPEC_CMD";break;}
>       case TDA_SET_INPUT_OUTPUT_CMD: {return "TDA_SET_INPUT_OUTPUT_CMD";break;}
>       case TDA_SET_AUDIO_INPUT_CMD: {return "TDA_SET_AUDIO_INPUT_CMD";break;}
>       case TDA_SET_VIDEO_INFOFRAME_CMD: {return "TDA_SET_VIDEO_INFOFRAME_CMD";break;}
>       case TDA_SET_AUDIO_INFOFRAME_CMD: {return "TDA_SET_AUDIO_INFOFRAME_CMD";break;}
>       case TDA_SET_ACP_CMD: {return "TDA_SET_ACP_CMD";break;}
>       case TDA_SET_GCP_CMD: {return "TDA_SET_GCP_CMD";break;}
>       case TDA_SET_ISRC1_CMD: {return "TDA_SET_ISRC1_CMD";break;}
>       case TDA_SET_ISRC2_CMD: {return "TDA_SET_ISRC2_CMD";break;}
>       case TDA_SET_MPS_INFOFRAME_CMD: {return "TDA_SET_MPS_INFOFRAME_CMD";break;}
>       case TDA_SET_SPD_INFOFRAME_CMD: {return "TDA_SET_SPD_INFOFRAME_CMD";break;}
>       case TDA_SET_VS_INFOFRAME_CMD: {return "TDA_SET_VS_INFOFRAME_CMD";break;}
>       case TDA_SET_AUDIO_MUTE_CMD: {return "TDA_SET_AUDIO_MUTE_CMD";break;}
>       case TDA_RESET_AUDIO_CTS_CMD: {return "TDA_RESET_AUDIO_CTS_CMD";break;}
>       case TDA_GET_EDID_STATUS_CMD: {return "TDA_GET_EDID_STATUS_CMD";break;}
>       case TDA_GET_EDID_AUDIO_CAPS_CMD: {return "TDA_GET_EDID_AUDIO_CAPS_CMD";break;}
>       case TDA_GET_EDID_VIDEO_CAPS_CMD: {return "TDA_GET_EDID_VIDEO_CAPS_CMD";break;}
>       case TDA_GET_EDID_VIDEO_PREF_CMD: {return "TDA_GET_EDID_VIDEO_PREF_CMD";break;}
>       case TDA_GET_EDID_SINK_TYPE_CMD: {return "TDA_GET_EDID_SINK_TYPE_CMD";break;}
>       case TDA_GET_EDID_SOURCE_ADDRESS_CMD: {return "TDA_GET_EDID_SOURCE_ADDRESS_CMD";break;}
>       case TDA_SET_GAMMUT_CMD: {return "TDA_SET_GAMMUT_CMD";break;}
>       case TDA_GET_EDID_DTD_CMD: {return "TDA_GET_EDID_DTD_CMD";break;}
>       case TDA_GET_EDID_MD_CMD: {return "TDA_GET_EDID_MD_CMD";break;}
>       case TDA_GET_EDID_TV_ASPECT_RATIO_CMD: {return "TDA_GET_EDID_TV_ASPECT_RATIO_CMD";break;}
>       case TDA_GET_EDID_LATENCY_CMD: {return "TDA_GET_EDID_LATENCY_CMD";break;}
>       default : {return "unknown";break;}
>       }
> 
> 
> }
> 
> #ifdef TMFL_TDA19989
> /*
>  *  
>  */
> static int tda_spy(int verbose)
> {
>    tda_instance *this=&our_instance;
>    int i,err=0;
> 
>    if (!verbose) {
>       return err;
>    }
> 
>    printk(KERN_INFO "\n<edid video caps>\n");
>    this->tda.edid_video_caps.max=EXAMPLE_MAX_SVD;
>    TRY(tmdlHdmiTxGetEdidVideoCaps(this->tda.instance,              \
>                                   this->tda.edid_video_caps.desc, \
>                                   this->tda.edid_video_caps.max,      \
>                                   &this->tda.edid_video_caps.written, \
>                                   &this->tda.edid_video_caps.flags));
>    printk(KERN_INFO "written:%d\n",this->tda.edid_video_caps.written);
>    printk(KERN_INFO "flags:0X%x\n",this->tda.edid_video_caps.flags);
>    if (this->tda.edid_video_caps.written > this->tda.edid_video_caps.max) {
>       printk(KERN_ERR "get %d video caps but was waiting for %d\n", \
>              this->tda.edid_video_caps.written,                     \
>              this->tda.edid_video_caps.max); 
>       this->tda.edid_video_caps.written = this->tda.edid_video_caps.max;
>    }
>    for(i=0; i<this->tda.edid_video_caps.written;i++) {
>       printk(KERN_INFO "videoFormat:%s\n",tda_spy_vfmt(this->tda.edid_video_caps.desc[i].videoFormat));
>       printk(KERN_INFO "nativeVideoFormat:%s\n",(this->tda.edid_video_caps.desc[i].nativeVideoFormat?"yes":"no"));
>    }
> 
>    printk(KERN_INFO "\n<edid video timings>\n");
>    TRY(tmdlHdmiTxGetEdidVideoPreferred(this->tda.instance, \
>                                        &this->tda.edid_video_timings));
>    printk(KERN_INFO "Pixel Clock/10 000:%d\n",this->tda.edid_video_timings.pixelClock);
>    printk(KERN_INFO "Horizontal Active Pixels:%d\n",this->tda.edid_video_timings.hActivePixels);
>    printk(KERN_INFO "Horizontal Blanking Pixels:%d\n",this->tda.edid_video_timings.hBlankPixels);
>    printk(KERN_INFO "Vertical Active Lines:%d\n",this->tda.edid_video_timings.vActiveLines);
>    printk(KERN_INFO "Vertical Blanking Lines:%d\n",this->tda.edid_video_timings.vBlankLines);
>    printk(KERN_INFO "Horizontal Sync Offset:%d\n",this->tda.edid_video_timings.hSyncOffset);
>    printk(KERN_INFO "Horiz. Sync Pulse Width:%d\n",this->tda.edid_video_timings.hSyncWidth);
>    printk(KERN_INFO "Vertical Sync Offset:%d\n",this->tda.edid_video_timings.vSyncOffset);
>    printk(KERN_INFO "Vertical Sync Pulse Width:%d\n",this->tda.edid_video_timings.vSyncWidth);
>    printk(KERN_INFO "Horizontal Image Size:%d\n",this->tda.edid_video_timings.hImageSize);
>    printk(KERN_INFO "Vertical Image Size:%d\n",this->tda.edid_video_timings.vImageSize);
>    printk(KERN_INFO "Horizontal Border:%d\n",this->tda.edid_video_timings.hBorderPixels);
>    printk(KERN_INFO "Vertical Border:%d\n",this->tda.edid_video_timings.vBorderPixels);
>    printk(KERN_INFO "Interlace/sync info:%x\n",this->tda.edid_video_timings.flags);
> 
>    printk(KERN_INFO "\n<sink type>\n");
>    TRY(tmdlHdmiTxGetEdidSinkType(this->tda.instance,    \
>                                  &this->tda.setio.sink));
>    printk(KERN_INFO "%s\n",tda_spy_sink(this->tda.setio.sink));
>    printk(KERN_INFO "\n<source address>\n");
>    TRY(tmdlHdmiTxGetEdidSourceAddress(this->tda.instance,   \
>                                       &this->tda.src_address));
>    printk(KERN_INFO "%x\n",this->tda.src_address);
>    printk(KERN_INFO "\n<detailled timing descriptors>\n");
>    this->tda.edid_dtd.max=EXAMPLE_MAX_SVD;
>    TRY(tmdlHdmiTxGetEdidDetailledTimingDescriptors(this->tda.instance,  \
>                                                    this->tda.edid_dtd.desc, \
>                                                    this->tda.edid_dtd.max, \
>                                                    &this->tda.edid_dtd.written));
>    printk(KERN_INFO "Interlace/sync info:%x\n",this->tda.edid_dtd.desc[i].flags);
>    printk(KERN_INFO "written:%d\n",this->tda.edid_dtd.written);
>    if (this->tda.edid_dtd.written > this->tda.edid_dtd.max) {
>       printk(KERN_ERR "get %d video caps but was waiting for %d\n", \
>              this->tda.edid_dtd.written,                     \
>              this->tda.edid_dtd.max); 
>       this->tda.edid_dtd.written = this->tda.edid_dtd.max;
>    }
>    for(i=0; i<this->tda.edid_dtd.written;i++) {
>       printk(KERN_INFO "Pixel Clock/10 000:%d\n",this->tda.edid_dtd.desc[i].pixelClock);
>       printk(KERN_INFO "Horizontal Active Pixels:%d\n",this->tda.edid_dtd.desc[i].hActivePixels);
>       printk(KERN_INFO "Horizontal Blanking Pixels:%d\n",this->tda.edid_dtd.desc[i].hBlankPixels);
>       printk(KERN_INFO "Vertical Active Lines:%d\n",this->tda.edid_dtd.desc[i].vActiveLines);
>       printk(KERN_INFO "Vertical Blanking Lines:%d\n",this->tda.edid_dtd.desc[i].vBlankLines);
>       printk(KERN_INFO "Horizontal Sync Offset:%d\n",this->tda.edid_dtd.desc[i].hSyncOffset);
>       printk(KERN_INFO "Horiz. Sync Pulse Width:%d\n",this->tda.edid_dtd.desc[i].hSyncWidth);
>       printk(KERN_INFO "Vertical Sync Offset:%d\n",this->tda.edid_dtd.desc[i].vSyncOffset);
>       printk(KERN_INFO "Vertical Sync Pulse Width:%d\n",this->tda.edid_dtd.desc[i].vSyncWidth);
>       printk(KERN_INFO "Horizontal Image Size:%d\n",this->tda.edid_dtd.desc[i].hImageSize);
>       printk(KERN_INFO "Vertical Image Size:%d\n",this->tda.edid_dtd.desc[i].vImageSize);
>       printk(KERN_INFO "Horizontal Border:%d\n",this->tda.edid_dtd.desc[i].hBorderPixels);
>       printk(KERN_INFO "Vertical Border:%d\n",this->tda.edid_dtd.desc[i].vBorderPixels);
>    }
> 
>    printk(KERN_INFO "\n<monitor descriptors>\n");
>    this->tda.edid_md.max=EXAMPLE_MAX_SVD;
>    TRY(tmdlHdmiTxGetEdidMonitorDescriptors(this->tda.instance,  \
>                                            this->tda.edid_md.desc1,    \
>                                            this->tda.edid_md.desc2,    \
>                                            this->tda.edid_md.other,    \
>                                            this->tda.edid_md.max,       \
>                                            &this->tda.edid_md.written));
>    printk(KERN_INFO "written:%d\n",this->tda.edid_md.written);
>    if (this->tda.edid_md.written > this->tda.edid_md.max) {
>       printk(KERN_ERR "get %d video caps but was waiting for %d\n", \
>              this->tda.edid_md.written,                     \
>              this->tda.edid_md.max); 
>       this->tda.edid_md.written = this->tda.edid_md.max;
>    }
>    for(i=0; i<this->tda.edid_md.written;i++) {
>       if (this->tda.edid_md.desc1[i].descRecord) {
>          this->tda.edid_md.desc1[i].monitorName[EDID_MONITOR_DESCRIPTOR_SIZE]=0;
>          printk(KERN_INFO "Monitor name:%s\n",this->tda.edid_md.desc1[i].monitorName);
>       }
>       if (this->tda.edid_md.desc1[i].descRecord) {
>          printk(KERN_INFO "Min vertical rate in Hz:%d\n",this->tda.edid_md.desc2[i].minVerticalRate);
>          printk(KERN_INFO "Max vertical rate in Hz:%d\n",this->tda.edid_md.desc2[i].maxVerticalRate);
>          printk(KERN_INFO "Min horizontal rate in Hz:%d\n",this->tda.edid_md.desc2[i].minHorizontalRate);
>          printk(KERN_INFO "Max horizontal rate in Hz:%d\n",this->tda.edid_md.desc2[i].maxHorizontalRate);
>          printk(KERN_INFO "Max suuported pixel clock rate in MHz:%d\n",this->tda.edid_md.desc2[i].maxSupportedPixelClk);
>       }
>    }
> 
>    printk(KERN_INFO "\n<TV picture ratio>\n");
>    TRY(tmdlHdmiTxGetEdidTVPictureRatio(this->tda.instance,  \
>                                        &this->tda.edid_tv_aspect_ratio));
>    printk(KERN_INFO "%s\n",tda_spy_aspect_ratio(this->tda.edid_tv_aspect_ratio));
> 
>    printk(KERN_INFO "\n<latency info>\n");
>    TRY(tmdlHdmiTxGetEdidLatencyInfo(this->tda.instance, \
>                                     &this->tda.edid_latency));
>    if (this->tda.edid_latency.latency_available) {
>       printk(KERN_INFO "Edid video:%d\n",this->tda.edid_latency.Edidvideo_latency);
>       printk(KERN_INFO "Edid audio:%d\n",this->tda.edid_latency.Edidaudio_latency);
>    }
>    if (this->tda.edid_latency.Ilatency_available) {
>       printk(KERN_INFO "Edid Ivideo:%d\n",this->tda.edid_latency.EdidIvideo_latency);
>       printk(KERN_INFO "Edid Iaudio:%d\n",this->tda.edid_latency.EdidIaudio_latency);
>    }
>  TRY_DONE:
>    return err;
> }
> #endif
> 
> /*
>  *
>  * PROCESSING
>  * ----------
>  * LEVEL 2
>  *
>  * - 
>  *
>  */
> 
> 
> /*
>  * On/Off HDCP
>  */
> void hdcp_onoff(tda_instance *this) {
> 
>    int err=0;
> 
> /*    printk("DBG %s status:%d enable:%d\n",__func__,this->tda.hdcp_status,this->tda.hdcp_enable); */
>    if (this->tda.rx_device_active) {
>       if (this->tda.hot_plug_detect == TMDL_HDMITX_HOTPLUG_ACTIVE) {
>          if (this->tda.power == tmPowerOn) {
>             if (this->tda.src_address != 0xFFFF) {
>                if (this->tda.hdcp_status!=TMDL_HDMITX_HDCP_CHECK_NUM) {/* ugly is bad */
>                   if (this->tda.hdcp_status == TMDL_HDMITX_HDCP_CHECK_NOT_STARTED) {
>                      if (this->tda.hdcp_enable) {
>                         TRY(tmdlHdmiTxSetHdcp(this->tda.instance,True));
>                      }
>                   }
>                   else if (this->tda.hdcp_status != TMDL_HDMITX_HDCP_CHECK_NOT_STARTED) {
>                      if (!this->tda.hdcp_enable) {
>                         TRY(tmdlHdmiTxSetHdcp(this->tda.instance,False));
>                      }
>                   }
>                }
>             }
>          }
>       }
>    }
> TRY_DONE:
>    (void)0;
> }
> 
> 
> /*
>  * Run video
>  */
> void show_video(tda_instance *this) {
> 
>    int err=0;
> 
>    if (this->tda.rx_device_active) {
>       if (this->tda.hot_plug_detect == TMDL_HDMITX_HOTPLUG_ACTIVE) {
>          if (this->tda.power == tmPowerOn) {
>             if (this->tda.src_address != 0xFFFF) {
>                TRY(tmdlHdmiTxSetInputOutput(this->tda.instance,     \
>                                             this->tda.setio.video_in,   \
>                                             this->tda.setio.video_out,  \
>                                             this->tda.setio.audio_in,   \
>                                             this->tda.setio.sink));
>                hdcp_onoff(this);
>             }
>          }
>       }
>    }
>  TRY_DONE:
>    (void)0;
> }
> 
> /*
>  *  TDA interrupt polling
>  */
> static void interrupt_polling(struct work_struct *dummy)
> {
>    tda_instance *this=&our_instance;
>    int err=0;
> 
>    /* Tx part */
>    TRY(tmdlHdmiTxHandleInterrupt(this->tda.instance));
> 
>    /* CEC part */
>    if (this->driver.cec_callback) this->driver.cec_callback(dummy);
> 
>  TRY_DONE:
> 
>    /* setup next polling */
> #ifndef IRQ
>    mod_timer(&this->driver.no_irq_timer,jiffies + ( CHECK_EVERY_XX_MS * HZ / 1000 ));
> #endif
> 
>    (void)0;
> }
> 
> /*
>  *  TDA interrupt polling
>  */
> static void hdcp_check(struct work_struct *dummy)
> {
>    int err=0;
>    tda_instance *this=&our_instance;
>    tmdlHdmiTxHdcpCheck_t hdcp_status;
> 
>    down(&this->driver.sem);
> 
>    if (this->tda.hdcp_status==TMDL_HDMITX_HDCP_CHECK_NUM) goto TRY_DONE; /* ugly is bad */
> 
>    TRY(tmdlHdmiTxHdcpCheck(this->tda.instance,HDCP_CHECK_EVERY_MS));
>    TRY(tmdlHdmiTxGetHdcpState(this->tda.instance, &hdcp_status));
>    if (this->tda.hdcp_status != hdcp_status) {
>       LOG(KERN_INFO,"HDCP status:%s\n",tda_spy_hdcp_status(hdcp_status));
>       this->tda.hdcp_status = hdcp_status;
>    }
> 
> #ifdef HDCP_TEST
>    /* TEST */
>    if (test++>500) {
>       test=0;
>       this->tda.hdcp_enable=1-this->tda.hdcp_enable;
>       printk("TEST hdcp:%d\n",this->tda.hdcp_enable);
>       hdcp_onoff(this);
>    }
> #endif
> 
>  TRY_DONE:
> 
>    /* setup next polling */
>    mod_timer(&this->driver.hdcp_check,jiffies + ( HDCP_CHECK_EVERY_MS * HZ / 1000 ));
> 
>    up(&this->driver.sem);
> }
> 
> void register_cec_interrupt(cec_callback_t fct)
> {
>    tda_instance *this=&our_instance;
> 
>    this->driver.cec_callback = fct;
> }
> EXPORT_SYMBOL(register_cec_interrupt);
> 
> void unregister_cec_interrupt(void)
> {
>    tda_instance *this=&our_instance;
> 
>    this->driver.cec_callback = NULL;
> }
> EXPORT_SYMBOL(unregister_cec_interrupt);
> 
> static DECLARE_WORK(wq_irq, interrupt_polling);
> void polling_timeout(unsigned long arg)
> {
>    /* derefered because ATOMIC context of timer does not support I2C_transfert */
>    schedule_work(&wq_irq);
> }
> 
> static DECLARE_WORK(wq_hdcp, hdcp_check);
> void hdcp_check_timeout(unsigned long arg)
> {
>    /* derefered because ATOMIC context of timer does not support I2C_transfert */
>    schedule_work(&wq_hdcp);
> }
> 
> #ifdef IRQ
> /*
>  *  TDA irq
>  */
> static irqreturn_t tda_irq(int irq, void *_udc)
> {
> 
>    /* do it now */
>    schedule_work(&wq_irq);
> 
>    return IRQ_HANDLED;
> }
> #endif
> 
> /*
>  *  TDA callback
>  */
> static void eventCallbackTx(tmdlHdmiTxEvent_t event)
> {
>    tda_instance *this=&our_instance;
>    int err=0;
>    unsigned short new_addr;
> 
>    this->tda.event=event;
>    printk(KERN_INFO "hdmi %s\n",tda_spy_event(event));
> 
>    switch (event) {
>    case TMDL_HDMITX_EDID_RECEIVED:
>       TRY(tmdlHdmiTxGetEdidSourceAddress(this->tda.instance,        \
>                                          &new_addr));
>       LOG(KERN_INFO,"phy.@:%x\n",new_addr);
>       /*       if (this->tda.src_address == new_addr) { */
>       /*          break; */
>       /*       } */
>       this->tda.src_address = new_addr;
> #ifdef TMFL_TDA19989
>       tda_spy(this->param.verbose>1);
> #endif
>       /* 
>          Customer may add stuff to analyse EDID (see tda_spy())
>          and select automatically some video/audio settings.
>          By default, let go on with next case and activate
>          default video/audio settings with tmdlHdmiTxSetInputOutput()
>       */
>       msleep(100);
>    case TMDL_HDMITX_RX_DEVICE_ACTIVE:
>       this->tda.rx_device_active = 1;
>       show_video(this);
>       break;
>    case TMDL_HDMITX_RX_DEVICE_INACTIVE: 
>       this->tda.rx_device_active = 0;
>       break;
>    case TMDL_HDMITX_HPD_ACTIVE: 
>       this->tda.hot_plug_detect = TMDL_HDMITX_HOTPLUG_ACTIVE;
>       show_video(this);
>       break;
>    case TMDL_HDMITX_HPD_INACTIVE: 
>       this->tda.hot_plug_detect = TMDL_HDMITX_HOTPLUG_INACTIVE;
>       this->tda.src_address = 0xFFFF;
>       break;
>    case TMDL_HDMITX_HDCP_INACTIVE:
>       tmdlHdmiTxGetHdcpFailStatus(this->tda.instance, \
>                                   &this->tda.hdcp_fail, \
>                                   &this->tda.hdcp_raw_status);
>       if (this->tda.hdcp_fail) {
>          LOG(KERN_INFO,"%s (%d)\n",tda_spy_hsdc_fail_status(this->tda.hdcp_fail),this->tda.hdcp_raw_status);
>       }
>       tmdlHdmiTxSetBScreen(this->tda.instance,TMDL_HDMITX_PATTERN_BLUE);
>       break;
>    case TMDL_HDMITX_RX_KEYS_RECEIVED:
>       tmdlHdmiTxRemoveBScreen(this->tda.instance);
>       break;
>    default:
>       break;
>    }
> 
>    this->driver.poll_done=true;
>    wake_up_interruptible(&this->driver.wait);
>    
>  TRY_DONE:
>    (void)0;
> }
> 
> /*
>  *  hdmi Tx init
>  */
> static int hdmi_tx_init(tda_instance *this)
> {
>    int err=0;
> 
>    LOG(KERN_INFO,"called\n");
> 
>    //[jaeseong.gim] +2lines
>    gpio_set_value(109,1);
>    mdelay(10);
> 
> 
>    /*Initialize HDMI Transmiter*/
>    TRY(tmdlHdmiTxOpen(&this->tda.instance));
>    /* Register the HDMI TX events callbacks */
>    TRY(tmdlHdmiTxRegisterCallbacks(this->tda.instance,(ptmdlHdmiTxCallback_t)eventCallbackTx));
>    /* EnableEvent, all by default */
>    TRY(tmdlHdmiTxEnableEvent(this->tda.instance,TMDL_HDMITX_HDCP_ACTIVE));
>    TRY(tmdlHdmiTxEnableEvent(this->tda.instance,TMDL_HDMITX_HDCP_INACTIVE));
>    TRY(tmdlHdmiTxEnableEvent(this->tda.instance,TMDL_HDMITX_HPD_ACTIVE));
>    TRY(tmdlHdmiTxEnableEvent(this->tda.instance,TMDL_HDMITX_HPD_INACTIVE));
>    TRY(tmdlHdmiTxEnableEvent(this->tda.instance,TMDL_HDMITX_RX_KEYS_RECEIVED));
>    TRY(tmdlHdmiTxEnableEvent(this->tda.instance,TMDL_HDMITX_RX_DEVICE_ACTIVE));
>    TRY(tmdlHdmiTxEnableEvent(this->tda.instance,TMDL_HDMITX_RX_DEVICE_INACTIVE));
>    TRY(tmdlHdmiTxEnableEvent(this->tda.instance,TMDL_HDMITX_EDID_RECEIVED));
> 
>    /* Size of the application EDID buffer */
>    this->tda.setup.edidBufferSize=EDID_BLOCK_COUNT * EDID_BLOCK_SIZE;
>    /* Buffer to store the application EDID data */
>    this->tda.setup.pEdidBuffer=this->tda.raw_edid;
>    /* To Enable/disable repeater feature, nor relevant here */
>    this->tda.setup.repeaterEnable=false;
>    /* To enable/disable simplayHD feature: blue screen when not authenticated */
>    this->tda.setup.simplayHd=false;
>    
> 
>    /* Provides HDMI TX instance configuration */
>    TRY(tmdlHdmiTxInstanceSetup(this->tda.instance,&this->tda.setup));
>    /* Get IC version */
>    TRY(tmdlHdmiTxGetCapabilities(&this->tda.capabilities));
> 
>    /* Main settings */
>    this->tda.setio.video_out.mode = TMDL_HDMITX_VOUTMODE_RGB444;
>    this->tda.setio.video_out.colorDepth = TMDL_HDMITX_COLORDEPTH_24;
> #ifdef TMFL_TDA19989
>    this->tda.setio.video_out.dviVqr = TMDL_HDMITX_VQR_DEFAULT; /* Use HDMI rules for DVI output */
> #endif
>    /*    this->tda.setio.video_out.format = TMDL_HDMITX_VFMT_04_1280x720p_60Hz; */
>    /*    this->tda.setio.video_out.format = TMDL_HDMITX_VFMT_19_1280x720p_50Hz; */
>    this->tda.setio.video_out.format = TMDL_HDMITX_VFMT_02_720x480p_60Hz;
> 
>    this->tda.setio.video_in.mode = TMDL_HDMITX_VINMODE_RGB444;
>    /*    this->tda.setio.video_in.mode = TMDL_HDMITX_VINMODE_YUV422; */
> 
> 
> 
> 
> 
> 
> 
> 
>    //[jaeseong.gim] 3 lines
>    this->tda.setio.video_out.format = TMDL_HDMITX_VFMT_04_1280x720p_60Hz;
>    this->tda.setio.video_in.format = this->tda.setio.video_out.format;
>    this->tda.setio.video_in.mode = TMDL_HDMITX_VINMODE_RGB444;      
> 
> 
> 
> 
> 
> 
> 
>    this->tda.setio.video_in.pixelRate = TMDL_HDMITX_PIXRATE_SINGLE;
>    this->tda.setio.video_in.syncSource = TMDL_HDMITX_SYNCSRC_EXT_VS; /* we use HS,VS as synchronisation source */
> 
>    this->tda.setio.audio_in.format = TMDL_HDMITX_AFMT_I2S;
>    this->tda.setio.audio_in.rate = TMDL_HDMITX_AFS_48K;
>    this->tda.setio.audio_in.i2sFormat = TMDL_HDMITX_I2SFOR_PHILIPS_L;
>    this->tda.setio.audio_in.i2sQualifier = TMDL_HDMITX_I2SQ_32BITS;
>    this->tda.setio.audio_in.dstRate = TMDL_HDMITX_DSTRATE_SINGLE; /* not relevant here */
>    this->tda.setio.audio_in.channelAllocation = 0; /* audio channel allocation (Ref to CEA-861D p85) */
> 
>    this->tda.setio.sink = TMDL_HDMITX_SINK_HDMI; /* skip edid reading */
>    /*    this->tda.src_address = 0x1000; /\* debug *\/ */
>    this->tda.src_address = NO_PHY_ADDR; /* it's unref */
> 
>  TRY_DONE:
>    return err;
> }
> 
> void reset_hdmi(int hdcp_module)
> {
>    tda_instance *this=&our_instance;
>    int err=0;
> 
>    down(&this->driver.sem);
> 
>    /* PATCH because of SetPowerState that calls SetHdcp that has just been removed by nwolc :( */
>    if (hdcp_module==2) {
>       tmdlHdmiTxSetHdcp(this->tda.instance,0);
>       goto TRY_DONE;
>    }
> 
>    TRY(tmdlHdmiTxSetPowerState(this->tda.instance,tmPowerStandby));
>    tmdlHdmiTxClose(this->tda.instance);
>    /* reset */
>    hdmi_tx_init(this);
>    /* recover previous power state */
>    TRY(tmdlHdmiTxSetPowerState(this->tda.instance,this->tda.power));
>    tmdlHdmiTxGetHPDStatus(this->tda.instance,&this->tda.hot_plug_detect); /* check if activ for timer */
>    show_video(this);
> 
>    /* wake up or shut down hdcp checking */
>    if (hdcp_module) {
>       this->driver.hdcp_check.expires = jiffies +  ( HDCP_CHECK_EVERY_MS * HZ / 1000 );
>       add_timer(&this->driver.hdcp_check);
>       this->tda.hdcp_status = TMDL_HDMITX_HDCP_CHECK_NOT_STARTED; /* ugly is bad ! */ 
>       this->tda.hdcp_enable = 1; /* FIXME : fallback 4 HDCP on/off is ok */
>    }
>    else {
>       del_timer(&this->driver.hdcp_check);
>       this->tda.hdcp_status = TMDL_HDMITX_HDCP_CHECK_NUM; /* ugly is bad ! */ 
>       this->tda.hdcp_enable = 0; /* FIXME : fallback 4 HDCP on/off is ok */
>    }
> 
>  TRY_DONE:
>    up(&this->driver.sem);
> }
> EXPORT_SYMBOL(reset_hdmi);
> 
> /*
>  *  
>  */
> short edid_phy_addr(void)
> {
>    tda_instance *this=&our_instance;
> 
>    return this->tda.src_address;
> }
> EXPORT_SYMBOL(edid_phy_addr);
> 
> /*
>  *  
>  */
> tda_power get_hdmi_status(void)
> { 
>    tda_instance *this=&our_instance;
>    
>    return this->tda.power;
> }
> EXPORT_SYMBOL(get_hdmi_status);
> 
> /*
>  *  
>  */
> tda_power get_hpd_status(void)
> { 
>    tda_instance *this=&our_instance;
>    
>    return (this->tda.hot_plug_detect == TMDL_HDMITX_HOTPLUG_ACTIVE);
> }
> EXPORT_SYMBOL(get_hpd_status);
> 
> /*
>  *  
>  */
> int edid_received(void)
> { 
>    tda_instance *this=&our_instance;
>    
>    return (this->tda.event == TMDL_HDMITX_EDID_RECEIVED);
> }
> EXPORT_SYMBOL(edid_received);
> 
> /*
>  *  
>  */
> int hdmi_enable(void)
> {
>    tda_instance *this=&our_instance;
>    int err=0;
> 
>    LOG(KERN_INFO,"called\n");
> 
>    down(&this->driver.sem);
> 
>    this->tda.power = tmPowerOn;
>    TRY(tmdlHdmiTxSetPowerState(this->tda.instance,this->tda.power));
>    if (err==TM_ERR_NO_RESOURCES) {
>       LOG(KERN_INFO,"Busy...\n");
>       TRY(tmdlHdmiTxHandleInterrupt(this->tda.instance));
>       TRY(tmdlHdmiTxHandleInterrupt(this->tda.instance));
>       TRY(tmdlHdmiTxHandleInterrupt(this->tda.instance));
>    }
>    tmdlHdmiTxGetHPDStatus(this->tda.instance,&this->tda.hot_plug_detect);
>    show_video(this); /* FIXME : mind usecases without HPD and RX_SEND... */
>    
>  TRY_DONE:
>    up(&this->driver.sem);
>    return err;
> }
> EXPORT_SYMBOL(hdmi_enable);
> 
> /*
>  *  
>  */
> int hdmi_disable(int event_tracking)
> { 
>    tda_instance *this=&our_instance;
>    int err=0;
>    
>    LOG(KERN_INFO,"called\n");
> 
>    down(&this->driver.sem);
> 
>    this->tda.power = (event_tracking?tmPowerSuspend:tmPowerStandby);
>    TRY(tmdlHdmiTxSetPowerState(this->tda.instance,this->tda.power));
> 
>  TRY_DONE:
>    up(&this->driver.sem);
>    return err;
> }
> EXPORT_SYMBOL(hdmi_disable);
> 
> /*
>  *
>  * ENTRY POINTS
>  * ------------
>  * LEVEL 3
>  *
>  * - 
>  *
>  */
> 
> #ifdef ANDROID_DSS
> /*
>  *  DSS driver :: probe
>  */
> static int hdmi_panel_probe(struct omap_dss_device *dssdev)
> {
>    tda_instance *this=&our_instance;
> 
>    LOG(KERN_INFO," called\n");
> 
>    sysdss=dssdev;
> 
>    /* 	OMAP_DSS_LCD_IVS		= 1<<0, */
>    /* 	OMAP_DSS_LCD_IHS		= 1<<1, */
>    /* 	OMAP_DSS_LCD_IPC		= 1<<2, */
>    /* 	OMAP_DSS_LCD_IEO		= 1<<3, */
>    /* 	OMAP_DSS_LCD_RF			= 1<<4, */
>    /* 	OMAP_DSS_LCD_ONOFF		= 1<<5, */
>    /* 	OMAP_DSS_LCD_TFT		= 1<<20, */
> 
>    dssdev->panel.config = OMAP_DSS_LCD_ONOFF | OMAP_DSS_LCD_IPC |  \
>       OMAP_DSS_LCD_TFT | OMAP_DSS_LCD_IVS | OMAP_DSS_LCD_IHS;
>    dssdev->panel.timings = video_720x480at60Hz_panel_timings;
>    (void)video_1280x720at60Hz_panel_timings;
>    (void)video_800x480at60Hz_panel_timings;
>    (void)video_1280x720at50Hz_panel_timings;
> 
>    return 0;
> }
> 
> /*
>  *  DSS driver :: enable
>  */
> static void hdmi_panel_remove(struct omap_dss_device *dssdev)
> {
> }
> 
> /*
>  *  DSS driver :: enable
>  */
> static int hdmi_panel_enable(struct omap_dss_device *dssdev)
> {
>    int r = 0;
> 
>    if (dssdev->platform_enable)
>       r = dssdev->platform_enable(dssdev);
>    
>    if (r)
>       goto ERROR0;
> 
>    r = hdmi_enable();
>    if (r)
>       goto ERROR0;
>    /* wait couple of vsyncs until enabling the LCD */
>    msleep(50);
> 
>    return 0;
>  ERROR0:
>    return r;
> }
> 
> /*
>  *  DSS driver :: disable
>  */
> static void hdmi_panel_disable(struct omap_dss_device *dssdev)
> {
>    hdmi_disable(0);
> 
>    /* wait couple of vsyncs until enabling the hdmi */
>    msleep(50);
> 
>    if (dssdev->platform_disable)
>       dssdev->platform_disable(dssdev);
> }
> 
> /*
>  *  DSS driver :: suspend
>  */
> static int hdmi_panel_suspend(struct omap_dss_device *dssdev)
> {
>    hdmi_panel_disable(dssdev);
>    return 0;
> }
> 
> /*
>  *  DSS driver :: resume
>  */
> static int hdmi_panel_resume(struct omap_dss_device *dssdev)
> {
>    return hdmi_panel_enable(dssdev);
> }
> 
> /*
>  *  DSS driver (frontend with omapzoom)
>  *  -----------------------------------
>  */
> static struct omap_dss_driver hdmi_driver = {
>    .probe = hdmi_panel_probe,
>    .remove = hdmi_panel_remove,
>    .enable = hdmi_panel_enable,
>    .disable = hdmi_panel_disable,
>    .suspend = hdmi_panel_suspend,
>    .resume = hdmi_panel_resume,
>    .driver = {
>       .name = "hdmi_panel",
>       .owner = THIS_MODULE,
>    }
> };
> #endif
> 
> /*
>  *  ioctl driver :: opening
>  */
> 
> static int this_cdev_open(struct inode *pInode, struct file *pFile)
> {
>    tda_instance *this;
>    int minor=iminor(pInode);
> 
>    if(minor >= MAX_MINOR) {
>       printk(KERN_ERR "hdmitx:%s:only one tda can be open\n",__func__);
>       return -EINVAL;
>    }
> 
>    if ((pFile->private_data != NULL) && (pFile->private_data != &our_instance)) {
>       printk(KERN_ERR "hdmitx:%s:pFile missmatch\n",__func__);
>    }
>    this = pFile->private_data = &our_instance;
>    down(&this->driver.sem);
> 
>    LOG(KERN_INFO,"major:%d minor:%d user:%d\n", imajor(pInode), iminor(pInode), this->driver.user_counter);
> 
>    if ((this->driver.user_counter++) && (this->driver.minor == minor)) {
>       /* init already done */
>       up(&this->driver.sem);
>       return 0;
>    }
>    this->driver.minor = minor;
> 
> 
>    up(&this->driver.sem);
>    return 0;
> }
> 
> /*
>  *  ioctl driver :: ioctl
>  */
> static int this_cdev_ioctl(struct inode *pInode, struct file *pFile, unsigned int cmd, unsigned long arg)
> {
>    tda_instance* this = pFile->private_data;
>    int err=0;
> 
>    LOG(KERN_INFO,":%s\n",tda_ioctl(_IOC_NR(cmd)));
> 
>    BUG_ON(this->driver.minor!=iminor(pInode));
>    if (_IOC_TYPE(cmd) != TDA_IOCTL_BASE) {
>       printk(KERN_INFO "hdmitx:%s:unknown ioctl type: %x\n",__func__,_IOC_TYPE(cmd));
>       return -ENOIOCTLCMD;
>    }
> 
>    if (_IOC_DIR(cmd) & _IOC_READ) 
>       err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd)) || !arg;
>    else if (_IOC_DIR(cmd) & _IOC_WRITE)
>       err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd)) || !arg;
>    if (err) {
>       printk(KERN_ERR "hdmitx:%s:argument access denied (check address vs value)\n",__func__);
>       printk(KERN_ERR "_IOC_DIR:%d arg:%lx\n",_IOC_DIR(cmd),arg);
>       return -EFAULT;
>    }
>    
>    down(&this->driver.sem);
> 
>    /* Check DevLib consistancy here */
> 
>    switch ( _IOC_NR(cmd) )
>       {
>       case TDA_VERBOSE_ON_CMD:
>          {
>             this->param.verbose=1;
>             printk(KERN_INFO "hdmitx:verbose on\n");
>             break;
>          }
> 
>       case TDA_VERBOSE_OFF_CMD:
>          {
>             printk(KERN_INFO "hdmitx:verbose off\n");
>             this->param.verbose=0;
>             break;
>          }
> 
>       case TDA_BYEBYE_CMD:
>          {
>             LOG(KERN_INFO,"release event handeling request\n");
>             this->tda.event=RELEASE;
>             this->driver.poll_done = true;
>             wake_up_interruptible(&this->driver.wait);
>             break;
>          }
> 
>       case TDA_GET_SW_VERSION_CMD:
>          {
>             TRY(tmdlHdmiTxGetSWVersion(&this->tda.version));
>             BUG_ON(copy_to_user((tda_version*)arg,&this->tda.version,sizeof(tda_version)) != 0);
>             break;
>          }
> 
>       case TDA_SET_POWER_CMD:
>          {
>             BUG_ON(copy_from_user(&this->tda.power,(tda_power*)arg,sizeof(tda_power)) != 0);
>             TRY(tmdlHdmiTxSetPowerState(this->tda.instance, \
>                                         this->tda.power));
>             break;
>          }
> 
>       case TDA_GET_POWER_CMD:
>          {
>             TRY(tmdlHdmiTxGetPowerState(this->tda.instance, \
>                                         &this->tda.power));
>             BUG_ON(copy_to_user((tda_power*)arg,&this->tda.power,sizeof(tda_power)) != 0);
>             break;
>          }
> 
>       case TDA_SETUP_CMD:
>          {
>             BUG_ON(copy_from_user(&this->tda.setup,(tda_setup_info*)arg,sizeof(tda_setup_info)) != 0);
>             TRY(tmdlHdmiTxInstanceSetup(this->tda.instance, \
>                                         &this->tda.setup));
>             break;
>          }
> 
>       case TDA_GET_SETUP_CMD:
>          {
>             TRY(tmdlHdmiTxGetInstanceSetup(this->tda.instance, \
>                                            &this->tda.setup));
>             BUG_ON(copy_to_user((tda_setup*)arg,&this->tda.setup,sizeof(tda_setup)) != 0);
>             break;
>          }
> 
>       case TDA_WAIT_EVENT_CMD:
>          {
>             this->driver.poll_done = false;
>             up(&this->driver.sem);
>             if (wait_event_interruptible(this->driver.wait,this->driver.poll_done)) return -ERESTARTSYS;
>             down(&this->driver.sem);
>             BUG_ON(copy_to_user((tda_event*)arg,&this->tda.event,sizeof(tda_event)) != 0);
>             break;
>          }
> 
>       case TDA_ENABLE_EVENT_CMD:
>          {
>             tmdlHdmiTxEvent_t event;
>             BUG_ON(copy_from_user(&event,(tmdlHdmiTxEvent_t*)arg,sizeof(tmdlHdmiTxEvent_t)) != 0);
>             TRY(tmdlHdmiTxEnableEvent(this->tda.instance,event));
>             break;
>          }
> 
>       case TDA_DISABLE_EVENT_CMD:
>          {
>             tmdlHdmiTxEvent_t event;
>             BUG_ON(copy_from_user(&event,(tmdlHdmiTxEvent_t*)arg,sizeof(tmdlHdmiTxEvent_t)) != 0);
>             TRY(tmdlHdmiTxDisableEvent(this->tda.instance,event));
>             break;
>          }
> 
>       case TDA_GET_VIDEO_SPEC_CMD:
>          {
>             TRY(tmdlHdmiTxGetVideoFormatSpecs(this->tda.instance, \
>                                               this->tda.video_fmt.id, \
>                                               &this->tda.video_fmt.spec));
>             BUG_ON(copy_to_user((tda_video_format*)arg,&this->tda.video_fmt,sizeof(tda_video_format)) != 0);
>             break;
>          }
> 
>       case TDA_SET_INPUT_OUTPUT_CMD:
>          {
>             BUG_ON(copy_from_user(&this->tda.setio,(tda_set_in_out*)arg,sizeof(tda_set_in_out)) != 0);
> 
>             TRY(tmdlHdmiTxSetInputOutput(this->tda.instance, \
>                                          this->tda.setio.video_in, \
>                                          this->tda.setio.video_out, \
>                                          this->tda.setio.audio_in, \
>                                          this->tda.setio.sink));
>             break;
>          }
> 
>       case TDA_SET_AUDIO_INPUT_CMD:
>          {
>             BUG_ON(copy_from_user(&this->tda.setio.audio_in,(tda_set_audio_in*)arg,sizeof(tda_set_audio_in)) != 0);
>             TRY(tmdlHdmiTxSetAudioInput(this->tda.instance, \
>                                         this->tda.setio.audio_in, \
>                                         this->tda.setio.sink));
>             break;
>          }
> 
>       case TDA_SET_VIDEO_INFOFRAME_CMD:
>          {
>             BUG_ON(copy_from_user(&this->tda.video_infoframe,(tda_video_infoframe*)arg,sizeof(tda_video_infoframe)) != 0);
>             TRY(tmdlHdmiTxSetVideoInfoframe(this->tda.instance, \
>                                             this->tda.video_infoframe.enable, \
>                                             &this->tda.video_infoframe.data));
>             break;
>          }
> 
>       case TDA_SET_AUDIO_INFOFRAME_CMD:
>          {
>             BUG_ON(copy_from_user(&this->tda.audio_infoframe,(tda_audio_infoframe*)arg,sizeof(tda_audio_infoframe)) != 0);
>             TRY(tmdlHdmiTxSetAudioInfoframe(this->tda.instance, \
>                                             this->tda.audio_infoframe.enable, \
>                                             &this->tda.audio_infoframe.data));
>             break;
>          }
> 
>       case TDA_SET_ACP_CMD:
>          {
>             BUG_ON(copy_from_user(&this->tda.acp,(tda_acp*)arg,sizeof(tda_acp)) != 0);
>             TRY(tmdlHdmiTxSetACPPacket(this->tda.instance, \
>                                        this->tda.acp.enable, \
>                                        &this->tda.acp.data));
>             break;
>          }
> 
>       case TDA_SET_GCP_CMD:
>          {
>             BUG_ON(copy_from_user(&this->tda.gcp,(tda_gcp*)arg,sizeof(tda_gcp)) != 0);
>             TRY(tmdlHdmiTxSetGeneralControlPacket(this->tda.instance, \
>                                                   this->tda.gcp.enable, \
>                                                   &this->tda.gcp.data));
>             break;
>          }
> 
>       case TDA_SET_ISRC1_CMD:
>          {
>             BUG_ON(copy_from_user(&this->tda.isrc1,(tda_isrc1*)arg,sizeof(tda_isrc1)) != 0);
>             TRY(tmdlHdmiTxSetISRC1Packet(this->tda.instance, \
>                                          this->tda.isrc1.enable, \
>                                          &this->tda.isrc1.data));
>             break;
>          }
> 
>       case TDA_SET_MPS_INFOFRAME_CMD:
>          {
>             BUG_ON(copy_from_user(&this->tda.mps_infoframe,(tda_mps_infoframe*)arg,sizeof(tda_mps_infoframe)) != 0);
>             TRY(tmdlHdmiTxSetMPSInfoframe(this->tda.instance, \
>                                           this->tda.mps_infoframe.enable, \
>                                           &this->tda.mps_infoframe.data));
>             break;
>          }
> 
>       case TDA_SET_SPD_INFOFRAME_CMD:
>          {
>             BUG_ON(copy_from_user(&this->tda.spd_infoframe,(tda_spd_infoframe*)arg,sizeof(tda_spd_infoframe)) != 0);
>             TRY(tmdlHdmiTxSetSpdInfoframe(this->tda.instance, \
>                                           this->tda.spd_infoframe.enable, \
>                                           &this->tda.spd_infoframe.data));
>             break;
>          }
> 
>       case TDA_SET_VS_INFOFRAME_CMD:
>          {
>             BUG_ON(copy_from_user(&this->tda.vs_infoframe,(tda_vs_infoframe*)arg,sizeof(tda_vs_infoframe)) != 0);
>             TRY(tmdlHdmiTxSetVsInfoframe(this->tda.instance, \
>                                          this->tda.vs_infoframe.enable, \
>                                          &this->tda.vs_infoframe.data));
>             break;
>          }
> 
>       case TDA_SET_AUDIO_MUTE_CMD:
>          {
>             BUG_ON(copy_from_user(&this->tda.audio_mute,(bool*)arg,sizeof(bool)) != 0);
>             TRY(tmdlHdmiTxSetAudioMute(this->tda.instance,			\
>                                        this->tda.audio_mute));
>             break;
>          }
> 
>       case TDA_RESET_AUDIO_CTS_CMD:
>          {
>             TRY(tmdlHdmiTxResetAudioCts(this->tda.instance));
>             break;
>          }
> 
>       case TDA_GET_EDID_STATUS_CMD:
>          {
>             TRY(tmdlHdmiTxGetEdidStatus(this->tda.instance, \
>                                         &this->tda.edid.status, \
>                                         &this->tda.edid.block_count));
>             BUG_ON(copy_to_user((tda_edid*)arg,&this->tda.edid,sizeof(tda_edid)) != 0);
>             break;
>          }
> 
>       case TDA_GET_EDID_AUDIO_CAPS_CMD:
>          {
>             TRY(tmdlHdmiTxGetEdidAudioCaps(this->tda.instance, \
>                                            this->tda.edid_audio_caps.desc, \
>                                            this->tda.edid_audio_caps.max, \
>                                            &this->tda.edid_audio_caps.written, \
>                                            &this->tda.edid_audio_caps.flags));
>             BUG_ON(copy_to_user((tda_edid_audio_caps*)arg,&this->tda.edid_audio_caps,sizeof(tda_edid_audio_caps)) != 0);
>             break;
>          }
> 
>       case TDA_GET_EDID_VIDEO_CAPS_CMD:
>          {
>             TRY(tmdlHdmiTxGetEdidVideoCaps(this->tda.instance, \
>                                            this->tda.edid_video_caps.desc, \
>                                            this->tda.edid_video_caps.max, \
>                                            &this->tda.edid_video_caps.written, \
>                                            &this->tda.edid_video_caps.flags));
>             BUG_ON(copy_to_user((tda_edid_video_caps*)arg,&this->tda.edid_video_caps,sizeof(tda_edid_video_caps)) != 0);
>             break;
>          }
> 
>       case TDA_GET_EDID_VIDEO_PREF_CMD:
>          {
>             TRY(tmdlHdmiTxGetEdidVideoPreferred(this->tda.instance, \
>                                                 &this->tda.edid_video_timings));
>             BUG_ON(copy_to_user((tda_edid_video_timings*)arg,&this->tda.edid_video_timings,sizeof(tda_edid_video_timings)) != 0);
>             break;
>          }
> 
>       case TDA_GET_EDID_SINK_TYPE_CMD:
>          {
>             TRY(tmdlHdmiTxGetEdidSinkType(this->tda.instance, \
>                                           &this->tda.setio.sink));
>             BUG_ON(copy_to_user((tda_sink*)arg,&this->tda.setio.sink,sizeof(tda_sink)) != 0);
>             break;
>          }
> 
>       case TDA_GET_EDID_SOURCE_ADDRESS_CMD:
>          {
>             TRY(tmdlHdmiTxGetEdidSourceAddress(this->tda.instance, \
>                                                &this->tda.src_address));
>             BUG_ON(copy_to_user((unsigned short*)arg,&this->tda.src_address,sizeof(unsigned short)) != 0);
>             break;
>          }
> 
>       case TDA_SET_GAMMUT_CMD:
>          {
>             BUG_ON(copy_from_user(&this->tda.gammut,(tda_gammut*)arg,sizeof(tda_gammut)) != 0);
>             TRY(tmdlHdmiTxSetGamutPacket(this->tda.instance, \
>                                          this->tda.gammut.enable, \
>                                          &this->tda.gammut.data));
>             break;
>          }
> 	 
>       case TDA_GET_EDID_DTD_CMD:
>          {
>             TRY(tmdlHdmiTxGetEdidDetailledTimingDescriptors(this->tda.instance, \
>                                                             this->tda.edid_dtd.desc, \
>                                                             this->tda.edid_dtd.max, \
>                                                             &this->tda.edid_dtd.written));
>             BUG_ON(copy_to_user((tda_edid_dtd*)arg,&this->tda.edid_dtd,sizeof(tda_edid_dtd)) != 0);
>             break;
>          }
>      
> #ifdef TMFL_TDA19989
>       case TDA_GET_EDID_MD_CMD:
>          {
>             TRY(tmdlHdmiTxGetEdidMonitorDescriptors(this->tda.instance, \
>                                                     this->tda.edid_md.desc1, \
>                                                     this->tda.edid_md.desc2, \
>                                                     this->tda.edid_md.other, \
>                                                     this->tda.edid_md.max, \
>                                                     &this->tda.edid_md.written));
>             BUG_ON(copy_to_user((tda_edid_md*)arg,&this->tda.edid_md,sizeof(tda_edid_md)) != 0);
>             break;
>          }
> 
>       case TDA_GET_EDID_TV_ASPECT_RATIO_CMD:
>          {
>             TRY(tmdlHdmiTxGetEdidTVPictureRatio(this->tda.instance, \
>                                                 &this->tda.edid_tv_aspect_ratio));
>             BUG_ON(copy_to_user((tda_edid_tv_aspect_ratio*)arg,&this->tda.edid_tv_aspect_ratio,sizeof(tda_edid_tv_aspect_ratio)) != 0);
>             break;
>          }
> 
>       case TDA_GET_EDID_LATENCY_CMD:
>          {
>             TRY(tmdlHdmiTxGetEdidLatencyInfo(this->tda.instance, \
>                                              &this->tda.edid_latency));
>             BUG_ON(copy_to_user((tda_edid_latency*)arg,&this->tda.edid_latency,sizeof(tda_edid_latency)) != 0);
>             break;
>          }
> 
>       case TDA_SET_HDCP_CMD:
>          {
>             BUG_ON(copy_from_user(&this->tda.hdcp_enable,(bool*)arg,sizeof(bool)) != 0);
>             break;
>          }
> 
>       case TDA_GET_HDCP_STATUS_CMD:
>          {
>             BUG_ON(copy_to_user((tda_edid_latency*)arg,&this->tda.hdcp_status,sizeof(tda_hdcp_status)) != 0);
>             break;
>          }
> #endif
> 
>       default:
>          {
>             /* unrecognized ioctl */	
>             printk(KERN_INFO "hdmitx:%s:unknown ioctl number: %x\n",__func__,cmd);
>             up(&this->driver.sem);
>             return -ENOIOCTLCMD;
>          }
>       }
> 
>  TRY_DONE:
>    up(&this->driver.sem);
>    return err;
> }
> 
> /*
>  *  ioctl driver :: releasing
>  */
> static int this_cdev_release(struct inode *pInode, struct file *pFile)
> {
>    tda_instance* this = pFile->private_data;
>    int minor = iminor(pInode);
> 
>    LOG(KERN_INFO,"called\n");
> 
>    if(minor >= MAX_MINOR) {
>       LOG(KERN_ERR,"minor too big!\n");
>       return -EINVAL;
>    }
> 
>    BUG_ON(this->driver.minor!=iminor(pInode));
>    down(&this->driver.sem);
> 
>    this->driver.user_counter--;
>    if(this->driver.user_counter == 0) {
>       pFile->private_data = NULL;
>    }
>    else {
>       LOG(KERN_INFO,"Still %d users pending\n",this->driver.user_counter);
>    }
> 
>    up(&this->driver.sem);
>    return 0;
> }
> 
> /*
>  *  I2C client :: creation
>  */
> static int this_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
> {
>    tda_instance *this=&our_instance;
>    int err=0;
> 
>    LOG(KERN_INFO,"called\n");
> 
> 
> 
> 	//[jaeseong.gim] + 4 lines
> 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)){
> 		printk("[jaeseong.gim]i2c_check_error\n");
> 		return -ENODEV;
> 	}
> 
>    /*
>      I2C setup
>    */
>    if (this->driver.i2c_client) {
>       dev_err(&this->driver.i2c_client->dev, "<%s> HDMI Device already created \n",
>               __func__);
>       return -ENODEV;
>    }
> 
>    this->driver.i2c_client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
>    if (!this->driver.i2c_client) {
>       return -ENOMEM;
>    }
>    memset(this->driver.i2c_client, 0, sizeof(struct i2c_client));
> 
>    strncpy(this->driver.i2c_client->name, TX_NAME, I2C_NAME_SIZE);
>    this->driver.i2c_client->addr = TDA998X_I2C_SLAVEADDRESS;
>    this->driver.i2c_client->adapter = client->adapter;
> 
>    i2c_set_clientdata(client, this->driver.i2c_client);
> 
>    /* I2C ok, then let's startup TDA */
>    err = hdmi_tx_init(this);
>    if (err) goto i2c_out;
>    this->tda.hdcp_enable = 0;
>    /* Standby the HDMI TX instance */
>    this->tda.power = tmPowerStandby;
>    tmdlHdmiTxSetPowerState(this->tda.instance,this->tda.power);
>    /* update HPD */
>    tmdlHdmiTxGetHPDStatus(this->tda.instance,&this->tda.hot_plug_detect);
> 
> #ifdef ANDROID_DSS
>    /* probe DSS */
>    err = omap_dss_register_driver(&hdmi_driver);
> #endif
>    if (err) goto i2c_tx_out;
> 
>    /* prepare event */
>    this->driver.poll_done = true; /* currently idle */
>    init_waitqueue_head(&this->driver.wait);
> 
> #ifdef IRQ
>    /* FRO calibration */
>    err=gpio_request(TDA_IRQ_CALIB,"tda998x calibration");
>    if (err < 0) {
> 	   //[jaeseong.gim] 107->104
>       printk(KERN_ERR "hdmitx:%s:cannot use GPIO 104\n",__func__);
>       goto i2c_out;
>    }
>    /* turn GPIO into IRQ */
>    gpio_direction_input(TDA_IRQ_CALIB);
>    msleep(1);
>    if (request_irq(gpio_to_irq(TDA_IRQ_CALIB), \
>                    tda_irq, IRQF_TRIGGER_FALLING|IRQF_DISABLED, "TDA IRQ", NULL)) {
>       printk(KERN_ERR "hdmitx:%s:Cannot request irq, err:%d\n",__func__,err);
>       gpio_free(TDA_IRQ_CALIB);
>       goto i2c_out;
>    }
> #else
>    init_timer(&this->driver.no_irq_timer);
>    this->driver.no_irq_timer.function=polling_timeout;
>    this->driver.no_irq_timer.data=0;
>    this->driver.no_irq_timer.expires = jiffies + HZ; /* start polling in one sec */
>    add_timer(&this->driver.no_irq_timer);
> #endif
> 
>    /* setup hdcp check timer */
>    init_timer(&this->driver.hdcp_check);
>    this->driver.hdcp_check.function=hdcp_check_timeout;
>    this->driver.hdcp_check.data=0;
> 
>    tmdlHdmiTxGetSWVersion(&this->tda.version);
>    printk(KERN_INFO "HDMI TX SW Version:%lu.%lu compatibility:%lu\n",   \
>           this->tda.version.majorVersionNr,\
>           this->tda.version.minorVersionNr,\
>           this->tda.version.compatibilityNr);
>    return 0;
> 
>  i2c_tx_out:
>    LOG(KERN_INFO,"tmdlHdmiTx closed\n");
>    /* close DevLib */
>    err=tmdlHdmiTxClose(this->tda.instance);
> 
>  i2c_out:
>    LOG(KERN_INFO,"this->driver.i2c_client removed\n");
>    kfree(this->driver.i2c_client);
>    this->driver.i2c_client = NULL;
> 
>    return err;
> }
> 
> /*
>  *  I2C client :: destroy
>  */
> static int this_i2c_remove(struct i2c_client *client)
> {
>    tda_instance *this=&our_instance;
>    int err=0;
> 
>    LOG(KERN_INFO,"called\n");
> 
> #ifdef ANDROID_DSS
>    /* unplug DSS */
>    omap_dss_unregister_driver(&hdmi_driver);
> #endif
> 
>    /* close DevLib */
>    err=tmdlHdmiTxClose(this->tda.instance);
> 
>    if (!client->adapter) {
>       dev_err(&this->driver.i2c_client->dev, "<%s> No HDMI Device \n",
>               __func__);
>       return -ENODEV;
>    }
>    kfree(this->driver.i2c_client);
>    this->driver.i2c_client = NULL;
> 
>    return err;
> }
> 
> /*
>  *  I2C client driver (backend)
>  *  -----------------
>  */
> static const struct i2c_device_id this_i2c_id[] = {
>    { TX_NAME, 0 },
>    { },
> };
> 
> MODULE_DEVICE_TABLE(i2c, this_i2c_id);
> 
> static struct i2c_driver this_i2c_driver = {
>    .driver = {
>       .owner = THIS_MODULE,
>       .name = TX_NAME,
>    },
>    .probe = this_i2c_probe,
>    .remove = this_i2c_remove,
>    .id_table = this_i2c_id,
> };
> 
> /*
>  *  ioctl driver (userland frontend)
>  *  ------------
>  */
> static struct file_operations this_cdev_fops = {
>  owner:    THIS_MODULE,
>  open:     this_cdev_open,
>  release:  this_cdev_release,
>  ioctl:    this_cdev_ioctl,
> };
> 
> /*
>  *  Module :: start up
>  */
> static int __init tx_init(void)
> {
>    tda_instance *this=&our_instance;
>    dev_t dev=0;
>    int err=0;
> 
>    //[jaeseong.gim] register hdmi device
> 
>    struct msm_panel_info *pinfo;
> 
>    pinfo = &hdmi_panel_data.panel_info;
> 
> 	//pinfo->lcdc.h_back_porch = 4;
> 	//pinfo->lcdc.h_front_porch = 6;
> 	//pinfo->lcdc.h_pulse_width = 1;
> 	//pinfo->lcdc.v_back_porch = 4;
> 	//pinfo->lcdc.v_front_porch = 3;
> 	//pinfo->lcdc.v_pulse_width = 1;
>    
> 	pinfo->lcdc.h_back_porch = 220;
> 	pinfo->lcdc.h_front_porch = 110;
> 	pinfo->lcdc.h_pulse_width = 40;
> 	pinfo->lcdc.v_back_porch = 20;
> 	pinfo->lcdc.v_front_porch = 5;
> 	pinfo->lcdc.v_pulse_width = 5;
> 
> 	//pinfo->lcdc.h_back_porch = 124;
> 	//pinfo->lcdc.h_front_porch = 110;
> 	//pinfo->lcdc.h_pulse_width = 136;
> 	//pinfo->lcdc.v_back_porch = 19;
> 	//pinfo->lcdc.v_front_porch = 5;
> 	//pinfo->lcdc.v_pulse_width = 6;
>  
> 	pinfo->lcdc.border_clr = 0;	/* blk */
> 	pinfo->lcdc.underflow_clr = 0xff;	/* blue */
> 	pinfo->lcdc.hsync_skew = 0;
> 
>    msm_fb_add_device(&hdmi_device);
> 
> 
>    /* 
>       general device context
>    */
>    memset(this,0,sizeof(tda_instance)); 
>    this->param.verbose = param_verbose;
>    this->param.major = param_major;
>    this->param.minor = param_minor;
> 
>    /* Hello word */
>    printk(KERN_INFO "%s(%s) %d.%d.%d compiled: %s %s %s\n", HDMITX_NAME, TDA_NAME, 
>           TDA_VERSION_MAJOR,
>           TDA_VERSION_MINOR,
>           TDA_VERSION_PATCHLEVEL, 
>           __DATE__, __TIME__, TDA_VERSION_EXTRA);
>    if (this->param.verbose) LOG(KERN_INFO,".verbose mode\n");
> 
>    /*
>      plug I2C (backend : Hw interfacing)
>    */
>    err = i2c_add_driver(&this_i2c_driver);
>    if (err < 0) {
>       printk(KERN_ERR "Driver registration failed\n");
>       return -ENODEV;
>    }
> 
>    if (this->driver.i2c_client == NULL) {
>       printk(KERN_ERR "this->driver.i2c_client not allocated\n");
>       /* unregister i2c */
>       err = -ENODEV;
>       goto init_out;
>    }
> 
>    /*
>      cdev init (userland frontend)
>    */
> 
>    /* arbitray range of device numbers */
>    if (this->param.major) {
>       /* user force major number @ insmod */
>       dev = MKDEV(this->param.major, this->param.minor);
>       err = register_chrdev_region(dev,MAX_MINOR,HDMITX_NAME);
>       if (err) {
>          printk(KERN_ERR "unable to register %s, dev=%d %s\n",HDMITX_NAME,dev,ERR_TO_STR(err));
>          goto init_out;
>       }
>    } else {
>       /* fully dynamic major number */
>       err = alloc_chrdev_region(&dev, this->param.minor, MAX_MINOR,HDMITX_NAME);
>       if (err) {
>          printk(KERN_ERR "unable to alloc chrdev region for %s, dev=%d %s\n",HDMITX_NAME,dev,ERR_TO_STR(err));
>          goto init_out;
>       }
>       this->param.major = MAJOR(dev);
>       this->param.minor = MINOR(dev);
>       /*       create_dev("/dev/hdmitx",dev); */
>       LOG(KERN_INFO,"/dev/hdmitx created major:%d minor:%d\n",this->param.major, this->param.minor);
>    }
> 
>    cdev_init(this_cdev, &this_cdev_fops);
>    this_cdev->owner = THIS_MODULE;
> 
>    this->driver.class = class_create(THIS_MODULE, HDMITX_NAME);
>    if (IS_ERR(this->driver.class)) {
>       printk(KERN_INFO "Error creating mmap device class.\n");
>       err =-EIO;
>       goto init_out;
>    }
>    this->driver.dev=device_create(this->driver.class, NULL, dev, NULL, HDMITX_NAME);
> 
>    this->driver.devno = dev;
>    err = cdev_add(this_cdev, this->driver.devno, MAX_MINOR);
>    if (err){
>       printk(KERN_INFO "unable to add device for %s, ipp_driver.devno=%d %s\n",HDMITX_NAME,this->driver.devno,ERR_TO_STR(err));
>       device_destroy(this->driver.class,this->driver.devno);
>       class_destroy(this->driver.class);
>       unregister_chrdev_region(this->driver.devno, MAX_MINOR);
>       goto init_out;
>    }   
> 
>    /* 
>       general device context
>    */
>    init_MUTEX(&this->driver.sem);
>    hdmi_enable();
>    return 0;
> 
>  init_out:
>    i2c_del_driver(&this_i2c_driver);
>    return err;
> }
> 
> /*
>  *  Module :: shut down
>  */
> static void __exit tx_exit(void)
> {
>    tda_instance *this=&our_instance;
> 
>    LOG(KERN_INFO,"called\n");
> 
>    hdmi_disable(0);
> 
> #ifdef IRQ
>    free_irq(gpio_to_irq(TDA_IRQ_CALIB), NULL);
>    gpio_free(TDA_IRQ_CALIB);
> #else
>    del_timer(&this->driver.no_irq_timer);
> #endif
> 
>    del_timer(&this->driver.hdcp_check);
> 
>    /* unregister cdevice */
>    cdev_del(this_cdev); 
>    unregister_chrdev_region(this->driver.devno, MAX_MINOR);
>    
>    /* unregister device */
>    device_destroy(this->driver.class,this->driver.devno);
>    class_destroy(this->driver.class);
> 
>    /* unregister i2c */
>    i2c_del_driver(&this_i2c_driver);
> }
> 
> 
> /*
>  *  Module
>  *  ------
>  */
> /* late_initcall(tx_init); */
> //[jaeseong.gim] module or built-in option
> #ifdef MODULE
> module_init(tx_init);
> #else
> late_initcall(tx_init);
> #endif
> module_exit(tx_exit);
> 
> /*
>  *  Disclamer
>  *  ---------
>  */
> MODULE_LICENSE("GPL");
> MODULE_AUTHOR("Andre Lepine <andre.lepine@nxp.com>");
> MODULE_DESCRIPTION(HDMITX_NAME " driver");
diff ./tda998x.h /home/jaeseong.gim/android/kernel/drivers/video/hdmi/tda998x.h
1,139c1,136
< /*****************************************************************************/
< /* Copyright (c) 2009 NXP Semiconductors BV                                  */
< /*                                                                           */
< /* This program is free software; you can redistribute it and/or modify      */
< /* it under the terms of the GNU General Public License as published by      */
< /* the Free Software Foundation, using version 2 of the License.             */
< /*                                                                           */
< /* This program is distributed in the hope that it will be useful,           */
< /* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
< /* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              */
< /* GNU General Public License for more details.                              */
< /*                                                                           */
< /* You should have received a copy of the GNU General Public License         */
< /* along with this program; if not, write to the Free Software               */
< /* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307       */
< /* USA.                                                                      */
< /*                                                                           */
< /*****************************************************************************/
< 
< #ifndef __tx_h__
< #define __tx_h__
< 
< #include "tda998x_ioctl.h"
< 
< #define HDMITX_NAME "hdmitx"
< 
< #define POLLING_WQ_NAME "TDA_POLLING"
< #define HDCP_CHECK_EVERY_MS 35
< #define CHECK_EVERY_XX_MS 200
< #define OMAP_LCD_GPIO 8
< 
< #define TDA_MAJOR 234 /* old-style interval of device numbers */
< #define MAX_MINOR 1 /* 1 minor but 2 access : 1 more for pooling */
< 
< 
< /* common I2C define with kernel */
< /* should be the same as arch/arm/mach-omap2/board-zoom2.c */
< #define TX_NAME "tda998X"
< #define TDA998X_I2C_SLAVEADDRESS 0x70
< 
< #define TDA_IRQ_CALIB 107
< 
< #define EDID_BLOCK_COUNT 4
< #define EDID_BLOCK_SIZE 128
< #define MAX_EDID_TRIAL 5
< #define NO_PHY_ADDR 0xFFFF
< 
< #define LOG(type,fmt,args...) {if (this->param.verbose) {printk(type HDMITX_NAME":%s:" fmt, __func__, ## args);}}
< /* not found the kernel "strerror" one! If someone knows, please replace it */
< #define ERR_TO_STR(e)((e == -ENODATA)?"ENODATA, no data available":\
<                       (e == -ENOMEM)? "ENOMEM, no memory available":\
<                       (e == -EINVAL)? "EINVAL, invalid argument":\
<                       (e == -EIO)? "EIO, input/output error":\
<                       (e == -ETIMEDOUT)? "ETIMEOUT, timeout has expired":\
<                       (e == -EBUSY)? "EBUSY, device or resource busy":\
<                       (e == -ENOENT)? "ENOENT, no such file or directory":\
<                       (e == -EACCES)? "EACCES, permission denied":\
<                       (e == 0)?       "":\
<                       "!UNKNOWN!")
< 
< #define TRY(fct) { \
<       err=(fct);                                                        \
<       if (err) {                                                        \
<          printk(KERN_ERR "%s returned in %s line %d\n",hdmi_tx_err_string(err),__func__,__LINE__); \
<          goto TRY_DONE;                                                 \
<       }                                                                 \
<    }
< 
< typedef void (*cec_callback_t)(struct work_struct *dummy);
< 
< typedef struct {
<    /* module params */
<    struct { 
<       int verbose;
<       int major;
<       int minor;
<    } param;
<    /* driver */
<    struct {
<       struct class *class;
<       struct device *dev;
<       int devno;
<       struct i2c_client *i2c_client;
<       struct semaphore sem;
<       int user_counter;
<       int minor;
<       wait_queue_head_t wait;
<       bool poll_done;
< #ifndef IRQ
<       struct timer_list no_irq_timer;
< #endif
<       struct timer_list hdcp_check;
<       cec_callback_t cec_callback;
<    } driver;
<    /* HDMI */
<    struct {
<       int instance;
<       tda_version version;
<       tda_setup setup;
<       tda_power power;
<       tmdlHdmiTxHotPlug_t hot_plug_detect;
<       bool rx_device_active;
<       tda_video_format video_fmt;
<       tda_set_in_out setio;
<       bool audio_mute;
<       tda_video_infoframe video_infoframe;
<       tda_audio_infoframe audio_infoframe;
<       tda_acp acp;
<       tda_gcp gcp;
<       tda_isrc1 isrc1;
<       tda_isrc2 isrc2;
<       tda_gammut gammut;
<       tda_mps_infoframe mps_infoframe;
<       tda_spd_infoframe spd_infoframe;
<       tda_vs_infoframe vs_infoframe;
<       tda_edid edid;
<       tda_edid_dtd edid_dtd;
<       tda_edid_md edid_md;
<       tda_edid_audio_caps edid_audio_caps;
<       tda_edid_video_caps edid_video_caps;
<       tda_edid_video_timings edid_video_timings;
<       tda_edid_tv_aspect_ratio edid_tv_aspect_ratio;
< #ifdef TMFL_TDA19989
<       tda_edid_latency edid_latency;
< #endif
<       unsigned short src_address;
<       unsigned char raw_edid[EDID_BLOCK_COUNT*EDID_BLOCK_SIZE];
<       tda_capabilities capabilities;
<       tda_event event;
<       tda_hdcp_status hdcp_status;
<       bool hdcp_enable;
< #if defined (TMFL_TDA19989) || defined (TMFL_TDA9984) 
<       tda_hdcp_fail hdcp_fail;
< #endif
<       unsigned char hdcp_raw_status;
<    } tda;
< } tda_instance;
< 
< #endif /* __tx_h__ */
---
> /*****************************************************************************/
> /* Copyright (c) 2009 NXP Semiconductors BV                                  */
> /*                                                                           */
> /* This program is free software; you can redistribute it and/or modify      */
> /* it under the terms of the GNU General Public License as published by      */
> /* the Free Software Foundation, using version 2 of the License.             */
> /*                                                                           */
> /* This program is distributed in the hope that it will be useful,           */
> /* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
> /* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              */
> /* GNU General Public License for more details.                              */
> /*                                                                           */
> /* You should have received a copy of the GNU General Public License         */
> /* along with this program; if not, write to the Free Software               */
> /* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307       */
> /* USA.                                                                      */
> /*                                                                           */
> /*****************************************************************************/
> 
> #ifndef __tx_h__
> #define __tx_h__
> 
> #include "tda998x_ioctl.h"
> 
> #define HDMITX_NAME "hdmitx"
> 
> #define POLLING_WQ_NAME "TDA_POLLING"
> #define HDCP_CHECK_EVERY_MS 20
> #define CHECK_EVERY_XX_MS 200
> #define OMAP_LCD_GPIO 8
> 
> #define TDA_MAJOR 234 /* old-style interval of device numbers */
> #define MAX_MINOR 1 /* 1 minor but 2 access : 1 more for pooling */
> 
> 
> /* common I2C define with kernel */
> /* should be the same as arch/arm/mach-omap2/board-zoom2.c */
> #define TX_NAME "tda998X"
> #define TDA998X_I2C_SLAVEADDRESS 0x70
> 
> //[jaeseong.gim] 107->104
> #define TDA_IRQ_CALIB 104
> 
> #define EDID_BLOCK_COUNT 4
> #define EDID_BLOCK_SIZE 128
> #define MAX_EDID_TRIAL 5
> #define NO_PHY_ADDR 0xFFFF
> 
> #define LOG(type,fmt,args...) {if (this->param.verbose) {printk(type HDMITX_NAME":%s:" fmt, __func__, ## args);}}
> /* not found the kernel "strerror" one! If someone knows, please replace it */
> #define ERR_TO_STR(e)((e == -ENODATA)?"ENODATA, no data available":\
>                       (e == -ENOMEM)? "ENOMEM, no memory available":\
>                       (e == -EINVAL)? "EINVAL, invalid argument":\
>                       (e == -EIO)? "EIO, input/output error":\
>                       (e == -ETIMEDOUT)? "ETIMEOUT, timeout has expired":\
>                       (e == -EBUSY)? "EBUSY, device or resource busy":\
>                       (e == -ENOENT)? "ENOENT, no such file or directory":\
>                       (e == -EACCES)? "EACCES, permission denied":\
>                       (e == 0)?       "":\
>                       "!UNKNOWN!")
> 
> #define TRY(fct) { \
>       err=(fct);                                                        \
>       if (err) {                                                        \
>          printk(KERN_ERR "%s returned in %s line %d\n",hdmi_tx_err_string(err),__func__,__LINE__); \
>          goto TRY_DONE;                                                 \
>       }                                                                 \
>    }
> 
> typedef void (*cec_callback_t)(struct work_struct *dummy);
> 
> typedef struct {
>    /* module params */
>    struct { 
>       int verbose;
>       int major;
>       int minor;
>    } param;
>    /* driver */
>    struct {
>       struct class *class;
>       struct device *dev;
>       int devno;
>       struct i2c_client *i2c_client;
>       struct semaphore sem;
>       int user_counter;
>       int minor;
>       wait_queue_head_t wait;
>       bool poll_done;
>       struct timer_list no_irq_polling;
>       struct timer_list hdcp_check;
>       cec_callback_t cec_callback;
>    } driver;
>    /* HDMI */
>    struct {
>       int instance;
>       tda_version version;
>       tda_setup setup;
>       tda_power power;
>       tmdlHdmiTxHotPlug_t hot_plug_detect;
>       bool rx_device_active;
>       tda_video_format video_fmt;
>       tda_set_in_out setio;
>       bool audio_mute;
>       tda_video_infoframe video_infoframe;
>       tda_audio_infoframe audio_infoframe;
>       tda_acp acp;
>       tda_gcp gcp;
>       tda_isrc1 isrc1;
>       tda_isrc2 isrc2;
>       tda_gammut gammut;
>       tda_mps_infoframe mps_infoframe;
>       tda_spd_infoframe spd_infoframe;
>       tda_vs_infoframe vs_infoframe;
>       tda_edid edid;
>       tda_edid_dtd edid_dtd;
>       tda_edid_md edid_md;
>       tda_edid_audio_caps edid_audio_caps;
>       tda_edid_video_caps edid_video_caps;
>       tda_edid_video_timings edid_video_timings;
>       tda_edid_tv_aspect_ratio edid_tv_aspect_ratio;
> #ifdef TMFL_TDA19989
>       tda_edid_latency edid_latency;
> #endif
>       unsigned short src_address;
>       unsigned char raw_edid[EDID_BLOCK_COUNT*EDID_BLOCK_SIZE];
>       tda_capabilities capabilities;
>       tda_event event;
>       tda_hdcp_status hdcp_status;
>       bool hdcp_enable;
>       tda_hdcp_fail hdcp_fail;
>       unsigned char hdcp_raw_status;
>    } tda;
> } tda_instance;
> 
> #endif /* __tx_h__ */
diff ./tda998x_cec.c /home/jaeseong.gim/android/kernel/drivers/video/hdmi/tda998x_cec.c
1,2172c1,2156
< /*****************************************************************************/
< /* Copyright (c) 2009 NXP Semiconductors BV                                  */
< /*                                                                           */
< /* This program is free software; you can redistribute it and/or modify      */
< /* it under the terms of the GNU General Public License as published by      */
< /* the Free Software Foundation, using version 2 of the License.             */
< /*                                                                           */
< /* This program is distributed in the hope that it will be useful,           */
< /* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
< /* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              */
< /* GNU General Public License for more details.                              */
< /*                                                                           */
< /* You should have received a copy of the GNU General Public License         */
< /* along with this program; if not, write to the Free Software               */
< /* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307       */
< /* USA.                                                                      */
< /*                                                                           */
< /*****************************************************************************/
< 
< #define _cec_c_
< 
< #include <linux/init.h>
< #include <linux/kernel.h>
< #include <linux/module.h>
< #include <linux/cdev.h>  
< #include <linux/fs.h>
< #include <linux/ioctl.h>
< #include <linux/i2c.h>
< #include <linux/delay.h>
< #include <linux/interrupt.h>
< #include <linux/input.h>
< #include <asm/uaccess.h>
< #include <mach/gpio.h>
< 
< /* HDMI DevLib */
< #include "tmNxCompId.h"
< #include "tmdlHdmiCEC.h"
< #include "tmdlHdmiCEC_local.h"
< 
< /* local */
< #include "tda998x_version.h"
< #include "tda998x_cec.h"
< #include "tda998x_ioctl.h"
< 
< /*
<  *
<  * DEFINITION
<  * ----------
<  * LEVEL 0
<  *
<  */
< 
< /*
<  *  Global
<  */
< 
< MODULE_DEVICE_TABLE(i2c, this_i2c_id);
< static const struct i2c_device_id this_i2c_id[] = {
<    { CEC_NAME, 0 },
<    { },
< };
< cec_instance our_instance;
< static struct cdev our_cdev, *this_cdev=&our_cdev;
< 
< #ifdef TWL4030_HACK
< /* AL : hack to bypass keypad */
< struct input_dev *gkp_input;
< extern struct input_dev *get_twm4030_input(void);
< #endif
< 
< /*
<  * Dependancies to HdmiTx module
<  */
< 
< extern void register_cec_interrupt(cec_callback_t fct); 
< extern void unregister_cec_interrupt(void); 
< extern short edid_phy_addr(void); 
< extern int hdmi_enable(void);
< extern int hdmi_disable(int event_tracking);
< extern cec_power get_hdmi_status(void);
< extern cec_power get_hpd_status(void);
< extern int edid_received(void);
< 
< /*
<  *  Module params
<  */
< 
< static int param_verbose=0,param_major=0,param_minor=0,param_device=4,param_addr=0xFFFF;
< module_param_named(verbose,param_verbose,int,S_IRUGO | S_IWUSR);
< MODULE_PARM_DESC(verbose, "Make the driver verbose");
< module_param_named(major, param_major, int, S_IRUGO);
< MODULE_PARM_DESC(major, "The major number of the device mapper");
< module_param_named(device, param_device, int, S_IRUGO);
< MODULE_PARM_DESC(device, "Device type can be 0:tv, 1:rec 3:tuner 4:mediaplayer, 5:audio");
< module_param_named(addr, param_addr, int, S_IRUGO);
< MODULE_PARM_DESC(addr, "Physical address (until EDID received)");
< 
< /*
<  *
<  * TOOLBOX
<  * -------
<  * LEVEL 1
<  *
<  * - i2c read/write
<  * - chip Id check
<  * - i2c client info
<  * 
<  */
< 
< 
< /* 
<  *  Get main and unique I2C Client driver handle
<  */
< struct i2c_client *GetThisI2cClient(void)
< {
<    cec_instance *this=&our_instance;
<    return this->driver.i2c_client;
< }
< 
< /*
<  * error handling
<  */
< static char *hdmi_cec_err_string(int err)
< {
<    switch (err)
<       {
<       case TMDL_ERR_DLHDMICEC_COMPATIBILITY: {return "SW Interface compatibility";break;}
<       case TMDL_ERR_DLHDMICEC_MAJOR_VERSION: {return "SW Major Version error";break;}
<       case TMDL_ERR_DLHDMICEC_COMP_VERSION: {return "SW component version error";break;}
<       case TMDL_ERR_DLHDMICEC_BAD_UNIT_NUMBER: {return "Invalid device unit number";break;}
<       case TMDL_ERR_DLHDMICEC_BAD_INSTANCE: {return "Bad input instance value  ";break;}
<       case TMDL_ERR_DLHDMICEC_BAD_HANDLE: {return "Bad input handle";break;}
<       case TMDL_ERR_DLHDMICEC_BAD_PARAMETER: {return "Invalid input parameter";break;}
<       case TMDL_ERR_DLHDMICEC_NO_RESOURCES: {return "Resource is not available ";break;}
<       case TMDL_ERR_DLHDMICEC_RESOURCE_OWNED: {return "Resource is already in use";break;}
<       case TMDL_ERR_DLHDMICEC_RESOURCE_NOT_OWNED: {return "Caller does not own resource";break;}
<       case TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS: {return "Inconsistent input params";break;}
<       case TMDL_ERR_DLHDMICEC_NOT_INITIALIZED: {return "Component is not initializ";break;}
<       case TMDL_ERR_DLHDMICEC_NOT_SUPPORTED: {return "Function is not supported";break;}
<       case TMDL_ERR_DLHDMICEC_INIT_FAILED: {return "Initialization failed";break;}
<       case TMDL_ERR_DLHDMICEC_BUSY: {return "Component is busy";break;}
<       case TMDL_ERR_DLHDMICEC_I2C_READ: {return "Read error";break;}
<       case TMDL_ERR_DLHDMICEC_I2C_WRITE: {return "Write error";break;}
<       case TMDL_ERR_DLHDMICEC_FULL: {return "Queue is full";break;}
<       case TMDL_ERR_DLHDMICEC_NOT_STARTED: {return "Function is not started";break;}
<       case TMDL_ERR_DLHDMICEC_ALREADY_STARTED: {return "Function is already starte";break;}
<       case TMDL_ERR_DLHDMICEC_ASSERTION: {return "Assertion failure";break;}
<       case TMDL_ERR_DLHDMICEC_INVALID_STATE: {return "Invalid state for function";break;}
<       case TMDL_ERR_DLHDMICEC_OPERATION_NOT_PERMITTED: {return "Corresponds to posix EPERM";break;}
<       default : {return "Unexpected error";break;}
<       }
< }
< 
< char *cec_opcode(int op)
< {
<    switch (op)
<       {
<       case CEC_OPCODE_FEATURE_ABORT: {return "CEC_OPCODE_FEATURE_ABORT";break;}
<       case CEC_OPCODE_IMAGE_VIEW_ON: {return "CEC_OPCODE_IMAGE_VIEW_ON";break;}
<       case CEC_OPCODE_TUNER_STEP_INCREMENT: {return "CEC_OPCODE_TUNER_STEP_INCREMENT";break;}
<       case CEC_OPCODE_TUNER_STEP_DECREMENT: {return "CEC_OPCODE_TUNER_STEP_DECREMENT";break;}
<       case CEC_OPCODE_TUNER_DEVICE_STATUS: {return "CEC_OPCODE_TUNER_DEVICE_STATUS";break;}
<       case CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS: {return "CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS";break;}
<       case CEC_OPCODE_RECORD_ON: {return "CEC_OPCODE_RECORD_ON";break;}
<       case CEC_OPCODE_RECORD_STATUS: {return "CEC_OPCODE_RECORD_STATUS";break;}
<       case CEC_OPCODE_RECORD_OFF: {return "CEC_OPCODE_RECORD_OFF";break;}
<       case CEC_OPCODE_TEXT_VIEW_ON: {return "CEC_OPCODE_TEXT_VIEW_ON";break;}
<       case CEC_OPCODE_RECORD_TV_SCREEN: {return "CEC_OPCODE_RECORD_TV_SCREEN";break;}
<       case CEC_OPCODE_GIVE_DECK_STATUS: {return "CEC_OPCODE_GIVE_DECK_STATUS";break;}
<       case CEC_OPCODE_DECK_STATUS: {return "CEC_OPCODE_DECK_STATUS";break;}
<       case CEC_OPCODE_SET_MENU_LANGUAGE: {return "CEC_OPCODE_SET_MENU_LANGUAGE";break;}
<       case CEC_OPCODE_CLEAR_ANALOGUE_TIMER: {return "CEC_OPCODE_CLEAR_ANALOGUE_TIMER";break;}
<       case CEC_OPCODE_SET_ANALOGUE_TIMER: {return "CEC_OPCODE_SET_ANALOGUE_TIMER";break;}
<       case CEC_OPCODE_TIMER_STATUS: {return "CEC_OPCODE_TIMER_STATUS";break;}
<       case CEC_OPCODE_STANDBY: {return "CEC_OPCODE_STANDBY";break;}
<       case CEC_OPCODE_PLAY: {return "CEC_OPCODE_PLAY";break;}
< /*       case CEC_OPCODE_DECK_CONTROL: {return "CEC_OPCODE_DECK_CONTROL";break;} */
<       case CEC_OPCODE_TIMER_CLEARED_STATUS: {return "CEC_OPCODE_TIMER_CLEARED_STATUS";break;}
<       case CEC_OPCODE_USER_CONTROL_PRESSED: {return "CEC_OPCODE_USER_CONTROL_PRESSED";break;}
<       case CEC_OPCODE_USER_CONTROL_RELEASED: {return "CEC_OPCODE_USER_CONTROL_RELEASED";break;}
<       case CEC_OPCODE_GIVE_OSD_NAME: {return "CEC_OPCODE_GIVE_OSD_NAME";break;}
<       case CEC_OPCODE_SET_OSD_NAME: {return "CEC_OPCODE_SET_OSD_NAME";break;}
<       case CEC_OPCODE_SET_OSD_STRING: {return "CEC_OPCODE_SET_OSD_STRING";break;}
<       case CEC_OPCODE_SET_TIMER_PROGRAM_TITLE: {return "CEC_OPCODE_SET_TIMER_PROGRAM_TITLE";break;}
<       case CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST: {return "CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST";break;}
<       case CEC_OPCODE_GIVE_AUDIO_STATUS: {return "CEC_OPCODE_GIVE_AUDIO_STATUS";break;}
<       case CEC_OPCODE_SET_SYSTEM_AUDIO_MODE: {return "CEC_OPCODE_SET_SYSTEM_AUDIO_MODE";break;}
<       case CEC_OPCODE_REPORT_AUDIO_STATUS: {return "CEC_OPCODE_REPORT_AUDIO_STATUS";break;}
<       case CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS: {return "CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS";break;}
<       case CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS: {return "CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS";break;}
<       case CEC_OPCODE_ROUTING_CHANGE: {return "CEC_OPCODE_ROUTING_CHANGE";break;}
<       case CEC_OPCODE_ROUTING_INFORMATION: {return "CEC_OPCODE_ROUTING_INFORMATION";break;}
<       case CEC_OPCODE_ACTIVE_SOURCE: {return "CEC_OPCODE_ACTIVE_SOURCE";break;}
<       case CEC_OPCODE_GIVE_PHYSICAL_ADDRESS: {return "CEC_OPCODE_GIVE_PHYSICAL_ADDRESS";break;}
<       case CEC_OPCODE_REPORT_PHYSICAL_ADDRESS: {return "CEC_OPCODE_REPORT_PHYSICAL_ADDRESS";break;}
<       case CEC_OPCODE_REQUEST_ACTIVE_SOURCE: {return "CEC_OPCODE_REQUEST_ACTIVE_SOURCE";break;}
<       case CEC_OPCODE_SET_STREAM_PATH: {return "CEC_OPCODE_SET_STREAM_PATH";break;}
<       case CEC_OPCODE_DEVICE_VENDOR_ID: {return "CEC_OPCODE_DEVICE_VENDOR_ID";break;}
<       case CEC_OPCODE_VENDOR_COMMAND: {return "CEC_OPCODE_VENDOR_COMMAND";break;}
<       case CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN: {return "CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN";break;}
<       case CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP: {return "CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP";break;}
<       case CEC_OPCODE_GIVE_DEVICE_VENDOR_ID: {return "CEC_OPCODE_GIVE_DEVICE_VENDOR_ID";break;}
<       case CEC_OPCODE_MENU_REQUEST: {return "CEC_OPCODE_MENU_REQUEST";break;}
<       case CEC_OPCODE_MENU_STATUS: {return "CEC_OPCODE_MENU_STATUS";break;}
<       case CEC_OPCODE_GIVE_DEVICE_POWER_STATUS: {return "CEC_OPCODE_GIVE_DEVICE_POWER_STATUS";break;}
<       case CEC_OPCODE_REPORT_POWER_STATUS: {return "CEC_OPCODE_REPORT_POWER_STATUS";break;}
<       case CEC_OPCODE_GET_MENU_LANGUAGE: {return "CEC_OPCODE_GET_MENU_LANGUAGE";break;}
<       case CEC_OPCODE_SET_ANALOGUE_SERVICE: {return "CEC_OPCODE_SET_ANALOGUE_SERVICE";break;}
<       case CEC_OPCODE_SET_DIGITAL_SERVICE: {return "CEC_OPCODE_SET_DIGITAL_SERVICE";break;}
<       case CEC_OPCODE_SET_DIGITAL_TIMER: {return "CEC_OPCODE_SET_DIGITAL_TIMER";break;}
<       case CEC_OPCODE_CLEAR_DIGITAL_TIMER: {return "CEC_OPCODE_CLEAR_DIGITAL_TIMER";break;}
<       case CEC_OPCODE_SET_AUDIO_RATE: {return "CEC_OPCODE_SET_AUDIO_RATE";break;}
<       case CEC_OPCODE_INACTIVE_SOURCE: {return "CEC_OPCODE_INACTIVE_SOURCE";break;}
<       case CEC_OPCODE_CEC_VERSION: {return "CEC_OPCODE_CEC_VERSION";break;}
<       case CEC_OPCODE_GET_CEC_VERSION: {return "CEC_OPCODE_GET_CEC_VERSION";break;}
<       case CEC_OPCODE_VENDOR_COMMAND_WITH_ID: {return "CEC_OPCODE_VENDOR_COMMAND_WITH_ID";break;}
<       case CEC_OPCODE_CLEAR_EXTERNAL_TIMER: {return "CEC_OPCODE_CLEAR_EXTERNAL_TIMER";break;}
<       case CEC_OPCODE_SET_EXTERNAL_TIMER: {return "CEC_OPCODE_SET_EXTERNAL_TIMER";break;}
<       case CEC_OPCODE_ABORT_MESSAGE: {return "CEC_OPCODE_ABORT_MESSAGE";break;}
<       default : {return "unknown";break;}
<       }
< }
< 
< 
< static char *cec_ioctl(int io)
< {
<    switch (io)
<       {
<       case CEC_VERBOSE_ON_CMD: {return "CEC_VERBOSE_ON_CMD";break;}
<       case CEC_VERBOSE_OFF_CMD: {return "CEC_VERBOSE_OFF_CMD";break;}
<       case CEC_BYEBYE_CMD: {return "CEC_BYEBYE_CMD";break;}
<       case CEC_IOCTL_RX_ADDR_CMD: {return "CEC_IOCTL_RX_ADDR_CMD";break;}
<       case CEC_IOCTL_PHY_ADDR_CMD: {return "CEC_IOCTL_PHY_ADDR_CMD";break;}
<       case CEC_IOCTL_WAIT_FRAME_CMD: {return "CEC_IOCTL_WAIT_FRAME_CMD";break;}
<       case CEC_IOCTL_ABORT_MSG_CMD: {return "CEC_IOCTL_ABORT_MSG_CMD";break;}
<       case CEC_IOCTL_ACTIVE_SRC_CMD: {return "CEC_IOCTL_ACTIVE_SRC_CMD";break;}
<       case CEC_IOCTL_VERSION_CMD: {return "CEC_IOCTL_VERSION_CMD";break;}
<       case CEC_IOCTL_CLEAR_ANALOGUE_TIMER_CMD: {return "CEC_IOCTL_CLEAR_ANALOGUE_TIMER_CMD";break;}
<       case CEC_IOCTL_CLEAR_DIGITAL_TIMER_CMD: {return "CEC_IOCTL_CLEAR_DIGITAL_TIMER_CMD";break;}
<       case CEC_IOCTL_CLEAR_EXT_TIMER_WITH_EXT_PLUG_CMD: {return "CEC_IOCTL_CLEAR_EXT_TIMER_WITH_EXT_PLUG_CMD";break;}
<       case CEC_IOCTL_CLEAR_EXT_TIMER_WITH_PHY_ADDR_CMD: {return "CEC_IOCTL_CLEAR_EXT_TIMER_WITH_PHY_ADDR_CMD";break;}
<       case CEC_IOCTL_DECK_CTRL_CMD: {return "CEC_IOCTL_DECK_CTRL_CMD";break;}
<       case CEC_IOCTL_DECK_STATUS_CMD: {return "CEC_IOCTL_DECK_STATUS_CMD";break;}
<       case CEC_IOCTL_DEVICE_VENDOR_ID_CMD: {return "CEC_IOCTL_DEVICE_VENDOR_ID_CMD";break;}
<       case CEC_IOCTL_FEATURE_ABORT_CMD: {return "CEC_IOCTL_FEATURE_ABORT_CMD";break;}
<       case CEC_IOCTL_GET_CEC_VERSION_CMD: {return "CEC_IOCTL_GET_CEC_VERSION_CMD";break;}
<       case CEC_IOCTL_GET_MENU_LANGUAGE_CMD: {return "CEC_IOCTL_GET_MENU_LANGUAGE_CMD";break;}
<       case CEC_IOCTL_GIVE_AUDIO_STATUS_CMD: {return "CEC_IOCTL_GIVE_AUDIO_STATUS_CMD";break;}
<       case CEC_IOCTL_GIVE_DECK_STATUS_CMD: {return "CEC_IOCTL_GIVE_DECK_STATUS_CMD";break;}
<       case CEC_IOCTL_GIVE_DEVICE_POWER_STATUS_CMD: {return "CEC_IOCTL_GIVE_DEVICE_POWER_STATUS_CMD";break;}
<       case CEC_IOCTL_GIVE_DEVICE_VENDOR_ID_CMD: {return "CEC_IOCTL_GIVE_DEVICE_VENDOR_ID_CMD";break;}
<       case CEC_IOCTL_GIVE_OSD_NAME_CMD: {return "CEC_IOCTL_GIVE_OSD_NAME_CMD";break;}
<       case CEC_IOCTL_GIVE_PHY_ADDR_CMD: {return "CEC_IOCTL_GIVE_PHY_ADDR_CMD";break;}
<       case CEC_IOCTL_GIVE_SYS_AUDIO_MODE_STATUS_CMD: {return "CEC_IOCTL_GIVE_SYS_AUDIO_MODE_STATUS_CMD";break;}
<       case CEC_IOCTL_GIVE_TUNER_DEVICE_STATUS_CMD: {return "CEC_IOCTL_GIVE_TUNER_DEVICE_STATUS_CMD";break;}
<       case CEC_IOCTL_IMAGE_VIEW_ON_CMD: {return "CEC_IOCTL_IMAGE_VIEW_ON_CMD";break;}
<       case CEC_IOCTL_INACTIVE_SRC_CMD: {return "CEC_IOCTL_INACTIVE_SRC_CMD";break;}
<       case CEC_IOCTL_MENU_REQUEST_CMD: {return "CEC_IOCTL_MENU_REQUEST_CMD";break;}
<       case CEC_IOCTL_MENU_STATUS_CMD: {return "CEC_IOCTL_MENU_STATUS_CMD";break;}
<       case CEC_IOCTL_PLAY_CMD: {return "CEC_IOCTL_PLAY_CMD";break;}
<       case CEC_IOCTL_POLLING_MSG_CMD: {return "CEC_IOCTL_POLLING_MSG_CMD";break;}
<       case CEC_IOCTL_REC_OFF_CMD: {return "CEC_IOCTL_REC_OFF_CMD";break;}
<       case CEC_IOCTL_REC_ON_ANALOGUE_SERVICE_CMD: {return "CEC_IOCTL_REC_ON_ANALOGUE_SERVICE_CMD";break;}
<       case CEC_IOCTL_REC_ON_DIGITAL_SERVICE_CMD: {return "CEC_IOCTL_REC_ON_DIGITAL_SERVICE_CMD";break;}
<       case CEC_IOCTL_REC_ON_EXT_PHY_ADDR_CMD: {return "CEC_IOCTL_REC_ON_EXT_PHY_ADDR_CMD";break;}
<       case CEC_IOCTL_REC_ON_EXT_PLUG_CMD: {return "CEC_IOCTL_REC_ON_EXT_PLUG_CMD";break;}
<       case CEC_IOCTL_REC_ON_OWN_SRC_CMD: {return "CEC_IOCTL_REC_ON_OWN_SRC_CMD";break;}
<       case CEC_IOCTL_REC_STATUS_CMD: {return "CEC_IOCTL_REC_STATUS_CMD";break;}
<       case CEC_IOCTL_REC_TV_SCREEN_CMD: {return "CEC_IOCTL_REC_TV_SCREEN_CMD";break;}
<       case CEC_IOCTL_REPORT_AUDIO_STATUS_CMD: {return "CEC_IOCTL_REPORT_AUDIO_STATUS_CMD";break;}
<       case CEC_IOCTL_REPORT_PHY_ADDR_CMD: {return "CEC_IOCTL_REPORT_PHY_ADDR_CMD";break;}
<       case CEC_IOCTL_REPORT_POWER_STATUS_CMD: {return "CEC_IOCTL_REPORT_POWER_STATUS_CMD";break;}
<       case CEC_IOCTL_REQUEST_ACTIVE_SRC_CMD: {return "CEC_IOCTL_REQUEST_ACTIVE_SRC_CMD";break;}
<       case CEC_IOCTL_ROUTING_CHANGE_CMD: {return "CEC_IOCTL_ROUTING_CHANGE_CMD";break;}
<       case CEC_IOCTL_ROUTING_INFORMATION_CMD: {return "CEC_IOCTL_ROUTING_INFORMATION_CMD";break;}
<       case CEC_IOCTL_SELECT_ANALOGUE_SERVICE_CMD: {return "CEC_IOCTL_SELECT_ANALOGUE_SERVICE_CMD";break;}
<       case CEC_IOCTL_SELECT_DIGITAL_SERVICE_CMD: {return "CEC_IOCTL_SELECT_DIGITAL_SERVICE_CMD";break;}
<       case CEC_IOCTL_SET_ANALOGUE_TIMER_CMD: {return "CEC_IOCTL_SET_ANALOGUE_TIMER_CMD";break;}
<       case CEC_IOCTL_SET_AUDIO_RATE_CMD: {return "CEC_IOCTL_SET_AUDIO_RATE_CMD";break;}
<       case CEC_IOCTL_SET_DIGITAL_TIMER_CMD: {return "CEC_IOCTL_SET_DIGITAL_TIMER_CMD";break;}
<       case CEC_IOCTL_SET_EXT_TIMER_WITH_EXT_PLUG_CMD: {return "CEC_IOCTL_SET_EXT_TIMER_WITH_EXT_PLUG_CMD";break;}
<       case CEC_IOCTL_SET_EXT_TIMER_WITH_PHY_ADDR_CMD: {return "CEC_IOCTL_SET_EXT_TIMER_WITH_PHY_ADDR_CMD";break;}
<       case CEC_IOCTL_SET_MENU_LANGUAGE_CMD: {return "CEC_IOCTL_SET_MENU_LANGUAGE_CMD";break;}
<       case CEC_IOCTL_SET_OSD_NAME_CMD: {return "CEC_IOCTL_SET_OSD_NAME_CMD";break;}
<       case CEC_IOCTL_SET_OSD_STRING_CMD: {return "CEC_IOCTL_SET_OSD_STRING_CMD";break;}
<       case CEC_IOCTL_SET_STREAM_PATH_CMD: {return "CEC_IOCTL_SET_STREAM_PATH_CMD";break;}
<       case CEC_IOCTL_SET_SYS_AUDIO_MODE_CMD: {return "CEC_IOCTL_SET_SYS_AUDIO_MODE_CMD";break;}
<       case CEC_IOCTL_SET_TIMER_PROGRAM_TITLE_CMD: {return "CEC_IOCTL_SET_TIMER_PROGRAM_TITLE_CMD";break;}
<       case CEC_IOCTL_STANDBY_CMD: {return "CEC_IOCTL_STANDBY_CMD";break;}
<       case CEC_IOCTL_SYS_AUDIO_MODE_REQUEST_CMD: {return "CEC_IOCTL_SYS_AUDIO_MODE_REQUEST_CMD";break;}
<       case CEC_IOCTL_SYS_AUDIO_MODE_STATUS_CMD: {return "CEC_IOCTL_SYS_AUDIO_MODE_STATUS_CMD";break;}
<       case CEC_IOCTL_TEXT_VIEW_ON_CMD: {return "CEC_IOCTL_TEXT_VIEW_ON_CMD";break;}
<       case CEC_IOCTL_TIMER_CLEARED_STATUS_CMD: {return "CEC_IOCTL_TIMER_CLEARED_STATUS_CMD";break;}
<       case CEC_IOCTL_TIMER_STATUS_CMD: {return "CEC_IOCTL_TIMER_STATUS_CMD";break;}
<       case CEC_IOCTL_TUNER_DEVICE_STATUS_ANALOGUE_CMD: {return "CEC_IOCTL_TUNER_DEVICE_STATUS_ANALOGUE_CMD";break;}
<       case CEC_IOCTL_TUNER_DEVICE_STATUS_DIGITAL_CMD: {return "CEC_IOCTL_TUNER_DEVICE_STATUS_DIGITAL_CMD";break;}
<       case CEC_IOCTL_TUNER_STEP_DECREMENT_CMD: {return "CEC_IOCTL_TUNER_STEP_DECREMENT_CMD";break;}
<       case CEC_IOCTL_TUNER_STEP_INCREMENT_CMD: {return "CEC_IOCTL_TUNER_STEP_INCREMENT_CMD";break;}
<       case CEC_IOCTL_USER_CTRL_CMD: {return "CEC_IOCTL_USER_CTRL_CMD";break;}
<       case CEC_IOCTL_USER_CTRL_PLAY_CMD: {return "CEC_IOCTL_USER_CTRL_PLAY_CMD";break;}
<       case CEC_IOCTL_USER_CTRL_SELECT_AUDIOINPUT_CMD: {return "CEC_IOCTL_USER_CTRL_SELECT_AUDIOINPUT_CMD";break;}
<       case CEC_IOCTL_USER_CTRL_SELECT_AVINPUT_CMD: {return "CEC_IOCTL_USER_CTRL_SELECT_AVINPUT_CMD";break;}
<       case CEC_IOCTL_USER_CTRL_SELECT_MEDIA_CMD: {return "CEC_IOCTL_USER_CTRL_SELECT_MEDIA_CMD";break;}
<       case CEC_IOCTL_USER_CTRL_TUNE_CMD: {return "CEC_IOCTL_USER_CTRL_TUNE_CMD";break;}
<       case CEC_IOCTL_USER_CTRL_RELEASED_CMD: {return "CEC_IOCTL_USER_CTRL_RELEASED_CMD";break;}
<       case CEC_IOCTL_VENDOR_COMMAND_CMD: {return "CEC_IOCTL_VENDOR_COMMAND_CMD";break;}
<       case CEC_IOCTL_VENDOR_COMMAND_WITH_ID_CMD: {return "CEC_IOCTL_VENDOR_COMMAND_WITH_ID_CMD";break;}
<       case CEC_IOCTL_VENDOR_REMOTE_BUTTON_DOWN_CMD: {return "CEC_IOCTL_VENDOR_REMOTE_BUTTON_DOWN_CMD";break;}
<       case CEC_IOCTL_VENDOR_REMOTE_BUTTON_UP_CMD: {return "CEC_IOCTL_VENDOR_REMOTE_BUTTON_UP_CMD";break;}
<       case CEC_IOCTL_GET_SW_VERSION_CMD: {return "CEC_IOCTL_GET_SW_VERSION_CMD";break;}
<       case CEC_IOCTL_SET_POWER_STATE_CMD: {return "CEC_IOCTL_SET_POWER_STATE_CMD";break;}
<       case CEC_IOCTL_GET_POWER_STATE_CMD: {return "CEC_IOCTL_GET_POWER_STATE_CMD";break;}
<       case CEC_IOCTL_INSTANCE_CONFIG_CMD: {return "CEC_IOCTL_INSTANCE_CONFIG_CMD";break;}
<       case CEC_IOCTL_INSTANCE_SETUP_CMD: {return "CEC_IOCTL_INSTANCE_SETUP_CMD";break;}
<       case CEC_IOCTL_GET_INSTANCE_SETUP_CMD: {return "CEC_IOCTL_GET_INSTANCE_SETUP_CMD";break;}
<       case CEC_IOCTL_ENABLE_EVENT_CMD: {return "CEC_IOCTL_ENABLE_EVENT_CMD";break;}
<       case CEC_IOCTL_DISABLE_EVENT_CMD: {return "CEC_IOCTL_DISABLE_EVENT_CMD";break;}
<       case CEC_IOCTL_ENABLE_CALIBRATION_CMD: {return "CEC_IOCTL_ENABLE_CALIBRATION_CMD";break;}
<       case CEC_IOCTL_DISABLE_CALIBRATION_CMD: {return "CEC_IOCTL_DISABLE_CALIBRATION_CMD";break;}
<       case CEC_IOCTL_SEND_MSG_CMD: {return "CEC_IOCTL_SEND_MSG_CMD";break;}
<       case CEC_IOCTL_SET_REGISTER_CMD: {return "CEC_IOCTL_SET_REGISTER_CMD";break;}
<       default : {return "unknown";break;}
<       }
< }
< 
< 
< static char *cec_rxstatus(int s)
< {
<    switch (s)
<       {
<       case CEC_MSG_SUCCESS :{return "success";break;}
<       case CEC_MSG_FAIL_DATA_NOT_ACK :{return "data not ack";break;}
<       case CEC_CSP_OFF_STATE :{return "CSP off";break;}
<       case CEC_BAD_REQ_SERVICE :{return "bad Req";break;}
<       case CEC_MSG_FAIL_UNABLE_TO_ACCESS :{return "CEC line error";break;}
<       case CEC_MSG_FAIL_ARBITRATION_ERROR :{return "arb error";break;}
<       case CEC_MSG_FAIL_BIT_TIMMING_ERROR :{return "bit error";break;}
<       case CEC_MSG_FAIL_DEST_NOT_ACK :{return "destination not ack";break;}
<       default : {return "unknown";break;}
<       }
< }
< 
< 
< static unsigned char get_next_logical_addr(cec_device_type device,unsigned char la)
< {
<    switch (device) {
<    case CEC_DEVICE_TYPE_TV:
<       switch (la) {
<       case CEC_LOGICAL_ADDRESS_TV:
<          return CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
<       default:
<          return CEC_LOGICAL_ADDRESS_TV;
<       }
<    case CEC_DEVICE_TYPE_REC_DEVICE:
<       switch (la) {
<       case CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_1:
<          return CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_2;
<       case CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_2:
<          return CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_3;
<       case CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_3:
<          return CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
<       default:
<          return CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_1;
<       }
<    case CEC_DEVICE_TYPE_TUNER:
<       switch (la) {
<       case CEC_LOGICAL_ADDRESS_TUNER_1:
<          return CEC_LOGICAL_ADDRESS_TUNER_2;
<       case CEC_LOGICAL_ADDRESS_TUNER_2:
<          return CEC_LOGICAL_ADDRESS_TUNER_3;
<       case CEC_LOGICAL_ADDRESS_TUNER_3:
<          return CEC_LOGICAL_ADDRESS_TUNER_4;
<       case CEC_LOGICAL_ADDRESS_TUNER_4:
<          return CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
<       default:
<          return CEC_LOGICAL_ADDRESS_TUNER_1;
<       }
<    case CEC_DEVICE_TYPE_PLAYBACK_DEVICE:
<       switch (la) {
<       case CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_1:
<          return CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_2;
<       case CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_2:
<          return CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_3;
<       case CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_3:
<          return CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
<       default:
<          return CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_1;
<       }
<    case CEC_DEVICE_TYPE_AUDIO_DEVICE: 
<       switch (la) {
<       case CEC_LOGICAL_ADDRESS_AUDIO_SYSTEM:
<          return CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
<       default:
<          return CEC_LOGICAL_ADDRESS_AUDIO_SYSTEM;
<       }
<    default:
<       return CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
<    }
< }
< 
< static int device_type(int type)
< {
<    printk(KERN_INFO "hdmicec declared as a ");
<    switch (type) {
<    case CEC_DEVICE_TYPE_TV: 
<       printk("TV");
<       break;
<    case CEC_DEVICE_TYPE_REC_DEVICE: 
<       printk("record");
<       break;
<    case CEC_DEVICE_TYPE_TUNER: 
<       printk("tuner");
<       break;
<    case CEC_DEVICE_TYPE_PLAYBACK_DEVICE: 
<       printk("playback");
<       break;
<    case CEC_DEVICE_TYPE_AUDIO_DEVICE: 
<       printk("audio");
<       break;
<    default: 
<       printk("default (playback)");
<       type = CEC_DEVICE_TYPE_PLAYBACK_DEVICE;
<       break;
<    }
<    printk(" device type\n");
<    return type;
< }
< 
< 
< /*
<  *
<  * PROCESSING
<  * ----------
<  * LEVEL 2
<  *
<  */
< 
< 
< /*
<  *  CEC Power On
<  */
< static void cec_on(cec_instance *this)
< {
<    int err;
<    struct task_struct *tsk = current;
< 
<    disable_irq(gpio_to_irq(TDA_IRQ_CALIB));
< 
<    this->cec.power = tmPowerOn;
<    TRY(tmdlHdmiCecSetPowerState(this->cec.inst,this->cec.power));
< 
<    /* turn GPIO into calib pulse generator */
<    gpio_direction_output(TDA_IRQ_CALIB,0); /* output (1 means try-state or high) */
<    __gpio_set_value(TDA_IRQ_CALIB,1);
<    this->cec.clock = TMDL_HDMICEC_CLOCK_FRO;
<    TRY(tmdlHdmiCecEnableCalibration(this->cec.inst,this->cec.clock));
<    msleep(10);
<    set_current_state(TASK_UNINTERRUPTIBLE);
< 
<    /* CAUTION : TDA needs a real 10ms pulse */
<    cpu_relax();
<    spin_lock_irq(&tsk->sighand->siglock);
<    __gpio_set_value(TDA_IRQ_CALIB,0);
<    __udelay(10000);
<    __gpio_set_value(TDA_IRQ_CALIB,1);
<    spin_unlock_irq(&tsk->sighand->siglock);
< 
<    msleep(10);
<    TRY(tmdlHdmiCecDisableCalibration(this->cec.inst));
< 
<    /* setup */ 
<    TRY(tmdlHdmiCecGetInstanceSetup(this->cec.inst,&this->cec.setup));
<    this->cec.setup.DeviceLogicalAddress = this->cec.rx_addr;
<    this->cec.clock = TMDL_HDMICEC_CLOCK_FRO;
<    this->cec.setup.cecClockSource = this->cec.clock;
<    TRY(tmdlHdmiCecInstanceSetup(this->cec.inst,&this->cec.setup));
< 
<    /* turn GPIO into IRQ */
<    gpio_direction_input(TDA_IRQ_CALIB);
<    enable_irq(gpio_to_irq(TDA_IRQ_CALIB));
< 
<    LOG(KERN_INFO,"standby --> on\n");
< 
<  TRY_DONE:
<    (void)0;
< }
< 
< /*
<  *  CEC Power Off
<  */
< static void cec_standby(cec_instance *this)
< {
<    int err;
< 
<    this->cec.power = tmPowerStandby;
<    TRY(tmdlHdmiCecSetPowerState(this->cec.inst,this->cec.power));
<    
<    LOG(KERN_INFO,"on --> standby\n");
< 
<  TRY_DONE:
<    (void)0;
< }
< 
< /*
<  *  CEC interrupt polling
<  */
< static void cec_interrupt(struct work_struct *dummy)
< {
<    cec_instance *this=&our_instance;
<    unsigned short new_phy_addr=edid_phy_addr();
<    int err=0;
<    
<    LOG(KERN_INFO,"%s called\n",__func__);
< 
<    /* switch on/off CEC */
<    if (!get_hpd_status() &&                     \
<        (this->cec.power == tmPowerOn)) {
<       this->cec.source_status = CEC_POWER_STATUS_STANDBY;
< /*       TRY(tmdlHdmiCecInactiveSource(this->cec.inst,             \ */
< /*                                        this->cec.initiator,     \ */
< /*                                        this->cec.phy_addr)); */
<       cec_standby(this);
<    }
<    else if (get_hpd_status() &&                         \
<             (this->cec.power == tmPowerStandby)) {
<       /* send active msg when hdmi has been abled */
<       cec_on(this);
<    }
<    /* new phy addr means new EDID, mean HPD ! */
<    else if ((this->cec.phy_addr != new_phy_addr) &&        \
<        (this->cec.source_status == CEC_POWER_STATUS_ON)) {
<       LOG(KERN_INFO,"New physical address %02x\n",new_phy_addr);
<       this->cec.phy_addr = new_phy_addr;
<       if (this->cec.phy_addr != 0xFFFF) {
<          this->cec.rx_addr = get_next_logical_addr(this->cec.device_type,CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST);
<          TRY(tmdlHdmiCecPollingMessage(this->cec.inst,this->cec.rx_addr));
<       }
<       else {
<          this->cec.rx_addr = CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
<       }
<    }
< #ifdef GUI_OVER_HDMI
<    else if (edid_received()) { /* Check me */
<       if (this->cec.source_status == CEC_POWER_STATUS_STANDBY) {
<          /* only for GFX on HDMI, do not use if only video playback on HDMI */
<          TRY(tmdlHdmiCecImageViewOn(this->cec.inst,this->cec.initiator));
<          TRY(tmdlHdmiCecHandleInterrupt(this->cec.inst));
<          msleep(200);
<          TRY(tmdlHdmiCecActiveSource(this->cec.inst,this->cec.phy_addr));
<          this->cec.source_status = CEC_POWER_STATUS_ON;
<       }
<    }
< #endif
<    
< #if 0
<    if (this->cec.phy_addr != 0xFFFF) {
< 
<       /* claim source status */
<       if ((get_hdmi_status() ==  tmPowerStandby) &&             \
<           (this->cec.source_status == CEC_POWER_STATUS_ON)) {
<          /* send inactive msg when hdmi has been disabled */
<          this->cec.source_status = CEC_POWER_STATUS_STANDBY;
<          TRY(tmdlHdmiCecInactiveSource(this->cec.inst,          \
<                                        this->cec.initiator,     \
<                                        this->cec.phy_addr));
<       }
<       else if ((get_hdmi_status() ==  tmPowerOn) &&                     \
<                (this->cec.source_status == CEC_POWER_STATUS_STANDBY)) {
<          /* send active msg when hdmi has been abled */
<          this->cec.source_status = CEC_POWER_STATUS_ON;
<          TRY(tmdlHdmiCecActiveSource(this->cec.inst,        \
<                                      this->cec.phy_addr));
<       }
< /*       printk(KERN_INFO "DBG phd_status:%s cec.power:%s\n", \ */
< /*              get_hpd_status()?"Active":"Inactive",                                      \ */
< /*              (this->cec.power==tmPowerOn)?"On":"Standby"); */
<    }
< #endif
< 
<    /* internal handeling */
<    TRY(tmdlHdmiCecHandleInterrupt(this->cec.inst));
<     
<  TRY_DONE:
< 
<    /* setup next tick */
<    if (!this->driver.deinit_req) {
<       /* setup next polling */
< #ifndef IRQ
< /*       this->driver.timer.expires = jiffies + ( CHECK_EVERY_XX_MS * HZ / 1000 ); */
< /*       add_timer(&this->driver.timer); */
<       mod_timer(&this->driver.timer,jiffies + ( CHECK_EVERY_XX_MS * HZ / 1000 ));
< #endif
<    }
<    else {
<       this->driver.deinit_req++;
<       wake_up_interruptible(&this->driver.wait);
<    }
< }
< 
< #ifndef IRQ
< static DECLARE_WORK(wq_name, cec_interrupt);
< 
< void polling_timeout(unsigned long arg)
< {
< 
< #if 0
<    /* fake frame for equipement-less testing */
< 
<       cec_instance *this=&our_instance;
< 
<       if (this->driver.timer.data++>1000) {
<          printk(KERN_INFO "Fake Rx message\n");
<          this->driver.timer.data=0;
< 
<          this->cec.frame.count = 4;
<          this->cec.frame.addr = 4; /* 0-->4 (TV-->MediaPlayer1) */
<          this->cec.frame.data[0]=0x46; /* opcode: "GiveOsd" */
<          this->cec.frame.service = CEC_RX_DONE;
<          
<          this->driver.poll_done = true;
<          wake_up_interruptible(&this->driver.wait);
<       }
< #endif
< 
<    /* derefered because ATOMIC context of timer does not support I2C_transfert */
<    schedule_work(&wq_name);
< 
< }
< #endif
< 
< #ifndef IRQ
< /*
<  *  TDA irq
<  */
< static irqreturn_t tda_irq(int irq, void *_udc)
< {
<    cec_instance *this=&our_instance;
<    /*    printk(KERN_INFO "DBG caught irq:%d\n",irq); */
<  
<    /* do it now */
<    mod_timer(&this->driver.timer,jiffies);
< 
<    return IRQ_HANDLED;
< }
< #endif
< 
< #ifdef TWL4030_HACK
< /*
<  *  User Control
<  */
< static void user_control(int key, int press)
< {
<    input_report_key(gkp_input, key, press);
<    input_sync(gkp_input);
<    msleep(20);
<    input_report_key(gkp_input, key, 0);
<    input_sync(gkp_input);
< }
< #endif
< 
< /*
<  *  CEC callback
<  */
< static void eventCallbackCEC(tmdlHdmiCecEvent_t event, unsigned char *data, unsigned char length)
< {
<    int err=0;
<    cec_instance *this=&our_instance;
<    int opcode;
<    int initiator,receiver;
< 
<    if (event == TMDL_HDMICEC_CALLBACK_MESSAGE_AVAILABLE) {
< 
<       this->cec.frame.count = length;
<       this->cec.frame.addr = data[1]; /* .AddressByte */
<       initiator = (this->cec.frame.addr >> 4) & 0x0F;
<       this->cec.initiator = initiator;
<       receiver = this->cec.frame.addr & 0x0F;
<       memcpy(&this->cec.frame.data,&data[2],length-2); /* .DataBytes[], length - siezof(length,addr,ack) */
<       opcode=this->cec.frame.data[0];
<       printk(KERN_INFO "hdmicec:Rx:[%x--->%x] %s length:%d addr:%d %02x%02x%02x%02x\n",initiator,receiver,cec_opcode(opcode), \
<           length,data[1],
<           this->cec.frame.data[0],                                      \
<           this->cec.frame.data[1],                                      \
<           this->cec.frame.data[2],                                      \
<           this->cec.frame.data[3]);
<       this->cec.frame.service = CEC_RX_DONE;
< 
<       msleep(20);
< 
<       /* automatic answering */
<       switch (opcode) {
<       case CEC_OPCODE_GIVE_PHYSICAL_ADDRESS:
<          TRY(tmdlHdmiCecReportPhysicalAddress(this->cec.inst,           \
<                                               this->cec.phy_addr,       \
<                                               this->cec.device_type));
<          break;
<       case CEC_OPCODE_GET_CEC_VERSION:
<          TRY(tmdlHdmiCecVersion(this->cec.inst,                         \
<                                 this->cec.initiator,                    \
<                                 this->cec.version));
<          break;   
<       case CEC_OPCODE_GIVE_OSD_NAME:
<          TRY(tmdlHdmiCecSetOsdName(this->cec.inst,         \
<                                    this->cec.initiator,        \
<                                    this->cec.osd_name.data,         \
<                                    this->cec.osd_name.length));
<          break;
<       case CEC_OPCODE_GIVE_DEVICE_VENDOR_ID:
<          TRY(tmdlHdmiCecDeviceVendorID(this->cec.inst,              \
<                                        this->cec.vendor_id));
<          break;
<       case CEC_OPCODE_REQUEST_ACTIVE_SOURCE:
<          if (this->cec.source_status == CEC_POWER_STATUS_ON) {
<             if (this->cec.initiator != 0x0F) {
<                if (receiver == 0x0F) {
<                   TRY(tmdlHdmiCecActiveSource(this->cec.inst,this->cec.phy_addr));
<                }
<             }
<          }
<          break;
<       case CEC_OPCODE_ACTIVE_SOURCE:
<          if (this->cec.source_status == CEC_POWER_STATUS_ON) {
<             this->cec.source_status = CEC_POWER_STATUS_STANDBY;
<             hdmi_disable(1);
<             this->cec.power = tmPowerOn;
<             TRY(tmdlHdmiCecSetPowerState(this->cec.inst,this->cec.power)); /* keeps CEC alive */
<          }
<          break;
<       case CEC_OPCODE_GIVE_DEVICE_POWER_STATUS:
<          TRY(tmdlHdmiCecReportPowerStatus(this->cec.inst,               \
<                                           this->cec.initiator,          \
<                                           this->cec.source_status));
<          break;
<       case CEC_OPCODE_STANDBY:
<          /* mind recording device can only be stopped by appli */ 
<          if (this->cec.device_type != CEC_DEVICE_TYPE_REC_DEVICE) {
<             this->cec.source_status = CEC_POWER_STATUS_STANDBY;
<             hdmi_disable(1);
<             this->cec.power = tmPowerOn;
<             TRY(tmdlHdmiCecSetPowerState(this->cec.inst,this->cec.power));  /* keeps CEC alive */
<          }
<          break;
<       case CEC_OPCODE_ROUTING_INFORMATION:
<       case CEC_OPCODE_SET_STREAM_PATH:
<          /* wake-up if called */
<          if (this->cec.phy_addr == (((int)this->cec.frame.data[1] << 8) + this->cec.frame.data[2])) {
<             if (this->cec.source_status != CEC_POWER_STATUS_ON) {
<                this->cec.source_status = CEC_POWER_STATUS_ON;
<                hdmi_enable();
<             }
<             TRY(tmdlHdmiCecActiveSource(this->cec.inst,this->cec.phy_addr));
<          }
<          break;
< /*       case /\* NEW DECK ??? *\/ */
<       case CEC_OPCODE_ROUTING_CHANGE:
<          /* wake-up if called */
<          if (this->cec.phy_addr == (((int)this->cec.frame.data[3] << 8) + this->cec.frame.data[4])) {
<             if (this->cec.source_status != CEC_POWER_STATUS_ON) {
<                this->cec.source_status = CEC_POWER_STATUS_ON;
<                hdmi_enable();
<             }
<             TRY(tmdlHdmiCecActiveSource(this->cec.inst,this->cec.phy_addr));
<          }
<          break;
<       case CEC_OPCODE_ABORT_MESSAGE:
<          if (this->cec.phy_addr == (((int)this->cec.frame.data[3] << 8) + this->cec.frame.data[4])) {
<             TRY(tmdlHdmiCecFeatureAbort(this->cec.inst, \
<                                         this->cec.initiator, \
<                                         this->cec.feature_abort.FeatureOpcode, \
<                                         this->cec.feature_abort.AbortReason));
<          }
<          break;
<       case CEC_OPCODE_MENU_REQUEST:
< #ifdef TWL4030_HACK
<          this->cec.menu_status = CEC_MENU_STATE_ACTIVATE;
<          TRY(tmdlHdmiCecMenuStatus(this->cec.inst, \
<                                    this->cec.initiator, \
<                                    this->cec.menu_status));
<          break;
< #endif
<       case CEC_OPCODE_USER_CONTROL_PRESSED:
<          switch (this->cec.frame.data[1]) {
< #ifdef TWL4030_HACK /* AL : hack to bypass keypad */
<          case CEC_REMOTE_BUTTON_SELECT:
<             user_control(353,64);
<             break;
<          case CEC_REMOTE_BUTTON_UP:
<             user_control(103,128);
<             break;
<          case CEC_REMOTE_BUTTON_DOWN:
<             user_control(108,128);
<             break;
<          case CEC_REMOTE_BUTTON_LEFT:
<             user_control(105,128);
<             break;
<          case CEC_REMOTE_BUTTON_RIGHT:
<             user_control(106,128);
<             break;
<          case CEC_REMOTE_BUTTON_EXIT:
<             user_control(14,8);
<             break;
< #endif
<          case CEC_REMOTE_BUTTON_POWER:
<             this->cec.source_status = CEC_POWER_STATUS_ON;
<             hdmi_enable();
<             break;
<          default:
<             this->cec.feature_abort.FeatureOpcode=opcode;
<             this->cec.feature_abort.AbortReason=CEC_ABORT_INVALID_OPERAND;
<             TRY(tmdlHdmiCecFeatureAbort(this->cec.inst, \
<                                         this->cec.initiator, \
<                                         this->cec.feature_abort.FeatureOpcode, \
<                                         this->cec.feature_abort.AbortReason));
<             break;
<          }
<          break;
< #ifdef TWL4030_HACK
<       case CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN:
<          user_control(59,8);
< #endif
<          break;
<       case CEC_OPCODE_FEATURE_ABORT:
<          /* stop any state machine transition */
<          break;
<       case CEC_OPCODE_VENDOR_COMMAND:
<       case CEC_OPCODE_DEVICE_VENDOR_ID:
<          /* hopefully will be handle in userspace */
<          break;
<       default:
<          if (receiver != 0x0F) {
<             this->cec.feature_abort.FeatureOpcode=opcode;
<             this->cec.feature_abort.AbortReason=CEC_ABORT_UNKNOWN_OPCODE;
<             TRY(tmdlHdmiCecFeatureAbort(this->cec.inst,                 \
<                                         this->cec.initiator,            \
<                                         this->cec.feature_abort.FeatureOpcode, \
<                                         this->cec.feature_abort.AbortReason));
<          }
<          break;
<       }
<       this->driver.poll_done = true;
<       wake_up_interruptible(&this->driver.wait);
<    }
<    else if (event == TMDL_HDMICEC_CALLBACK_STATUS) {
< 
<       this->cec.frame.count = length;
<       this->cec.frame.addr = data[1]; /* .AddressByte */
<       initiator = (this->cec.frame.addr >> 4) & 0x0F;
<       receiver = this->cec.frame.addr & 0x0F;
<       memcpy(&this->cec.frame.data,&data[2],length-2); /* .DataBytes[], length - siezof(length,addr)  */
<       opcode=this->cec.frame.data[0];
<       this->cec.frame.service = CEC_TX_DONE;
< 
<       if (length==POLLING_LENGTH) {
<          if (opcode == CEC_MSG_FAIL_DEST_NOT_ACK) {
<             /* no echo means it's mine ! */
<             TRY(tmdlHdmiCecSetLogicalAddress(this->cec.inst,this->cec.rx_addr));
<             TRY(tmdlHdmiCecReportPhysicalAddress(this->cec.inst,        \
<                                                  this->cec.phy_addr,    \
<                                                  this->cec.device_type));
<             /* DEVICE VENDOR ID sending after logicial address allocation according to spec 1.4 */
<             TRY(tmdlHdmiCecDeviceVendorID(this->cec.inst, this->cec.vendor_id));
<          }
<          else if (opcode == CEC_MSG_SUCCESS) {
<             /* try next one */
<             this->cec.rx_addr=get_next_logical_addr(this->cec.device_type,this->cec.rx_addr);
<             if (this->cec.rx_addr != CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST) {
<                TRY(tmdlHdmiCecPollingMessage(this->cec.inst,this->cec.rx_addr));
<             }
<             else {
<                /* no more room, keep and claim unregistred */
<                TRY(tmdlHdmiCecSetLogicalAddress(this->cec.inst,this->cec.rx_addr));
<                TRY(tmdlHdmiCecReportPhysicalAddress(this->cec.inst,     \
<                                                     this->cec.phy_addr, \
<                                                     this->cec.device_type));
<             }
<          }
<          else {
<             printk(KERN_INFO "ACK [%x--->%x] %s\n",initiator,receiver,cec_rxstatus(opcode));
<          }
<       }
<       else {
<          if (CEC_MSG_SUCCESS != opcode) {
<             printk(KERN_INFO "ACK [%x--->%x] %s\n",initiator,receiver,cec_rxstatus(opcode));
<          }
<       }
< 
<       this->driver.poll_done = true;
<       wake_up_interruptible(&this->driver.wait);
< 
<    }
<    else {
<       LOG(KERN_ERR,"Oups ! Callback got invalid event %d !\n",event);
<    }
< 
<  TRY_DONE:
<    (void)err;
< }
< 
< /*
<  *  DevLib CEC opening
<  */
< static int hdmi_cec_init(cec_instance *this)
< {
<    int err=0;
< 
<    /* Real opening */
<    TRY(tmdlHdmiCecOpen(&this->cec.inst));
< 
< /*    this->cec.vendor_id = 0x006037;   /\* NXP (IEEE OUI) *\/ */
< /*    this->cec.vendor_id = 0x0000f0;   /\* Samsung *\/ */
<    this->cec.vendor_id = 0x00e091;   /* LGE */
< 
< /*    this->cec.version = CEC_VERSION_1_4; */
<    this->cec.version = CEC_VERSION_1_3a;
<    this->cec.osd_name.data[0]=0x54; /* TDA19989 by default */
<    this->cec.osd_name.data[1]=0x44;
<    this->cec.osd_name.data[2]=0x41;
<    this->cec.osd_name.data[3]=0x31;
<    this->cec.osd_name.data[4]=0x39;
<    this->cec.osd_name.data[5]=0x39;
<    this->cec.osd_name.data[6]=0x38;
<    this->cec.osd_name.data[7]=0x39;
<    this->cec.osd_name.length=8;
<    
<    TRY(tmdlHdmiCecRegisterCallbacks(this->cec.inst,eventCallbackCEC));
<        
<    this->cec.phy_addr = param_addr;
<    this->cec.device_type = device_type(param_device);
< 
<  TRY_DONE:
<    return err;
< }
< 
< 
< /*
<  *
<  * ENTRY POINTS
<  * ------------
<  * LEVEL 3
<  *
<  * - 
<  *
<  */
< 
< 
< 
< /*
<  *  ioctl driver :: opening
<  */
< 
< static int this_cdev_open(struct inode *pInode, struct file *pFile)
< {
<    cec_instance *this;
<    int minor=iminor(pInode);
< 
<    if(minor >= MAX_MINOR) {
<       printk(KERN_ERR "hdmicec:%s:only one cec opening please\n",__func__);
<       return -EINVAL;
<    }
< 
<    if ((pFile->private_data != NULL) && (pFile->private_data != &our_instance)) {
<       printk(KERN_ERR "hdmicec:%s:pFile missmatch\n",__func__);
<    }
<    this = pFile->private_data = &our_instance;
<    down(&this->driver.sem);
< 
<    LOG(KERN_INFO,"major:%d minor:%d user:%d\n", imajor(pInode), iminor(pInode), this->driver.user_counter);
< 
<    if ((this->driver.user_counter++) && (this->driver.minor == minor)) {
<       /* init already done */
<       up(&this->driver.sem);
<       return 0;
<    }
<    this->driver.minor = minor;
< 
< 
<    up(&this->driver.sem);
<    return 0;
< }
< 
< /*
<  *  ioctl driver :: ioctl
<  */
< static int this_cdev_ioctl(struct inode *pInode, struct file *pFile, unsigned int cmd, unsigned long arg)
< {
<    cec_instance* this = pFile->private_data;
<    int err=0;
< 
<    LOG(KERN_INFO,":%s\n",cec_ioctl(_IOC_NR(cmd)));
< 
<    BUG_ON(this->driver.minor!=iminor(pInode));
<    if (_IOC_TYPE(cmd) != CEC_IOCTL_BASE) {
<       printk(KERN_INFO "hdmicec:%s:unknown ioctl type: %x\n",__func__,_IOC_TYPE(cmd));
<       return -ENOIOCTLCMD;
<    }
< 
<    if (_IOC_DIR(cmd) & _IOC_READ) 
<       err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd)) || !arg;
<    else if (_IOC_DIR(cmd) & _IOC_WRITE)
<       err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd)) || !arg;
<    if (err) {
<       printk(KERN_ERR "hdmicec:%s:argument access denied (check address vs value)\n",__func__);
<       printk(KERN_ERR "_IOC_DIR:%d arg:%lx\n",_IOC_DIR(cmd),arg);
<       return -EFAULT;
<    }
<    
<    down(&this->driver.sem);
< 
<    /* Check DevLib consistancy here */
< 
<    switch ( _IOC_NR(cmd) )
<       {
<       case CEC_VERBOSE_ON_CMD:
<          {
<             printk(KERN_INFO "verbose on\n");
<             this->param.verbose=1;
<             break;
<          }
< 
<       case CEC_VERBOSE_OFF_CMD:
<          {
<             printk(KERN_INFO "verbose off\n");
<             this->param.verbose=0;
<             break;
<          }
< 
<       case CEC_BYEBYE_CMD:
<          {
<             LOG(KERN_INFO,"callback release request\n");
<             this->cec.frame.service=CEC_RELEASE;
<             this->driver.poll_done = true;
<             wake_up_interruptible(&this->driver.wait);
<             break;
<          }
< 
<          /*
<            no param
<          */
< 
<       case CEC_IOCTL_DISABLE_CALIBRATION_CMD:
<          {
<             TRY(tmdlHdmiCecDisableCalibration(this->cec.inst));
<             break;
<          }
< 
<       case CEC_IOCTL_INSTANCE_CONFIG_CMD:
<          {
<             TRY(tmdlHdmiCecInstanceConfig(this->cec.inst));
<             break;
<          }
< 
<       case CEC_IOCTL_REQUEST_ACTIVE_SRC_CMD:
<          {
<             TRY(tmdlHdmiCecRequestActiveSource(this->cec.inst));
<             break;
<          }
< 
<       case CEC_IOCTL_ABORT_MSG_CMD:
<          {
<             TRY(tmdlHdmiCecAbortMessage(this->cec.inst,this->cec.initiator));
<             break;
<          }
< 
<       case CEC_IOCTL_GET_MENU_LANGUAGE_CMD:
<          {
<             TRY(tmdlHdmiCecGetMenuLanguage(this->cec.inst,this->cec.initiator));
<             break;
<          }
< 
<       case CEC_IOCTL_GIVE_AUDIO_STATUS_CMD:
<          {
<             TRY(tmdlHdmiCecGiveAudioStatus(this->cec.inst,this->cec.initiator));
<             break;
<          }
< 
<       case CEC_IOCTL_GIVE_DEVICE_POWER_STATUS_CMD:
<          {
<             TRY(tmdlHdmiCecGiveDevicePowerStatus(this->cec.inst,this->cec.initiator));
<             break;
<          }
< 
<       case CEC_IOCTL_GIVE_DEVICE_VENDOR_ID_CMD:
<          {
<             TRY(tmdlHdmiCecGiveDeviceVendorID(this->cec.inst,this->cec.initiator));
<             break;
<          }
< 
<       case CEC_IOCTL_GIVE_OSD_NAME_CMD:
<          {
<             TRY(tmdlHdmiCecGiveOsdName(this->cec.inst,this->cec.initiator));
<             break;
<          }
< 
<       case CEC_IOCTL_GIVE_PHY_ADDR_CMD:
<          {
<             TRY(tmdlHdmiCecGivePhysicalAddress(this->cec.inst,this->cec.initiator));
<             break;
<          }
< 
<       case CEC_IOCTL_GIVE_SYS_AUDIO_MODE_STATUS_CMD:
<          {
<             TRY(tmdlHdmiCecGiveSystemAudioModeStatus(this->cec.inst,this->cec.initiator));
<             break;
<          }
< 
<       case CEC_IOCTL_IMAGE_VIEW_ON_CMD:
<          {
<             TRY(tmdlHdmiCecImageViewOn(this->cec.inst,this->cec.initiator));
<             break;
<          }
< 
<       case CEC_IOCTL_POLLING_MSG_CMD:
<          {
<             TRY(tmdlHdmiCecPollingMessage(this->cec.inst,this->cec.rx_addr));
<             break;
<          }
< 
<       case CEC_IOCTL_REC_OFF_CMD:
<          {
<             TRY(tmdlHdmiCecRecordOff(this->cec.inst,this->cec.initiator));
<             break;
<          }
< 
<       case CEC_IOCTL_REC_ON_OWN_SRC_CMD:
<          {
<             TRY(tmdlHdmiCecRecordOnOwnSource(this->cec.inst,this->cec.initiator));
<             break;
<          }
< 
<       case CEC_IOCTL_REC_TV_SCREEN_CMD:
<          {
<             TRY(tmdlHdmiCecRecordTvScreen(this->cec.inst,this->cec.initiator));
<             break;
<          }
< 
<       case CEC_IOCTL_STANDBY_CMD:
<          {
<             TRY(tmdlHdmiCecStandby(this->cec.inst,this->cec.initiator));
<             break;
<          }
< 
<       case CEC_IOCTL_TEXT_VIEW_ON_CMD:
<          {
<             TRY(tmdlHdmiCecTextViewOn(this->cec.inst,this->cec.initiator));
<             break;
<          }
< 
<       case CEC_IOCTL_TUNER_STEP_DECREMENT_CMD:
<          {
<             TRY(tmdlHdmiCecTunerStepDecrement(this->cec.inst,this->cec.initiator));
<             break;
<          }
< 
<       case CEC_IOCTL_TUNER_STEP_INCREMENT_CMD:
<          {
<             TRY(tmdlHdmiCecTunerStepIncrement(this->cec.inst,this->cec.initiator));
<             break;
<          }
< 
<       case CEC_IOCTL_USER_CTRL_RELEASED_CMD:
<          {
<             TRY(tmdlHdmiCecUserControlReleased(this->cec.inst,this->cec.initiator));
<             break;
<          }
< 
<       case CEC_IOCTL_VENDOR_REMOTE_BUTTON_UP_CMD:
<          {
<             TRY(tmdlHdmiCecVendorRemoteButtonUp(this->cec.inst,this->cec.initiator));
<             break;
<          }
< 
<       case CEC_IOCTL_ROUTING_INFORMATION_CMD:
<          {
<             TRY(tmdlHdmiCecRoutingInformation(this->cec.inst,this->cec.phy_addr));
<             break;
<          }
< 
<       case CEC_IOCTL_SET_STREAM_PATH_CMD:
<          {
<             TRY(tmdlHdmiCecSetStreamPath(this->cec.inst,this->cec.phy_addr));
<             break;
<          }
< 
<       case CEC_IOCTL_ACTIVE_SRC_CMD:
<          {
<             /* NEW first do a <image view on> */
<             /* NEW when switch by DSS and was inactive */
<             TRY(tmdlHdmiCecActiveSource(this->cec.inst,this->cec.phy_addr));
<             break;
<          }
< 
<       case CEC_IOCTL_SYS_AUDIO_MODE_REQUEST_CMD:
<          {
<             TRY(tmdlHdmiCecSystemAudioModeRequest(this->cec.inst, \
<                                                   this->cec.initiator, \
<                                                   this->cec.phy_addr));
<             break;
<          }
< 
<          /*
<            1 param
<          */
< 
<       case CEC_IOCTL_RX_ADDR_CMD:
<          {
<             /* 	    BUG_ON(copy_from_user(&this->cec.rx_addr,(unsigned char*)arg,sizeof(unsigned char)) != 0); */
<             this->cec.rx_addr=arg;
<             TRY(tmdlHdmiCecSetLogicalAddress(this->cec.inst,this->cec.rx_addr));
<             break;
<          }
< 
<       case CEC_IOCTL_PHY_ADDR_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.phy_addr,(unsigned short*)arg,sizeof(unsigned short)) != 0);
<             break;
<          }
< 
<       case CEC_IOCTL_GET_CEC_VERSION_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.version,(cec_version*)arg,sizeof(cec_version)) != 0);
<             TRY(tmdlHdmiCecGetCecVersion(this->cec.inst,this->cec.version));
<             break;
<          }
< 
<       case CEC_IOCTL_GET_SW_VERSION_CMD:
<          {
<             TRY(tmdlHdmiCecGetSWVersion(&this->cec.sw_version));
<             BUG_ON(copy_to_user((cec_sw_version*)arg,&this->cec.sw_version,sizeof(cec_sw_version)) != 0);
<             break;
<          }
< 
<       case CEC_IOCTL_SET_POWER_STATE_CMD:
<          {
<             /* NEW : log : please use DSS */
<             BUG_ON(copy_from_user(&this->cec.power,(cec_power*)arg,sizeof(cec_power)) != 0);
<             TRY(tmdlHdmiCecSetPowerState(this->cec.inst,this->cec.power));
<             break;
<          }
< 
<       case CEC_IOCTL_GET_POWER_STATE_CMD:
<          {
<             TRY(tmdlHdmiCecGetPowerState(this->cec.inst,&this->cec.power));
<             BUG_ON(copy_to_user((cec_power*)arg,&this->cec.power,sizeof(cec_power)) != 0);
<             break;
<          }
< 
<       case CEC_IOCTL_INSTANCE_SETUP_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.setup,(cec_setup*)arg,sizeof(cec_setup)) != 0);
<             TRY(tmdlHdmiCecInstanceSetup(this->cec.inst,&this->cec.setup));
<             break;
<          }
< 
<       case CEC_IOCTL_GET_INSTANCE_SETUP_CMD:
<          {
<             TRY(tmdlHdmiCecGetInstanceSetup(this->cec.inst,&this->cec.setup));
<             BUG_ON(copy_to_user((cec_setup*)arg,&this->cec.setup,sizeof(cec_setup)) != 0);
<             break;
<          }
< 
<          /*
<            case CEC_IOCTL_ENABLE_EVENT_CMD:
<            {
<            BUG_ON(copy_from_user(&this->cec.an_event,(cec_event*)arg,sizeof(cec_event)) != 0);
<            TRY(tmdlHdmiCecEnableEvent(this->cec.inst,this->cec.an_event));
<            break;
<            }
< 
<            case CEC_IOCTL_DISABLE_EVENT_CMD:
<            {
<            BUG_ON(copy_from_user(&this->cec.an_event,(cec_event*)arg,sizeof(cec_event)) != 0);
<            TRY(tmdlHdmiCecDisableEvent(this->cec.inst,this->cec.an_event));
<            break;
<            }
<          */
< 
<       case CEC_IOCTL_SET_MENU_LANGUAGE_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.clock,(cec_string*)arg,sizeof(cec_string)) != 0);
<             TRY(tmdlHdmiCecSetMenuLanguage(this->cec.inst,this->cec.string.data));
<             break;
<          }
< 
<       case CEC_IOCTL_ENABLE_CALIBRATION_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.clock,(cec_clock*)arg,sizeof(cec_clock)) != 0);
<             TRY(tmdlHdmiCecEnableCalibration(this->cec.inst,this->cec.clock));
<             break;
<          }
< 
<          /*
<            >1 param
<          */
< 
<       case CEC_IOCTL_WAIT_FRAME_CMD:
<          {
<             this->cec.frame.service = CEC_WAITING;
<             this->driver.poll_done = false;
<             up(&this->driver.sem);
<             if (wait_event_interruptible(this->driver.wait,this->driver.poll_done)) return -ERESTARTSYS;
<             down(&this->driver.sem);
<             BUG_ON(copy_to_user((cec_frame*)arg,&this->cec.frame,sizeof(cec_frame)) != 0);
<             break;
<          }
< 
<       case CEC_IOCTL_VERSION_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.version,(cec_version*)arg,sizeof(cec_version)) != 0);
<             TRY(tmdlHdmiCecVersion(this->cec.inst, \
<                                    this->cec.initiator, \
<                                    this->cec.version));
<             break;
<          }
< 
<       case CEC_IOCTL_CLEAR_ANALOGUE_TIMER_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.analog_timer,(cec_analogue_timer*)arg,sizeof(cec_analogue_timer)) != 0);
<             TRY(tmdlHdmiCecClearAnalogueTimer(this->cec.inst, \
<                                               this->cec.initiator, \
<                                               this->cec.analog_timer.DayOfMonth, \
<                                               this->cec.analog_timer.MonthOfYear, \
<                                               this->cec.analog_timer.StartTime, \
<                                               &this->cec.analog_timer.Duration, \
<                                               this->cec.analog_timer.RecordingSequence, \
<                                               this->cec.analog_timer.AnalogueBroadcastType, \
<                                               this->cec.analog_timer.AnalogueFrequency, \
<                                               this->cec.analog_timer.BroadcastSystem));
<             break;
<          }
< 
<       case CEC_IOCTL_CLEAR_DIGITAL_TIMER_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.digital_timer,(cec_digital_timer*)arg,sizeof(cec_digital_timer)) != 0);
<             TRY(tmdlHdmiCecClearDigitalTimer(this->cec.inst, \
<                                              this->cec.initiator, \
<                                              this->cec.digital_timer.DayOfMonth, \
<                                              this->cec.digital_timer.MonthOfYear, \
<                                              this->cec.digital_timer.StartTime, \
<                                              &this->cec.digital_timer.Duration, \
<                                              this->cec.digital_timer.RecordingSequence, \
<                                              &this->cec.digital_timer.ServiceIdentification));
<             break;
<          }
< 
<       case CEC_IOCTL_CLEAR_EXT_TIMER_WITH_EXT_PLUG_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.etwep,(cec_ext_timer_with_ext_plug*)arg,sizeof(cec_ext_timer_with_ext_plug)) != 0);
<             TRY(tmdlHdmiCecClearExternalTimerWithExternalPlug(this->cec.inst, \
<                                                               this->cec.initiator, \
<                                                               this->cec.etwep.DayOfMonth, \
<                                                               this->cec.etwep.MonthOfYear, \
<                                                               this->cec.etwep.StartTime, \
<                                                               &this->cec.etwep.Duration, \
<                                                               this->cec.etwep.RecordingSequence, \
<                                                               this->cec.etwep.ExternalPlug));
<             break;
<          }
< 
<       case CEC_IOCTL_CLEAR_EXT_TIMER_WITH_PHY_ADDR_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.etwpa,(cec_ext_timer_with_phy_addr*)arg,sizeof(cec_ext_timer_with_phy_addr)) != 0);
<             TRY(tmdlHdmiCecClearExternalTimerWithPhysicalAddress(this->cec.inst, \
<                                                                  this->cec.initiator, \
<                                                                  this->cec.etwpa.DayOfMonth, \
<                                                                  this->cec.etwpa.MonthOfYear, \
<                                                                  this->cec.etwpa.StartTime, \
<                                                                  &this->cec.etwpa.Duration, \
<                                                                  this->cec.etwpa.RecordingSequence, \
<                                                                  this->cec.etwpa.ExternalPhysicalAddress));
<             break;
<          }
< 
<       case CEC_IOCTL_DECK_CTRL_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.deck_ctrl,(cec_deck_ctrl*)arg,sizeof(cec_deck_ctrl)) != 0);
<             TRY(tmdlHdmiCecDeckControl(this->cec.inst, \
<                                        this->cec.initiator, \
<                                        this->cec.deck_ctrl));
<             break;
<          }
< 
<       case CEC_IOCTL_DECK_STATUS_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.deck_status,(cec_deck_status*)arg,sizeof(cec_deck_status)) != 0);
<             TRY(tmdlHdmiCecDeckStatus(this->cec.inst, \
<                                       this->cec.initiator, \
<                                       this->cec.deck_status));
<             break;
<          }
< 
<       case CEC_IOCTL_DEVICE_VENDOR_ID_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.vendor_id,(unsigned long*)arg,sizeof(unsigned long)) != 0);
<             TRY(tmdlHdmiCecDeviceVendorID(this->cec.inst, \
<                                           this->cec.vendor_id));
<             break;
<          }
< 
<       case CEC_IOCTL_FEATURE_ABORT_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.feature_abort,(cec_feature_abort*)arg,sizeof(cec_feature_abort)) != 0);
<             TRY(tmdlHdmiCecFeatureAbort(this->cec.inst, \
<                                         this->cec.initiator, \
<                                         this->cec.feature_abort.FeatureOpcode, \
<                                         this->cec.feature_abort.AbortReason));
<             break;
<          }
< 
<       case CEC_IOCTL_GIVE_DECK_STATUS_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.satus_request,(cec_status_request*)arg,sizeof(cec_status_request)) != 0);
<             TRY(tmdlHdmiCecGiveDeckStatus(this->cec.inst, \
<                                           this->cec.initiator, \
<                                           this->cec.satus_request));
<             break;
<          }
< 
<       case CEC_IOCTL_GIVE_TUNER_DEVICE_STATUS_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.satus_request,(cec_status_request*)arg,sizeof(cec_status_request*)) != 0);
<             TRY(tmdlHdmiCecGiveTunerDeviceStatus(this->cec.inst, \
<                                                  this->cec.initiator, \
<                                                  this->cec.satus_request));
<             break;
<          }
< 
<       case CEC_IOCTL_INACTIVE_SRC_CMD:
<          {
<             /* NEW first stand by video */
<             /* NEW when hdmi_disable and was active */
<             TRY(tmdlHdmiCecInactiveSource(this->cec.inst, \
<                                           this->cec.initiator, \
<                                           this->cec.phy_addr));
<             break;
<          }
< 
<       case CEC_IOCTL_MENU_REQUEST_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.menu_request,(cec_menu_request*)arg,sizeof(cec_menu_request)) != 0);
<             TRY(tmdlHdmiCecMenuRequest(this->cec.inst, \
<                                        this->cec.initiator, \
<                                        this->cec.menu_request));
<             break;
<          }
< 
<       case CEC_IOCTL_MENU_STATUS_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.menu_status,(cec_menu_status*)arg,sizeof(cec_menu_status)) != 0);
<             TRY(tmdlHdmiCecMenuStatus(this->cec.inst, \
<                                       this->cec.initiator, \
<                                       this->cec.menu_status));
<             break;
<          }
< 
<       case CEC_IOCTL_PLAY_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.play,(cec_play*)arg,sizeof(cec_play)) != 0);
<             TRY(tmdlHdmiCecPlay(this->cec.inst, \
<                                 this->cec.initiator, \
<                                 this->cec.play));
<             break;
<          }
< 
<       case CEC_IOCTL_REC_ON_ANALOGUE_SERVICE_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.analog_service,(cec_analogue_service*)arg,sizeof(cec_analogue_service)) != 0);
<             TRY(tmdlHdmiCecRecordOnAnalogueService(this->cec.inst, \
<                                                    this->cec.initiator, \
<                                                    this->cec.analog_service.AnalogueBroadcastType, \
<                                                    this->cec.analog_service.AnalogueFrequency, \
<                                                    this->cec.analog_service.BroadcastSystem));
<             break;
<          }
< 
<       case CEC_IOCTL_REC_ON_DIGITAL_SERVICE_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.digital_service,(cec_digital_service*)arg,sizeof(cec_digital_service)) != 0);
<             TRY(tmdlHdmiCecRecordOnDigitalService(this->cec.inst, \
<                                                   this->cec.initiator, \
<                                                   &this->cec.digital_service));
<             break;
<          }
< 
<       case CEC_IOCTL_REC_ON_EXT_PHY_ADDR_CMD:
<          {
<             TRY(tmdlHdmiCecRecordOnExternalPhysicalAddress(this->cec.inst, \
<                                                            this->cec.initiator, \
<                                                            this->cec.phy_addr));
<             break;
<          }
< 
<       case CEC_IOCTL_REC_ON_EXT_PLUG_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.ext_plug,(cec_ext_plug*)arg,sizeof(cec_ext_plug)) != 0);
<             TRY(tmdlHdmiCecRecordOnExternalPlug(this->cec.inst, \
<                                                 this->cec.initiator, \
<                                                 this->cec.ext_plug));
<             break;
<          }
< 
<       case CEC_IOCTL_REC_STATUS_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.rec_status,(cec_rec_status*)arg,sizeof(cec_rec_status)) != 0);
<             TRY(tmdlHdmiCecRecordStatus(this->cec.inst, \
<                                         this->cec.initiator, \
<                                         this->cec.rec_status));
<             break;
<          }
< 
<       case CEC_IOCTL_REPORT_AUDIO_STATUS_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.audio_status,(cec_audio_status*)arg,sizeof(cec_audio_status)) != 0);
<             TRY(tmdlHdmiCecReportAudioStatus(this->cec.inst, \
<                                              this->cec.initiator, \
<                                              &this->cec.audio_status));
<             break;
<          }
< 
<       case CEC_IOCTL_REPORT_PHY_ADDR_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.device_type,(cec_device_type*)arg,sizeof(cec_device_type)) != 0);
<             TRY(tmdlHdmiCecReportPhysicalAddress(this->cec.inst, \
<                                                  this->cec.phy_addr, \
<                                                  this->cec.device_type));
<             break;
<          }
< 
<       case CEC_IOCTL_REPORT_POWER_STATUS_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.source_status,(cec_power_status*)arg,sizeof(cec_power_status)) != 0);
<             TRY(tmdlHdmiCecReportPowerStatus(this->cec.inst, \
<                                              this->cec.initiator, \
<                                              this->cec.source_status));
<             break;
<          }
< 
<       case CEC_IOCTL_SELECT_ANALOGUE_SERVICE_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.analog_service,(cec_analogue_service*)arg,sizeof(cec_analogue_service)) != 0);
<             TRY(tmdlHdmiCecSelectAnalogueService(this->cec.inst, \
<                                                  this->cec.initiator, \
<                                                  this->cec.analog_service.AnalogueBroadcastType, \
<                                                  this->cec.analog_service.AnalogueFrequency, \
<                                                  this->cec.analog_service.BroadcastSystem));
<             break;
<          }
< 
<       case CEC_IOCTL_SELECT_DIGITAL_SERVICE_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.digital_service,(cec_digital_service*)arg,sizeof(cec_digital_service)) != 0);
<             TRY(tmdlHdmiCecSelectDigitalService(this->cec.inst, \
<                                                 this->cec.initiator, \
<                                                 &this->cec.digital_service));
<             break;
<          }
< 
<       case CEC_IOCTL_SET_ANALOGUE_TIMER_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.analog_timer,(cec_analogue_timer*)arg,sizeof(cec_analogue_timer)) != 0);
<             TRY(tmdlHdmiCecSetAnalogueTimer(this->cec.inst, \
<                                             this->cec.initiator, \
<                                             this->cec.analog_timer.DayOfMonth, \
<                                             this->cec.analog_timer.MonthOfYear, \
<                                             this->cec.analog_timer.StartTime, \
<                                             &this->cec.analog_timer.Duration, \
<                                             this->cec.analog_timer.RecordingSequence, \
<                                             this->cec.analog_timer.AnalogueBroadcastType, \
<                                             this->cec.analog_timer.AnalogueFrequency, \
<                                             this->cec.analog_timer.BroadcastSystem));
<             break;
<          }
< 
<       case CEC_IOCTL_SET_AUDIO_RATE_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.audio_rate,(cec_audio_rate*)arg,sizeof(cec_audio_rate)) != 0);
<             TRY(tmdlHdmiCecSetAudioRate(this->cec.inst, \
<                                         this->cec.initiator, \
<                                         this->cec.audio_rate));
<             break;
<          }
< 
<       case CEC_IOCTL_SET_DIGITAL_TIMER_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.digital_timer,(cec_digital_timer*)arg,sizeof(cec_digital_timer)) != 0);
<             TRY(tmdlHdmiCecSetDigitalTimer(this->cec.inst, \
<                                            this->cec.initiator, \
<                                            this->cec.digital_timer.DayOfMonth, \
<                                            this->cec.digital_timer.MonthOfYear, \
<                                            this->cec.digital_timer.StartTime, \
<                                            &this->cec.digital_timer.Duration, \
<                                            this->cec.digital_timer.RecordingSequence, \
<                                            &this->cec.digital_timer.ServiceIdentification));
<             break;
<          }
< 
<       case CEC_IOCTL_SET_EXT_TIMER_WITH_EXT_PLUG_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.etwep,(cec_ext_timer_with_ext_plug*)arg,sizeof(cec_ext_timer_with_ext_plug)) != 0);
<             TRY(tmdlHdmiCecSetExternalTimerWithExternalPlug(this->cec.inst, \
<                                                             this->cec.initiator, \
<                                                             this->cec.etwep.DayOfMonth, \
<                                                             this->cec.etwep.MonthOfYear, \
<                                                             this->cec.etwep.StartTime, \
<                                                             &this->cec.etwep.Duration, \
<                                                             this->cec.etwep.RecordingSequence, \
<                                                             this->cec.etwep.ExternalPlug));
<             break;
<          }
< 
<       case CEC_IOCTL_SET_EXT_TIMER_WITH_PHY_ADDR_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.etwpa,(cec_ext_timer_with_phy_addr*)arg,sizeof(cec_ext_timer_with_phy_addr)) != 0);
<             TRY(tmdlHdmiCecSetExternalTimerWithPhysicalAddress(this->cec.inst, \
<                                                                this->cec.initiator, \
<                                                                this->cec.etwpa.DayOfMonth, \
<                                                                this->cec.etwpa.MonthOfYear, \
<                                                                this->cec.etwpa.StartTime, \
<                                                                &this->cec.etwpa.Duration, \
<                                                                this->cec.etwpa.RecordingSequence, \
<                                                                this->cec.etwpa.ExternalPhysicalAddress));
<             break;
<          }
< 
<       case CEC_IOCTL_SET_SYS_AUDIO_MODE_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.sys_audio_status,(cec_sys_audio_status*)arg,sizeof(cec_sys_audio_status)) != 0);
<             TRY(tmdlHdmiCecSetSystemAudioMode(this->cec.inst, \
<                                               this->cec.initiator, \
<                                               this->cec.sys_audio_status));
<             break;
<          }
< 
<       case CEC_IOCTL_SYS_AUDIO_MODE_STATUS_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.sys_audio_status,(cec_sys_audio_status*)arg,sizeof(cec_sys_audio_status)) != 0);
<             TRY(tmdlHdmiCecSystemAudioModeStatus(this->cec.inst, \
<                                                  this->cec.initiator, \
<                                                  this->cec.sys_audio_status));
<             break;
<          }
< 
<       case CEC_IOCTL_TIMER_CLEARED_STATUS_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.timer_cleared_status,(cec_timer_cleared_status*)arg,sizeof(cec_timer_cleared_status)) != 0);
<             TRY(tmdlHdmiCecTimerClearedStatus(this->cec.inst, \
<                                               this->cec.initiator, \
<                                               this->cec.timer_cleared_status));
<             break;
<          }
< 
<       case CEC_IOCTL_TIMER_STATUS_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.timer_status,(cec_timer_status*)arg,sizeof(cec_timer_status)) != 0);
<             TRY(tmdlHdmiCecTimerStatus(this->cec.inst, \
<                                        this->cec.initiator, \
<                                        &this->cec.timer_status));
<             break;
<          }
< 
<       case CEC_IOCTL_TUNER_DEVICE_STATUS_ANALOGUE_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.tdsa,(cec_tuner_device_status_analogue*)arg,sizeof(cec_tuner_device_status_analogue)) != 0);
<             TRY(tmdlHdmiCecTunerDeviceStatusAnalogue(this->cec.inst, \
<                                                      this->cec.initiator, \
<                                                      this->cec.tdsa.RecordingFlag, \
<                                                      this->cec.tdsa.TunerDisplayInfo, \
<                                                      this->cec.tdsa.AnalogueBroadcastType, \
<                                                      this->cec.tdsa.AnalogueFrequency, \
<                                                      this->cec.tdsa.BroadcastSystem));
<             break;
<          }
< 
<       case CEC_IOCTL_TUNER_DEVICE_STATUS_DIGITAL_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.tdsd,(cec_tuner_device_status_digital*)arg,sizeof(cec_tuner_device_status_digital)) != 0);
<             TRY(tmdlHdmiCecTunerDeviceStatusDigital(this->cec.inst, \
<                                                     this->cec.initiator, \
<                                                     this->cec.tdsd.RecordingFlag, \
<                                                     this->cec.tdsd.TunerDisplayInfo, \
<                                                     &this->cec.tdsd.ServiceIdentification));
<             break;
<          }
< 
<       case CEC_IOCTL_USER_CTRL_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.user_ctrl,(cec_user_ctrl*)arg,sizeof(cec_user_ctrl)) != 0);
<             TRY(tmdlHdmiCecUserControlPressed(this->cec.inst, \
<                                               this->cec.initiator, \
<                                               this->cec.user_ctrl));
<             break;
<          }
< 
<       case CEC_IOCTL_USER_CTRL_PLAY_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.play,(cec_play*)arg,sizeof(cec_play)) != 0);
<             TRY(tmdlHdmiCecUserControlPressedPlay(this->cec.inst, \
<                                                   this->cec.initiator, \
<                                                   this->cec.play));
<             break;
<          }
< 
<       case CEC_IOCTL_USER_CTRL_SELECT_AUDIOINPUT_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.select,(unsigned char*)arg,sizeof(unsigned char)) != 0);
<             TRY(tmdlHdmiCecUserControlPressedSelectAudioInput(this->cec.inst, \
<                                                               this->cec.initiator, \
<                                                               this->cec.select));
<             break;
<          }
< 
<       case CEC_IOCTL_USER_CTRL_SELECT_AVINPUT_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.select,(unsigned char*)arg,sizeof(unsigned char)) != 0);
<             TRY(tmdlHdmiCecUserControlPressedSelectAVInput(this->cec.inst, \
<                                                            this->cec.initiator, \
<                                                            this->cec.select));
<             break;
<          }
< 
<       case CEC_IOCTL_USER_CTRL_SELECT_MEDIA_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.select,(unsigned char*)arg,sizeof(unsigned char)) != 0);
<             TRY(tmdlHdmiCecUserControlPressedSelectMedia(this->cec.inst, \
<                                                          this->cec.initiator, \
<                                                          this->cec.select));
<             break;
<          }
< 
<       case CEC_IOCTL_USER_CTRL_TUNE_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.user_ctrl_tune,(cec_user_ctrl_tune*)arg,sizeof(cec_user_ctrl_tune)) != 0);
<             TRY(tmdlHdmiCecUserControlPressedTune(this->cec.inst, \
<                                                   this->cec.initiator, \
<                                                   &this->cec.user_ctrl_tune));
<             break;
<          }
< 
<       case CEC_IOCTL_SET_OSD_NAME_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.osd_name,(cec_string*)arg,sizeof(cec_string)) != 0);
<             TRY(tmdlHdmiCecSetOsdName(this->cec.inst,      \
<                                       this->cec.initiator, \
<                                       this->cec.osd_name.data, \
<                                       this->cec.osd_name.length));
<             break;
<          }
< 
<       case CEC_IOCTL_SET_OSD_STRING_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.osd_string,(cec_osd_string*)arg,sizeof(cec_osd_string)) != 0);
<             TRY(tmdlHdmiCecSetOsdString(this->cec.inst, \
<                                         this->cec.initiator, \
<                                         this->cec.osd_string.DisplayControl, \
<                                         this->cec.osd_string.data, \
<                                         this->cec.osd_string.length));
<             break;
<          }
< 
<       case CEC_IOCTL_SET_TIMER_PROGRAM_TITLE_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.string,(cec_string*)arg,sizeof(cec_string)) != 0);
<             TRY(tmdlHdmiCecSetTimerProgramTitle(this->cec.inst, \
<                                                 this->cec.initiator, \
<                                                 this->cec.string.data, \
<                                                 this->cec.string.length));
<             break;
<          }
< 
<       case CEC_IOCTL_VENDOR_COMMAND_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.string,(cec_string*)arg,sizeof(cec_string)) != 0);
<             TRY(tmdlHdmiCecVendorCommand(this->cec.inst, \
<                                          this->cec.initiator, \
<                                          this->cec.string.data, \
<                                          this->cec.string.length));
<             break;
<          }
< 
<       case CEC_IOCTL_VENDOR_REMOTE_BUTTON_DOWN_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.string,(cec_string*)arg,sizeof(cec_string)) != 0);
<             TRY(tmdlHdmiCecVendorRemoteButtonDown(this->cec.inst, \
<                                                   this->cec.initiator, \
<                                                   this->cec.string.data, \
<                                                   this->cec.string.length));
<             break;
<          }
< 
<       case CEC_IOCTL_VENDOR_COMMAND_WITH_ID_CMD:
<          {
<             BUG_ON(copy_from_user(&this->cec.vcwi,(cec_vendor_command_with_id*)arg,sizeof(cec_vendor_command_with_id)) != 0);
<             TRY(tmdlHdmiCecVendorCommandWithID(this->cec.inst,	\
<                                                this->cec.initiator,	\
<                                                this->cec.vcwi.VendorID, \
<                                                this->cec.vcwi.cmd.data, \
<                                                this->cec.vcwi.cmd.length));
<             break;
<          }
< 
<          /*       case : */
<          /* 	 { */
<          /* 	    BUG_ON(copy_from_user(&this->cec.,(*)arg,sizeof()) != 0); */
<          /* 	    TRY((this->cec.inst, \ */
<          /* 		 this->cec.,	 \ */
<          /* 		 &this->cec.)); */
<          /* 	    break; */
<          /* 	 } */
< 
<       default:
<          {
<             /* unrecognized ioctl */	
<             printk(KERN_INFO " unknown ioctl %x\n",cmd);
<             up(&this->driver.sem);
<             return -ENOIOCTLCMD;
<          }
<       }
< 
<  TRY_DONE:
<    up(&this->driver.sem);
<    return err;
< }
< 
< /*
<  *  ioctl driver :: releasing
<  */
< static int this_cdev_release(struct inode *pInode, struct file *pFile)
< {
<    cec_instance* this = pFile->private_data;
<    int minor = iminor(pInode);
< 
<    LOG(KERN_INFO,"called\n");
< 
<    if(minor >= MAX_MINOR) {
<       return -EINVAL;
<    }
< 
<    BUG_ON(this->driver.minor!=iminor(pInode));
<    down(&this->driver.sem);
< 
<    this->driver.user_counter--;
<    if(this->driver.user_counter == 0) {
<       pFile->private_data = NULL;
<    }
<    else {
<       LOG(KERN_INFO,"Still %d user pending\n",this->driver.user_counter);
<    }
< 
<    up(&this->driver.sem);
<    return 0;
< }
< 
< /*
<  *  I2C client :: creation
<  */
< static int __devinit this_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
< {
<    cec_instance *this=&our_instance;
<    int err=0;
< 
<    LOG(KERN_INFO,"called\n");
< 
<    /*
<      I2C setup
<    */
<    if (this->driver.i2c_client) {
<       dev_err(&this->driver.i2c_client->dev, "<%s> CEC Device already created \n",
<               __func__);
<       return -ENODEV;
<    }
< 
<    this->driver.i2c_client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
<    if (!this->driver.i2c_client) {
<       return -ENOMEM;
<    }
<    memset(this->driver.i2c_client, 0, sizeof(struct i2c_client));
< 
<    strncpy(this->driver.i2c_client->name, CEC_NAME, I2C_NAME_SIZE);
<    this->driver.i2c_client->addr = TDA99XCEC_I2C_SLAVEADDRESS;
<    this->driver.i2c_client->adapter = client->adapter;
< 
<    i2c_set_clientdata(client, this->driver.i2c_client);
< 
<    tmdlHdmiCecGetSWVersion(&this->cec.sw_version);
<    LOG(KERN_INFO,"HDMI CEC SW Version:%lu.%lu compatibility:%lu\n", \
<        this->cec.sw_version.majorVersionNr,\
<        this->cec.sw_version.minorVersionNr,\
<        this->cec.sw_version.compatibilityNr);
< 
<    /* I2C ok, then let's startup CEC */
< 
<    /* prepare event */
<    this->driver.poll_done = true; /* currently idle */
<    init_waitqueue_head(&this->driver.wait);
< #ifndef IRQ
<    init_timer(&this->driver.timer); /* do it before request_irq */
<    this->driver.timer.function=polling_timeout;
<    this->driver.timer.data=0;
<    this->driver.timer.expires = jiffies + HZ; /* start polling in one sec */
<    add_timer(&this->driver.timer);
< #else
<    register_cec_interrupt((cec_callback_t)cec_interrupt);
< #endif
< 
< #ifndef IRQ
<    /* FRO calibration */
<    err=gpio_request(TDA_IRQ_CALIB,"tda19989 calibration");
<    if (err < 0) {
<       printk(KERN_ERR "hdmicec:%s:cannot use GPIO 107\n",__func__);
<       goto i2c_out;
<    }
<    /* turn GPIO into IRQ */
<    gpio_direction_input(TDA_IRQ_CALIB);
<    msleep(1);
<    if (request_irq(gpio_to_irq(TDA_IRQ_CALIB), \
<                    tda_irq, IRQF_TRIGGER_FALLING|IRQF_DISABLED, "TDA IRQ", NULL)) {
<       printk(KERN_ERR "hdmicec:%s:Cannot request irq, err:%d\n",__func__,err);
<       gpio_free(TDA_IRQ_CALIB);
<       goto i2c_out;
<    }
< #endif
< 
<    err = hdmi_cec_init(this);
<    if (err) goto i2c_out;
<    this->cec.rx_addr=CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
< 
<    if (get_hpd_status()) {
<       cec_on(this);
<       disable_irq(gpio_to_irq(TDA_IRQ_CALIB));
<       cec_interrupt(NULL); /* initiate polling */
<       enable_irq(gpio_to_irq(TDA_IRQ_CALIB));
<    }
<    else {
<       cec_standby(this);
<    }
< 
<    return 0;
< 
<  i2c_out:
<    LOG(KERN_INFO,"HDMICEC eject: this->driver.i2c_client removed\n");
<    tmdlHdmiCecClose(this->cec.inst);
<    kfree(this->driver.i2c_client);
<    this->driver.i2c_client = NULL;
< 
<    return err;
< }
< 
< /*
<  *  I2C client :: destroy
<  */
< static int this_i2c_remove(struct i2c_client *client)
< {
<    cec_instance *this=&our_instance;
<    int err=0;
< 
<    LOG(KERN_INFO,"called\n");
< 
<    err=tmdlHdmiCecClose(this->cec.inst);
< 
<    if (!client->adapter) {
<       dev_err(&this->driver.i2c_client->dev, "<%s> No CEC Device \n",
<               __func__);
<       return -ENODEV;
<    }
<    kfree(this->driver.i2c_client);
<    this->driver.i2c_client = NULL;
< 
<    return err;
< }
< 
< /*
<  *  I2C client driver (backend)
<  *  -----------------
<  */
< static struct i2c_driver this_i2c_driver = {
<    .driver = {
<       .owner = THIS_MODULE,
<       .name = CEC_NAME,
<    },
<    .probe = this_i2c_probe,
<    .remove = this_i2c_remove,
<    .id_table = this_i2c_id,
< };
< 
< /*
<  *  ioctl driver (userland frontend)
<  *  ------------
<  */
< static struct file_operations this_cdev_fops = {
<  owner:    THIS_MODULE,
<  open:     this_cdev_open,
<  release:  this_cdev_release,
<  ioctl:    this_cdev_ioctl,
< };
< 
< /*
<  *  Module :: start up
<  */
< static int __init cec_init(void)
< {
<    cec_instance *this=&our_instance;
<    dev_t dev=0;
<    int err=0;
< 
<    /* 
<       general device context
<    */
<    memset(this,0,sizeof(cec_instance));
<    this->param.verbose = param_verbose;
<    this->param.major = param_major;
<    this->param.minor = param_minor;
< 
<    /* Hello word */
<    printk(KERN_INFO "%s(%s) %d.%d.%d compiled: %s %s %s\n", HDMICEC_NAME, TDA_NAME, TDA_VERSION_MAJOR,
<           TDA_VERSION_MINOR, TDA_VERSION_PATCHLEVEL, __DATE__, __TIME__, TDA_VERSION_EXTRA);
<    if (this->param.verbose) LOG(KERN_INFO,".verbose mode\n");
< 
<    /*
<      plug I2C (backend : Hw interfacing)
<    */
<    err = i2c_add_driver(&this_i2c_driver);
<    if (err < 0) {
<       printk(KERN_ERR "Driver registration failed\n");
<       return -ENODEV;
<    }
< 
<    if (this->driver.i2c_client == NULL) {
<       printk(KERN_ERR "this->driver.i2c_client not allocated\n");
<       err = -ENODEV;
<       goto init_out;
<    }
< 
<    /*
<      cdev init (userland frontend)
<    */
< 
<    /* arbitray range of device numbers */
<    if (this->param.major) {
<       /* user force major number @ insmod */
<       dev = MKDEV(this->param.major, this->param.minor);
<       err = register_chrdev_region(dev,MAX_MINOR,HDMICEC_NAME);
<       if (err) {
<          printk(KERN_ERR "unable to register %s, dev=%d %s\n",HDMICEC_NAME,dev,ERR_TO_STR(err));
<          goto init_out;
<       }
<    } else {
<       /* fully dynamic major number */
<       err = alloc_chrdev_region(&dev, this->param.minor, MAX_MINOR,HDMICEC_NAME);
<       if (err) {
<          printk(KERN_ERR "unable to alloc chrdev region for %s, dev=%d %s\n",HDMICEC_NAME,dev,ERR_TO_STR(err));
<          goto init_out;
<       }
<       this->param.major = MAJOR(dev);
<    }
< 
<    cdev_init(this_cdev, &this_cdev_fops);
<    this_cdev->owner = THIS_MODULE;
< 
<    this->driver.class = class_create(THIS_MODULE, HDMICEC_NAME);
<    if (IS_ERR(this->driver.class)) {
<       printk(KERN_INFO "Error creating mmap device class.\n");
<       err =-EIO;
<       goto init_out;
<    }
<    this->driver.dev = device_create(this->driver.class, NULL, dev, NULL, HDMICEC_NAME);
< 
<    this->driver.devno = dev;
<    err = cdev_add(this_cdev, this->driver.devno, MAX_MINOR);
<    if (err){
<       printk(KERN_INFO "unable to add device for %s, ipp_driver.devno=%d %s\n",HDMICEC_NAME,this->driver.devno,ERR_TO_STR(err));
<       device_destroy(this->driver.class,this->driver.devno);
<       class_destroy(this->driver.class);
<       unregister_chrdev_region(this->driver.devno, MAX_MINOR);
<       goto init_out;
<    }   
< 
< #ifdef TWL4030_HACK
<    /* AL : hack to bypass keypad */
<    gkp_input = get_twm4030_input();
< #endif
< 
<    /* 
<       general device context
<    */
<    init_MUTEX(&this->driver.sem);
<    this->driver.deinit_req=0;
<    
< #if 0
<    /* TEST START */
<    {
<       struct device *dev, *devn;
<       struct kset *dev_kset;
<       int cpt=0;
<       
<       dev_kset=this->driver.dev->kobj.kset;
<       list_for_each_entry_safe_reverse(dev, devn, &dev_kset->list, kobj.entry) {
<          cpt++;
<          if ((dev->bus_id[0] == 'h') \
<              && (dev->bus_id[1] == 'd') \
<              && (dev->bus_id[2] == 'm') \
<              && (dev->bus_id[3] == 'i'))
<             {
<                printk("DBG -%s-\n",dev->bus_id);
<             }
<       }
<       printk("DBG get %d devices\n",cpt);
<    }
<    /* TEST STOP */
<  #endif
< 
<    return 0;
< 
<  init_out:
<    i2c_del_driver(&this_i2c_driver);
<    return err;
< }
< 
< /*
<  *  Module :: shut down
<  */
< static void __exit cec_exit(void)
< {
<    cec_instance *this=&our_instance;
<    
<    LOG(KERN_INFO,"called\n");
<    
< #ifndef IRQ
<    free_irq(gpio_to_irq(TDA_IRQ_CALIB), NULL);
< #endif
<    
<    unregister_cec_interrupt();
<    this->driver.deinit_req=1;
< #ifndef IRQ
<    if (wait_event_interruptible(this->driver.wait,this->driver.deinit_req>1)) {
<       /* oups... just wait... */
<       msleep(CHECK_EVERY_XX_MS*20);
<    }
< #endif
<    
< #ifndef IRQ
<    /* release GPIO */ 
<    gpio_free(TDA_IRQ_CALIB);
< #endif
< 
<    /* unregister cdevice */
<    cdev_del(this_cdev);
<    unregister_chrdev_region(this->driver.devno, MAX_MINOR);
< 
<    /* unregister device */
<    device_destroy(this->driver.class,this->driver.devno);
<    class_destroy(this->driver.class);
< 
<    /* unregister i2c */
<    i2c_del_driver(&this_i2c_driver);
< 
< }
< 
< 
< /*
<  *  Module
<  *  ------
<  */
< /* late_initcall(cec_init); */
< module_init(cec_init);
< module_exit(cec_exit);
< 
< /*
<  *  Disclamer
<  *  ---------
<  */
< MODULE_LICENSE("GPL");
< MODULE_AUTHOR("Andre Lepine <andre.lepine@nxp.com>");
< MODULE_DESCRIPTION(HDMICEC_NAME " driver");
---
> /*****************************************************************************/
> /* Copyright (c) 2009 NXP Semiconductors BV                                  */
> /*                                                                           */
> /* This program is free software; you can redistribute it and/or modify      */
> /* it under the terms of the GNU General Public License as published by      */
> /* the Free Software Foundation, using version 2 of the License.             */
> /*                                                                           */
> /* This program is distributed in the hope that it will be useful,           */
> /* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
> /* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              */
> /* GNU General Public License for more details.                              */
> /*                                                                           */
> /* You should have received a copy of the GNU General Public License         */
> /* along with this program; if not, write to the Free Software               */
> /* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307       */
> /* USA.                                                                      */
> /*                                                                           */
> /*****************************************************************************/
> 
> #define _cec_c_
> 
> #include <linux/init.h>
> #include <linux/kernel.h>
> #include <linux/module.h>
> #include <linux/cdev.h>  
> #include <linux/fs.h>
> #include <linux/ioctl.h>
> #include <linux/i2c.h>
> #include <linux/delay.h>
> #include <linux/interrupt.h>
> #include <linux/input.h>
> #include <asm/uaccess.h>
> #include <mach/gpio.h>
> 
> /* HDMI DevLib */
> #include "tmNxCompId.h"
> #include "tmdlHdmiCEC.h"
> #include "tmdlHdmiCEC_local.h"
> 
> /* local */
> #include "tda998x_version.h"
> #include "tda998x_cec.h"
> #include "tda998x_ioctl.h"
> 
> /*
>  *
>  * DEFINITION
>  * ----------
>  * LEVEL 0
>  *
>  */
> 
> /*
>  *  Global
>  */
> 
> MODULE_DEVICE_TABLE(i2c, this_i2c_id);
> static const struct i2c_device_id this_i2c_id[] = {
>    { CEC_NAME, 0 },
>    { },
> };
> cec_instance our_instance;
> static struct cdev our_cdev, *this_cdev=&our_cdev;
> 
> #ifdef TWL4030_HACK
> /* AL : hack to bypass keypad */
> struct input_dev *gkp_input;
> extern struct input_dev *get_twm4030_input(void);
> #endif
> 
> /*
>  * Dependancies to HdmiTx module
>  */
> 
> extern void register_cec_interrupt(cec_callback_t fct); 
> extern void unregister_cec_interrupt(void); 
> extern short edid_phy_addr(void); 
> extern int hdmi_enable(void);
> extern int hdmi_disable(int event_tracking);
> extern cec_power get_hdmi_status(void);
> extern cec_power get_hpd_status(void);
> extern int edid_received(void);
> 
> /*
>  *  Module params
>  */
> 
> static int param_verbose=0,param_major=0,param_minor=0,param_device=4,param_addr=0xFFFF;
> module_param_named(verbose,param_verbose,int,S_IRUGO | S_IWUSR);
> MODULE_PARM_DESC(verbose, "Make the driver verbose");
> module_param_named(major, param_major, int, S_IRUGO);
> MODULE_PARM_DESC(major, "The major number of the device mapper");
> module_param_named(device, param_device, int, S_IRUGO);
> MODULE_PARM_DESC(device, "Device type can be 0:tv, 1:rec 3:tuner 4:mediaplayer, 5:audio");
> module_param_named(addr, param_addr, int, S_IRUGO);
> MODULE_PARM_DESC(addr, "Physical address (until EDID received)");
> 
> /*
>  *
>  * TOOLBOX
>  * -------
>  * LEVEL 1
>  *
>  * - i2c read/write
>  * - chip Id check
>  * - i2c client info
>  * 
>  */
> 
> 
> /* 
>  *  Get main and unique I2C Client driver handle
>  */
> struct i2c_client *GetThisI2cClient(void)
> {
>    cec_instance *this=&our_instance;
>    return this->driver.i2c_client;
> }
> 
> /*
>  * error handling
>  */
> static char *hdmi_cec_err_string(int err)
> {
>    switch (err)
>       {
>       case TMDL_ERR_DLHDMICEC_COMPATIBILITY: {return "SW Interface compatibility";break;}
>       case TMDL_ERR_DLHDMICEC_MAJOR_VERSION: {return "SW Major Version error";break;}
>       case TMDL_ERR_DLHDMICEC_COMP_VERSION: {return "SW component version error";break;}
>       case TMDL_ERR_DLHDMICEC_BAD_UNIT_NUMBER: {return "Invalid device unit number";break;}
>       case TMDL_ERR_DLHDMICEC_BAD_INSTANCE: {return "Bad input instance value  ";break;}
>       case TMDL_ERR_DLHDMICEC_BAD_HANDLE: {return "Bad input handle";break;}
>       case TMDL_ERR_DLHDMICEC_BAD_PARAMETER: {return "Invalid input parameter";break;}
>       case TMDL_ERR_DLHDMICEC_NO_RESOURCES: {return "Resource is not available ";break;}
>       case TMDL_ERR_DLHDMICEC_RESOURCE_OWNED: {return "Resource is already in use";break;}
>       case TMDL_ERR_DLHDMICEC_RESOURCE_NOT_OWNED: {return "Caller does not own resource";break;}
>       case TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS: {return "Inconsistent input params";break;}
>       case TMDL_ERR_DLHDMICEC_NOT_INITIALIZED: {return "Component is not initializ";break;}
>       case TMDL_ERR_DLHDMICEC_NOT_SUPPORTED: {return "Function is not supported";break;}
>       case TMDL_ERR_DLHDMICEC_INIT_FAILED: {return "Initialization failed";break;}
>       case TMDL_ERR_DLHDMICEC_BUSY: {return "Component is busy";break;}
>       case TMDL_ERR_DLHDMICEC_I2C_READ: {return "Read error";break;}
>       case TMDL_ERR_DLHDMICEC_I2C_WRITE: {return "Write error";break;}
>       case TMDL_ERR_DLHDMICEC_FULL: {return "Queue is full";break;}
>       case TMDL_ERR_DLHDMICEC_NOT_STARTED: {return "Function is not started";break;}
>       case TMDL_ERR_DLHDMICEC_ALREADY_STARTED: {return "Function is already starte";break;}
>       case TMDL_ERR_DLHDMICEC_ASSERTION: {return "Assertion failure";break;}
>       case TMDL_ERR_DLHDMICEC_INVALID_STATE: {return "Invalid state for function";break;}
>       case TMDL_ERR_DLHDMICEC_OPERATION_NOT_PERMITTED: {return "Corresponds to posix EPERM";break;}
>       default : {return "Unexpected error";break;}
>       }
> }
> 
> char *cec_opcode(int op)
> {
>    switch (op)
>       {
>       case CEC_OPCODE_FEATURE_ABORT: {return "CEC_OPCODE_FEATURE_ABORT";break;}
>       case CEC_OPCODE_IMAGE_VIEW_ON: {return "CEC_OPCODE_IMAGE_VIEW_ON";break;}
>       case CEC_OPCODE_TUNER_STEP_INCREMENT: {return "CEC_OPCODE_TUNER_STEP_INCREMENT";break;}
>       case CEC_OPCODE_TUNER_STEP_DECREMENT: {return "CEC_OPCODE_TUNER_STEP_DECREMENT";break;}
>       case CEC_OPCODE_TUNER_DEVICE_STATUS: {return "CEC_OPCODE_TUNER_DEVICE_STATUS";break;}
>       case CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS: {return "CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS";break;}
>       case CEC_OPCODE_RECORD_ON: {return "CEC_OPCODE_RECORD_ON";break;}
>       case CEC_OPCODE_RECORD_STATUS: {return "CEC_OPCODE_RECORD_STATUS";break;}
>       case CEC_OPCODE_RECORD_OFF: {return "CEC_OPCODE_RECORD_OFF";break;}
>       case CEC_OPCODE_TEXT_VIEW_ON: {return "CEC_OPCODE_TEXT_VIEW_ON";break;}
>       case CEC_OPCODE_RECORD_TV_SCREEN: {return "CEC_OPCODE_RECORD_TV_SCREEN";break;}
>       case CEC_OPCODE_GIVE_DECK_STATUS: {return "CEC_OPCODE_GIVE_DECK_STATUS";break;}
>       case CEC_OPCODE_DECK_STATUS: {return "CEC_OPCODE_DECK_STATUS";break;}
>       case CEC_OPCODE_SET_MENU_LANGUAGE: {return "CEC_OPCODE_SET_MENU_LANGUAGE";break;}
>       case CEC_OPCODE_CLEAR_ANALOGUE_TIMER: {return "CEC_OPCODE_CLEAR_ANALOGUE_TIMER";break;}
>       case CEC_OPCODE_SET_ANALOGUE_TIMER: {return "CEC_OPCODE_SET_ANALOGUE_TIMER";break;}
>       case CEC_OPCODE_TIMER_STATUS: {return "CEC_OPCODE_TIMER_STATUS";break;}
>       case CEC_OPCODE_STANDBY: {return "CEC_OPCODE_STANDBY";break;}
>       case CEC_OPCODE_PLAY: {return "CEC_OPCODE_PLAY";break;}
> /*       case CEC_OPCODE_DECK_CONTROL: {return "CEC_OPCODE_DECK_CONTROL";break;} */
>       case CEC_OPCODE_TIMER_CLEARED_STATUS: {return "CEC_OPCODE_TIMER_CLEARED_STATUS";break;}
>       case CEC_OPCODE_USER_CONTROL_PRESSED: {return "CEC_OPCODE_USER_CONTROL_PRESSED";break;}
>       case CEC_OPCODE_USER_CONTROL_RELEASED: {return "CEC_OPCODE_USER_CONTROL_RELEASED";break;}
>       case CEC_OPCODE_GIVE_OSD_NAME: {return "CEC_OPCODE_GIVE_OSD_NAME";break;}
>       case CEC_OPCODE_SET_OSD_NAME: {return "CEC_OPCODE_SET_OSD_NAME";break;}
>       case CEC_OPCODE_SET_OSD_STRING: {return "CEC_OPCODE_SET_OSD_STRING";break;}
>       case CEC_OPCODE_SET_TIMER_PROGRAM_TITLE: {return "CEC_OPCODE_SET_TIMER_PROGRAM_TITLE";break;}
>       case CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST: {return "CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST";break;}
>       case CEC_OPCODE_GIVE_AUDIO_STATUS: {return "CEC_OPCODE_GIVE_AUDIO_STATUS";break;}
>       case CEC_OPCODE_SET_SYSTEM_AUDIO_MODE: {return "CEC_OPCODE_SET_SYSTEM_AUDIO_MODE";break;}
>       case CEC_OPCODE_REPORT_AUDIO_STATUS: {return "CEC_OPCODE_REPORT_AUDIO_STATUS";break;}
>       case CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS: {return "CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS";break;}
>       case CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS: {return "CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS";break;}
>       case CEC_OPCODE_ROUTING_CHANGE: {return "CEC_OPCODE_ROUTING_CHANGE";break;}
>       case CEC_OPCODE_ROUTING_INFORMATION: {return "CEC_OPCODE_ROUTING_INFORMATION";break;}
>       case CEC_OPCODE_ACTIVE_SOURCE: {return "CEC_OPCODE_ACTIVE_SOURCE";break;}
>       case CEC_OPCODE_GIVE_PHYSICAL_ADDRESS: {return "CEC_OPCODE_GIVE_PHYSICAL_ADDRESS";break;}
>       case CEC_OPCODE_REPORT_PHYSICAL_ADDRESS: {return "CEC_OPCODE_REPORT_PHYSICAL_ADDRESS";break;}
>       case CEC_OPCODE_REQUEST_ACTIVE_SOURCE: {return "CEC_OPCODE_REQUEST_ACTIVE_SOURCE";break;}
>       case CEC_OPCODE_SET_STREAM_PATH: {return "CEC_OPCODE_SET_STREAM_PATH";break;}
>       case CEC_OPCODE_DEVICE_VENDOR_ID: {return "CEC_OPCODE_DEVICE_VENDOR_ID";break;}
>       case CEC_OPCODE_VENDOR_COMMAND: {return "CEC_OPCODE_VENDOR_COMMAND";break;}
>       case CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN: {return "CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN";break;}
>       case CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP: {return "CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP";break;}
>       case CEC_OPCODE_GIVE_DEVICE_VENDOR_ID: {return "CEC_OPCODE_GIVE_DEVICE_VENDOR_ID";break;}
>       case CEC_OPCODE_MENU_REQUEST: {return "CEC_OPCODE_MENU_REQUEST";break;}
>       case CEC_OPCODE_MENU_STATUS: {return "CEC_OPCODE_MENU_STATUS";break;}
>       case CEC_OPCODE_GIVE_DEVICE_POWER_STATUS: {return "CEC_OPCODE_GIVE_DEVICE_POWER_STATUS";break;}
>       case CEC_OPCODE_REPORT_POWER_STATUS: {return "CEC_OPCODE_REPORT_POWER_STATUS";break;}
>       case CEC_OPCODE_GET_MENU_LANGUAGE: {return "CEC_OPCODE_GET_MENU_LANGUAGE";break;}
>       case CEC_OPCODE_SET_ANALOGUE_SERVICE: {return "CEC_OPCODE_SET_ANALOGUE_SERVICE";break;}
>       case CEC_OPCODE_SET_DIGITAL_SERVICE: {return "CEC_OPCODE_SET_DIGITAL_SERVICE";break;}
>       case CEC_OPCODE_SET_DIGITAL_TIMER: {return "CEC_OPCODE_SET_DIGITAL_TIMER";break;}
>       case CEC_OPCODE_CLEAR_DIGITAL_TIMER: {return "CEC_OPCODE_CLEAR_DIGITAL_TIMER";break;}
>       case CEC_OPCODE_SET_AUDIO_RATE: {return "CEC_OPCODE_SET_AUDIO_RATE";break;}
>       case CEC_OPCODE_INACTIVE_SOURCE: {return "CEC_OPCODE_INACTIVE_SOURCE";break;}
>       case CEC_OPCODE_CEC_VERSION: {return "CEC_OPCODE_CEC_VERSION";break;}
>       case CEC_OPCODE_GET_CEC_VERSION: {return "CEC_OPCODE_GET_CEC_VERSION";break;}
>       case CEC_OPCODE_VENDOR_COMMAND_WITH_ID: {return "CEC_OPCODE_VENDOR_COMMAND_WITH_ID";break;}
>       case CEC_OPCODE_CLEAR_EXTERNAL_TIMER: {return "CEC_OPCODE_CLEAR_EXTERNAL_TIMER";break;}
>       case CEC_OPCODE_SET_EXTERNAL_TIMER: {return "CEC_OPCODE_SET_EXTERNAL_TIMER";break;}
>       case CEC_OPCODE_ABORT_MESSAGE: {return "CEC_OPCODE_ABORT_MESSAGE";break;}
>       default : {return "unknown";break;}
>       }
> }
> 
> 
> static char *cec_ioctl(int io)
> {
>    switch (io)
>       {
>       case CEC_VERBOSE_ON_CMD: {return "CEC_VERBOSE_ON_CMD";break;}
>       case CEC_VERBOSE_OFF_CMD: {return "CEC_VERBOSE_OFF_CMD";break;}
>       case CEC_BYEBYE_CMD: {return "CEC_BYEBYE_CMD";break;}
>       case CEC_IOCTL_RX_ADDR_CMD: {return "CEC_IOCTL_RX_ADDR_CMD";break;}
>       case CEC_IOCTL_PHY_ADDR_CMD: {return "CEC_IOCTL_PHY_ADDR_CMD";break;}
>       case CEC_IOCTL_WAIT_FRAME_CMD: {return "CEC_IOCTL_WAIT_FRAME_CMD";break;}
>       case CEC_IOCTL_ABORT_MSG_CMD: {return "CEC_IOCTL_ABORT_MSG_CMD";break;}
>       case CEC_IOCTL_ACTIVE_SRC_CMD: {return "CEC_IOCTL_ACTIVE_SRC_CMD";break;}
>       case CEC_IOCTL_VERSION_CMD: {return "CEC_IOCTL_VERSION_CMD";break;}
>       case CEC_IOCTL_CLEAR_ANALOGUE_TIMER_CMD: {return "CEC_IOCTL_CLEAR_ANALOGUE_TIMER_CMD";break;}
>       case CEC_IOCTL_CLEAR_DIGITAL_TIMER_CMD: {return "CEC_IOCTL_CLEAR_DIGITAL_TIMER_CMD";break;}
>       case CEC_IOCTL_CLEAR_EXT_TIMER_WITH_EXT_PLUG_CMD: {return "CEC_IOCTL_CLEAR_EXT_TIMER_WITH_EXT_PLUG_CMD";break;}
>       case CEC_IOCTL_CLEAR_EXT_TIMER_WITH_PHY_ADDR_CMD: {return "CEC_IOCTL_CLEAR_EXT_TIMER_WITH_PHY_ADDR_CMD";break;}
>       case CEC_IOCTL_DECK_CTRL_CMD: {return "CEC_IOCTL_DECK_CTRL_CMD";break;}
>       case CEC_IOCTL_DECK_STATUS_CMD: {return "CEC_IOCTL_DECK_STATUS_CMD";break;}
>       case CEC_IOCTL_DEVICE_VENDOR_ID_CMD: {return "CEC_IOCTL_DEVICE_VENDOR_ID_CMD";break;}
>       case CEC_IOCTL_FEATURE_ABORT_CMD: {return "CEC_IOCTL_FEATURE_ABORT_CMD";break;}
>       case CEC_IOCTL_GET_CEC_VERSION_CMD: {return "CEC_IOCTL_GET_CEC_VERSION_CMD";break;}
>       case CEC_IOCTL_GET_MENU_LANGUAGE_CMD: {return "CEC_IOCTL_GET_MENU_LANGUAGE_CMD";break;}
>       case CEC_IOCTL_GIVE_AUDIO_STATUS_CMD: {return "CEC_IOCTL_GIVE_AUDIO_STATUS_CMD";break;}
>       case CEC_IOCTL_GIVE_DECK_STATUS_CMD: {return "CEC_IOCTL_GIVE_DECK_STATUS_CMD";break;}
>       case CEC_IOCTL_GIVE_DEVICE_POWER_STATUS_CMD: {return "CEC_IOCTL_GIVE_DEVICE_POWER_STATUS_CMD";break;}
>       case CEC_IOCTL_GIVE_DEVICE_VENDOR_ID_CMD: {return "CEC_IOCTL_GIVE_DEVICE_VENDOR_ID_CMD";break;}
>       case CEC_IOCTL_GIVE_OSD_NAME_CMD: {return "CEC_IOCTL_GIVE_OSD_NAME_CMD";break;}
>       case CEC_IOCTL_GIVE_PHY_ADDR_CMD: {return "CEC_IOCTL_GIVE_PHY_ADDR_CMD";break;}
>       case CEC_IOCTL_GIVE_SYS_AUDIO_MODE_STATUS_CMD: {return "CEC_IOCTL_GIVE_SYS_AUDIO_MODE_STATUS_CMD";break;}
>       case CEC_IOCTL_GIVE_TUNER_DEVICE_STATUS_CMD: {return "CEC_IOCTL_GIVE_TUNER_DEVICE_STATUS_CMD";break;}
>       case CEC_IOCTL_IMAGE_VIEW_ON_CMD: {return "CEC_IOCTL_IMAGE_VIEW_ON_CMD";break;}
>       case CEC_IOCTL_INACTIVE_SRC_CMD: {return "CEC_IOCTL_INACTIVE_SRC_CMD";break;}
>       case CEC_IOCTL_MENU_REQUEST_CMD: {return "CEC_IOCTL_MENU_REQUEST_CMD";break;}
>       case CEC_IOCTL_MENU_STATUS_CMD: {return "CEC_IOCTL_MENU_STATUS_CMD";break;}
>       case CEC_IOCTL_PLAY_CMD: {return "CEC_IOCTL_PLAY_CMD";break;}
>       case CEC_IOCTL_POLLING_MSG_CMD: {return "CEC_IOCTL_POLLING_MSG_CMD";break;}
>       case CEC_IOCTL_REC_OFF_CMD: {return "CEC_IOCTL_REC_OFF_CMD";break;}
>       case CEC_IOCTL_REC_ON_ANALOGUE_SERVICE_CMD: {return "CEC_IOCTL_REC_ON_ANALOGUE_SERVICE_CMD";break;}
>       case CEC_IOCTL_REC_ON_DIGITAL_SERVICE_CMD: {return "CEC_IOCTL_REC_ON_DIGITAL_SERVICE_CMD";break;}
>       case CEC_IOCTL_REC_ON_EXT_PHY_ADDR_CMD: {return "CEC_IOCTL_REC_ON_EXT_PHY_ADDR_CMD";break;}
>       case CEC_IOCTL_REC_ON_EXT_PLUG_CMD: {return "CEC_IOCTL_REC_ON_EXT_PLUG_CMD";break;}
>       case CEC_IOCTL_REC_ON_OWN_SRC_CMD: {return "CEC_IOCTL_REC_ON_OWN_SRC_CMD";break;}
>       case CEC_IOCTL_REC_STATUS_CMD: {return "CEC_IOCTL_REC_STATUS_CMD";break;}
>       case CEC_IOCTL_REC_TV_SCREEN_CMD: {return "CEC_IOCTL_REC_TV_SCREEN_CMD";break;}
>       case CEC_IOCTL_REPORT_AUDIO_STATUS_CMD: {return "CEC_IOCTL_REPORT_AUDIO_STATUS_CMD";break;}
>       case CEC_IOCTL_REPORT_PHY_ADDR_CMD: {return "CEC_IOCTL_REPORT_PHY_ADDR_CMD";break;}
>       case CEC_IOCTL_REPORT_POWER_STATUS_CMD: {return "CEC_IOCTL_REPORT_POWER_STATUS_CMD";break;}
>       case CEC_IOCTL_REQUEST_ACTIVE_SRC_CMD: {return "CEC_IOCTL_REQUEST_ACTIVE_SRC_CMD";break;}
>       case CEC_IOCTL_ROUTING_CHANGE_CMD: {return "CEC_IOCTL_ROUTING_CHANGE_CMD";break;}
>       case CEC_IOCTL_ROUTING_INFORMATION_CMD: {return "CEC_IOCTL_ROUTING_INFORMATION_CMD";break;}
>       case CEC_IOCTL_SELECT_ANALOGUE_SERVICE_CMD: {return "CEC_IOCTL_SELECT_ANALOGUE_SERVICE_CMD";break;}
>       case CEC_IOCTL_SELECT_DIGITAL_SERVICE_CMD: {return "CEC_IOCTL_SELECT_DIGITAL_SERVICE_CMD";break;}
>       case CEC_IOCTL_SET_ANALOGUE_TIMER_CMD: {return "CEC_IOCTL_SET_ANALOGUE_TIMER_CMD";break;}
>       case CEC_IOCTL_SET_AUDIO_RATE_CMD: {return "CEC_IOCTL_SET_AUDIO_RATE_CMD";break;}
>       case CEC_IOCTL_SET_DIGITAL_TIMER_CMD: {return "CEC_IOCTL_SET_DIGITAL_TIMER_CMD";break;}
>       case CEC_IOCTL_SET_EXT_TIMER_WITH_EXT_PLUG_CMD: {return "CEC_IOCTL_SET_EXT_TIMER_WITH_EXT_PLUG_CMD";break;}
>       case CEC_IOCTL_SET_EXT_TIMER_WITH_PHY_ADDR_CMD: {return "CEC_IOCTL_SET_EXT_TIMER_WITH_PHY_ADDR_CMD";break;}
>       case CEC_IOCTL_SET_MENU_LANGUAGE_CMD: {return "CEC_IOCTL_SET_MENU_LANGUAGE_CMD";break;}
>       case CEC_IOCTL_SET_OSD_NAME_CMD: {return "CEC_IOCTL_SET_OSD_NAME_CMD";break;}
>       case CEC_IOCTL_SET_OSD_STRING_CMD: {return "CEC_IOCTL_SET_OSD_STRING_CMD";break;}
>       case CEC_IOCTL_SET_STREAM_PATH_CMD: {return "CEC_IOCTL_SET_STREAM_PATH_CMD";break;}
>       case CEC_IOCTL_SET_SYS_AUDIO_MODE_CMD: {return "CEC_IOCTL_SET_SYS_AUDIO_MODE_CMD";break;}
>       case CEC_IOCTL_SET_TIMER_PROGRAM_TITLE_CMD: {return "CEC_IOCTL_SET_TIMER_PROGRAM_TITLE_CMD";break;}
>       case CEC_IOCTL_STANDBY_CMD: {return "CEC_IOCTL_STANDBY_CMD";break;}
>       case CEC_IOCTL_SYS_AUDIO_MODE_REQUEST_CMD: {return "CEC_IOCTL_SYS_AUDIO_MODE_REQUEST_CMD";break;}
>       case CEC_IOCTL_SYS_AUDIO_MODE_STATUS_CMD: {return "CEC_IOCTL_SYS_AUDIO_MODE_STATUS_CMD";break;}
>       case CEC_IOCTL_TEXT_VIEW_ON_CMD: {return "CEC_IOCTL_TEXT_VIEW_ON_CMD";break;}
>       case CEC_IOCTL_TIMER_CLEARED_STATUS_CMD: {return "CEC_IOCTL_TIMER_CLEARED_STATUS_CMD";break;}
>       case CEC_IOCTL_TIMER_STATUS_CMD: {return "CEC_IOCTL_TIMER_STATUS_CMD";break;}
>       case CEC_IOCTL_TUNER_DEVICE_STATUS_ANALOGUE_CMD: {return "CEC_IOCTL_TUNER_DEVICE_STATUS_ANALOGUE_CMD";break;}
>       case CEC_IOCTL_TUNER_DEVICE_STATUS_DIGITAL_CMD: {return "CEC_IOCTL_TUNER_DEVICE_STATUS_DIGITAL_CMD";break;}
>       case CEC_IOCTL_TUNER_STEP_DECREMENT_CMD: {return "CEC_IOCTL_TUNER_STEP_DECREMENT_CMD";break;}
>       case CEC_IOCTL_TUNER_STEP_INCREMENT_CMD: {return "CEC_IOCTL_TUNER_STEP_INCREMENT_CMD";break;}
>       case CEC_IOCTL_USER_CTRL_CMD: {return "CEC_IOCTL_USER_CTRL_CMD";break;}
>       case CEC_IOCTL_USER_CTRL_PLAY_CMD: {return "CEC_IOCTL_USER_CTRL_PLAY_CMD";break;}
>       case CEC_IOCTL_USER_CTRL_SELECT_AUDIOINPUT_CMD: {return "CEC_IOCTL_USER_CTRL_SELECT_AUDIOINPUT_CMD";break;}
>       case CEC_IOCTL_USER_CTRL_SELECT_AVINPUT_CMD: {return "CEC_IOCTL_USER_CTRL_SELECT_AVINPUT_CMD";break;}
>       case CEC_IOCTL_USER_CTRL_SELECT_MEDIA_CMD: {return "CEC_IOCTL_USER_CTRL_SELECT_MEDIA_CMD";break;}
>       case CEC_IOCTL_USER_CTRL_TUNE_CMD: {return "CEC_IOCTL_USER_CTRL_TUNE_CMD";break;}
>       case CEC_IOCTL_USER_CTRL_RELEASED_CMD: {return "CEC_IOCTL_USER_CTRL_RELEASED_CMD";break;}
>       case CEC_IOCTL_VENDOR_COMMAND_CMD: {return "CEC_IOCTL_VENDOR_COMMAND_CMD";break;}
>       case CEC_IOCTL_VENDOR_COMMAND_WITH_ID_CMD: {return "CEC_IOCTL_VENDOR_COMMAND_WITH_ID_CMD";break;}
>       case CEC_IOCTL_VENDOR_REMOTE_BUTTON_DOWN_CMD: {return "CEC_IOCTL_VENDOR_REMOTE_BUTTON_DOWN_CMD";break;}
>       case CEC_IOCTL_VENDOR_REMOTE_BUTTON_UP_CMD: {return "CEC_IOCTL_VENDOR_REMOTE_BUTTON_UP_CMD";break;}
>       case CEC_IOCTL_GET_SW_VERSION_CMD: {return "CEC_IOCTL_GET_SW_VERSION_CMD";break;}
>       case CEC_IOCTL_SET_POWER_STATE_CMD: {return "CEC_IOCTL_SET_POWER_STATE_CMD";break;}
>       case CEC_IOCTL_GET_POWER_STATE_CMD: {return "CEC_IOCTL_GET_POWER_STATE_CMD";break;}
>       case CEC_IOCTL_INSTANCE_CONFIG_CMD: {return "CEC_IOCTL_INSTANCE_CONFIG_CMD";break;}
>       case CEC_IOCTL_INSTANCE_SETUP_CMD: {return "CEC_IOCTL_INSTANCE_SETUP_CMD";break;}
>       case CEC_IOCTL_GET_INSTANCE_SETUP_CMD: {return "CEC_IOCTL_GET_INSTANCE_SETUP_CMD";break;}
>       case CEC_IOCTL_ENABLE_EVENT_CMD: {return "CEC_IOCTL_ENABLE_EVENT_CMD";break;}
>       case CEC_IOCTL_DISABLE_EVENT_CMD: {return "CEC_IOCTL_DISABLE_EVENT_CMD";break;}
>       case CEC_IOCTL_ENABLE_CALIBRATION_CMD: {return "CEC_IOCTL_ENABLE_CALIBRATION_CMD";break;}
>       case CEC_IOCTL_DISABLE_CALIBRATION_CMD: {return "CEC_IOCTL_DISABLE_CALIBRATION_CMD";break;}
>       case CEC_IOCTL_SEND_MSG_CMD: {return "CEC_IOCTL_SEND_MSG_CMD";break;}
>       case CEC_IOCTL_SET_REGISTER_CMD: {return "CEC_IOCTL_SET_REGISTER_CMD";break;}
>       default : {return "unknown";break;}
>       }
> }
> 
> 
> static char *cec_rxstatus(int s)
> {
>    switch (s)
>       {
>       case CEC_MSG_SUCCESS :{return "success";break;}
>       case CEC_MSG_FAIL_DATA_NOT_ACK :{return "data not ack";break;}
>       case CEC_CSP_OFF_STATE :{return "CSP off";break;}
>       case CEC_BAD_REQ_SERVICE :{return "bad Req";break;}
>       case CEC_MSG_FAIL_UNABLE_TO_ACCESS :{return "CEC line error";break;}
>       case CEC_MSG_FAIL_ARBITRATION_ERROR :{return "arb error";break;}
>       case CEC_MSG_FAIL_BIT_TIMMING_ERROR :{return "bit error";break;}
>       case CEC_MSG_FAIL_DEST_NOT_ACK :{return "destination not ack";break;}
>       default : {return "unknown";break;}
>       }
> }
> 
> 
> static unsigned char get_next_logical_addr(cec_device_type device,unsigned char la)
> {
>    switch (device) {
>    case CEC_DEVICE_TYPE_TV:
>       switch (la) {
>       case CEC_LOGICAL_ADDRESS_TV:
>          return CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
>       default:
>          return CEC_LOGICAL_ADDRESS_TV;
>       }
>    case CEC_DEVICE_TYPE_REC_DEVICE:
>       switch (la) {
>       case CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_1:
>          return CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_2;
>       case CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_2:
>          return CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_3;
>       case CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_3:
>          return CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
>       default:
>          return CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_1;
>       }
>    case CEC_DEVICE_TYPE_TUNER:
>       switch (la) {
>       case CEC_LOGICAL_ADDRESS_TUNER_1:
>          return CEC_LOGICAL_ADDRESS_TUNER_2;
>       case CEC_LOGICAL_ADDRESS_TUNER_2:
>          return CEC_LOGICAL_ADDRESS_TUNER_3;
>       case CEC_LOGICAL_ADDRESS_TUNER_3:
>          return CEC_LOGICAL_ADDRESS_TUNER_4;
>       case CEC_LOGICAL_ADDRESS_TUNER_4:
>          return CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
>       default:
>          return CEC_LOGICAL_ADDRESS_TUNER_1;
>       }
>    case CEC_DEVICE_TYPE_PLAYBACK_DEVICE:
>       switch (la) {
>       case CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_1:
>          return CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_2;
>       case CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_2:
>          return CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_3;
>       case CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_3:
>          return CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
>       default:
>          return CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_1;
>       }
>    case CEC_DEVICE_TYPE_AUDIO_DEVICE: 
>       switch (la) {
>       case CEC_LOGICAL_ADDRESS_AUDIO_SYSTEM:
>          return CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
>       default:
>          return CEC_LOGICAL_ADDRESS_AUDIO_SYSTEM;
>       }
>    default:
>       return CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
>    }
> }
> 
> static int device_type(int type)
> {
>    printk(KERN_INFO "hdmicec declared as a ");
>    switch (type) {
>    case CEC_DEVICE_TYPE_TV: 
>       printk("TV");
>       break;
>    case CEC_DEVICE_TYPE_REC_DEVICE: 
>       printk("record");
>       break;
>    case CEC_DEVICE_TYPE_TUNER: 
>       printk("tuner");
>       break;
>    case CEC_DEVICE_TYPE_PLAYBACK_DEVICE: 
>       printk("playback");
>       break;
>    case CEC_DEVICE_TYPE_AUDIO_DEVICE: 
>       printk("audio");
>       break;
>    default: 
>       printk("default (playback)");
>       type = CEC_DEVICE_TYPE_PLAYBACK_DEVICE;
>       break;
>    }
>    printk(" device type\n");
>    return type;
> }
> 
> 
> /*
>  *
>  * PROCESSING
>  * ----------
>  * LEVEL 2
>  *
>  */
> 
> 
> /*
>  *  CEC Power On
>  */
> static void cec_on(cec_instance *this)
> {
>    int err;
>    struct task_struct *tsk = current;
> 
>    disable_irq(gpio_to_irq(TDA_IRQ_CALIB));
> 
>    this->cec.power = tmPowerOn;
>    TRY(tmdlHdmiCecSetPowerState(this->cec.inst,this->cec.power));
> 
>    /* turn GPIO into calib pulse generator */
>    gpio_direction_output(TDA_IRQ_CALIB,0); /* output (1 means try-state or high) */
>    //[jaeseong.gim] __->eli
>    gpio_set_value(TDA_IRQ_CALIB,1);
>    this->cec.clock = TMDL_HDMICEC_CLOCK_FRO;
>    TRY(tmdlHdmiCecEnableCalibration(this->cec.inst,this->cec.clock));
>    msleep(10);
>    set_current_state(TASK_UNINTERRUPTIBLE);
> 
>    /* CAUTION : TDA needs a real 10ms pulse */
>    cpu_relax();
>    spin_lock_irq(&tsk->sighand->siglock);
>    //[jaeseong.gim] __->eli
>    gpio_set_value(TDA_IRQ_CALIB,0);
>    __udelay(10000);
>    //[jaeseong.gim] __->eli
>    gpio_set_value(TDA_IRQ_CALIB,1);
>    spin_unlock_irq(&tsk->sighand->siglock);
> 
>    msleep(10);
>    TRY(tmdlHdmiCecDisableCalibration(this->cec.inst));
> 
>    /* setup */ 
>    TRY(tmdlHdmiCecGetInstanceSetup(this->cec.inst,&this->cec.setup));
>    this->cec.setup.DeviceLogicalAddress = this->cec.rx_addr;
>    this->cec.clock = TMDL_HDMICEC_CLOCK_FRO;
>    this->cec.setup.cecClockSource = this->cec.clock;
>    TRY(tmdlHdmiCecInstanceSetup(this->cec.inst,&this->cec.setup));
> 
>    /* turn GPIO into IRQ */
>    gpio_direction_input(TDA_IRQ_CALIB);
>    enable_irq(gpio_to_irq(TDA_IRQ_CALIB));
> 
>    LOG(KERN_INFO,"standby --> on\n");
> 
>  TRY_DONE:
>    (void)0;
> }
> 
> /*
>  *  CEC Power Off
>  */
> static void cec_standby(cec_instance *this)
> {
>    int err;
> 
>    this->cec.power = tmPowerStandby;
>    TRY(tmdlHdmiCecSetPowerState(this->cec.inst,this->cec.power));
>    
>    LOG(KERN_INFO,"on --> standby\n");
> 
>  TRY_DONE:
>    (void)0;
> }
> 
> /*
>  *  CEC interrupt polling
>  */
> static void cec_interrupt(struct work_struct *dummy)
> {
>    cec_instance *this=&our_instance;
>    unsigned short new_phy_addr=edid_phy_addr();
>    int err=0;
>    
>    LOG(KERN_INFO,"%s called\n",__func__);
> 
>    /* switch on/off CEC */
>    if (!get_hpd_status() &&                     \
>        (this->cec.power == tmPowerOn)) {
>       this->cec.source_status = CEC_POWER_STATUS_STANDBY;
> /*       TRY(tmdlHdmiCecInactiveSource(this->cec.inst,             \ */
> /*                                        this->cec.initiator,     \ */
> /*                                        this->cec.phy_addr)); */
>       cec_standby(this);
>    }
>    else if (get_hpd_status() &&                         \
>             (this->cec.power == tmPowerStandby)) {
>       /* send active msg when hdmi has been abled */
>       cec_on(this);
>    }
>    /* new phy addr means new EDID, mean HPD ! */
>    else if ((this->cec.phy_addr != new_phy_addr) &&        \
>        (this->cec.source_status == CEC_POWER_STATUS_ON)) {
>       LOG(KERN_INFO,"New physical address %02x\n",new_phy_addr);
>       this->cec.phy_addr = new_phy_addr;
>       if (this->cec.phy_addr != 0xFFFF) {
>          this->cec.rx_addr = get_next_logical_addr(this->cec.device_type,CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST);
>          TRY(tmdlHdmiCecPollingMessage(this->cec.inst,this->cec.rx_addr));
>       }
>       else {
>          this->cec.rx_addr = CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
>       }
>    }
> #ifdef GUI_OVER_HDMI
>    else if (edid_received()) { /* Check me */
>       if (this->cec.source_status == CEC_POWER_STATUS_STANDBY) {
>          /* only for GFX on HDMI, do not use if only video playback on HDMI */
>          TRY(tmdlHdmiCecImageViewOn(this->cec.inst,this->cec.initiator));
>          TRY(tmdlHdmiCecHandleInterrupt(this->cec.inst));
>          msleep(200);
>          TRY(tmdlHdmiCecActiveSource(this->cec.inst,this->cec.phy_addr));
>          this->cec.source_status = CEC_POWER_STATUS_ON;
>       }
>    }
> #endif
>    
> #if 0
>    if (this->cec.phy_addr != 0xFFFF) {
> 
>       /* claim source status */
>       if ((get_hdmi_status() ==  tmPowerStandby) &&             \
>           (this->cec.source_status == CEC_POWER_STATUS_ON)) {
>          /* send inactive msg when hdmi has been disabled */
>          this->cec.source_status = CEC_POWER_STATUS_STANDBY;
>          TRY(tmdlHdmiCecInactiveSource(this->cec.inst,          \
>                                        this->cec.initiator,     \
>                                        this->cec.phy_addr));
>       }
>       else if ((get_hdmi_status() ==  tmPowerOn) &&                     \
>                (this->cec.source_status == CEC_POWER_STATUS_STANDBY)) {
>          /* send active msg when hdmi has been abled */
>          this->cec.source_status = CEC_POWER_STATUS_ON;
>          TRY(tmdlHdmiCecActiveSource(this->cec.inst,        \
>                                      this->cec.phy_addr));
>       }
> /*       printk(KERN_INFO "DBG phd_status:%s cec.power:%s\n", \ */
> /*              get_hpd_status()?"Active":"Inactive",                                      \ */
> /*              (this->cec.power==tmPowerOn)?"On":"Standby"); */
>    }
> #endif
> 
>    /* internal handeling */
>    TRY(tmdlHdmiCecHandleInterrupt(this->cec.inst));
>     
>  TRY_DONE:
> 
>    /* setup next tick */
>    if (!this->driver.deinit_req) {
>       /* setup next polling */
> #ifndef IRQ
> /*       this->driver.timer.expires = jiffies + ( CHECK_EVERY_XX_MS * HZ / 1000 ); */
> /*       add_timer(&this->driver.timer); */
>       mod_timer(&this->driver.timer,jiffies + ( CHECK_EVERY_XX_MS * HZ / 1000 ));
> #endif
>    }
>    else {
>       this->driver.deinit_req++;
>       wake_up_interruptible(&this->driver.wait);
>    }
> }
> 
> #ifndef IRQ
> static DECLARE_WORK(wq_name, cec_interrupt);
> 
> void polling_timeout(unsigned long arg)
> {
> 
> #if 0
>    /* fake frame for equipement-less testing */
> 
>       cec_instance *this=&our_instance;
> 
>       if (this->driver.timer.data++>1000) {
>          printk(KERN_INFO "Fake Rx message\n");
>          this->driver.timer.data=0;
> 
>          this->cec.frame.count = 4;
>          this->cec.frame.addr = 4; /* 0-->4 (TV-->MediaPlayer1) */
>          this->cec.frame.data[0]=0x46; /* opcode: "GiveOsd" */
>          this->cec.frame.service = CEC_RX_DONE;
>          
>          this->driver.poll_done = true;
>          wake_up_interruptible(&this->driver.wait);
>       }
> #endif
> 
>    /* derefered because ATOMIC context of timer does not support I2C_transfert */
>    schedule_work(&wq_name);
> 
> }
> #endif
> 
> #ifndef IRQ
> /*
>  *  TDA irq
>  */
> static irqreturn_t tda_irq(int irq, void *_udc)
> {
>    cec_instance *this=&our_instance;
>    /*    printk(KERN_INFO "DBG caught irq:%d\n",irq); */
>  
>    /* do it now */
>    mod_timer(&this->driver.timer,jiffies);
> 
>    return IRQ_HANDLED;
> }
> #endif
> 
> #ifdef TWL4030_HACK
> /*
>  *  User Control
>  */
> static void user_control(int key, int press)
> {
>    input_report_key(gkp_input, key, press);
>    input_sync(gkp_input);
>    msleep(20);
>    input_report_key(gkp_input, key, 0);
>    input_sync(gkp_input);
> }
> #endif
> 
> /*
>  *  CEC callback
>  */
> static void eventCallbackCEC(tmdlHdmiCecEvent_t event, unsigned char *data, unsigned char length)
> {
>    int err=0;
>    cec_instance *this=&our_instance;
>    int opcode;
>    int initiator,receiver;
> 
>    if (event == TMDL_HDMICEC_CALLBACK_MESSAGE_AVAILABLE) {
> 
>       this->cec.frame.count = length;
>       this->cec.frame.addr = data[1]; /* .AddressByte */
>       initiator = (this->cec.frame.addr >> 4) & 0x0F;
>       this->cec.initiator = initiator;
>       receiver = this->cec.frame.addr & 0x0F;
>       memcpy(&this->cec.frame.data,&data[2],length-2); /* .DataBytes[], length - siezof(length,addr,ack) */
>       opcode=this->cec.frame.data[0];
>       printk(KERN_INFO "hdmicec:Rx:[%x--->%x] %s length:%d addr:%d %02x%02x%02x%02x\n",initiator,receiver,cec_opcode(opcode), \
>           length,data[1],
>           this->cec.frame.data[0],                                      \
>           this->cec.frame.data[1],                                      \
>           this->cec.frame.data[2],                                      \
>           this->cec.frame.data[3]);
>       this->cec.frame.service = CEC_RX_DONE;
> 
>       msleep(20);
> 
>       /* automatic answering */
>       switch (opcode) {
>       case CEC_OPCODE_GIVE_PHYSICAL_ADDRESS:
>          TRY(tmdlHdmiCecReportPhysicalAddress(this->cec.inst,           \
>                                               this->cec.phy_addr,       \
>                                               this->cec.device_type));
>          break;
>       case CEC_OPCODE_GET_CEC_VERSION:
>          TRY(tmdlHdmiCecVersion(this->cec.inst,                         \
>                                 this->cec.initiator,                    \
>                                 this->cec.version));
>          break;   
>       case CEC_OPCODE_GIVE_OSD_NAME:
>          TRY(tmdlHdmiCecSetOsdName(this->cec.inst,         \
>                                    this->cec.initiator,        \
>                                    this->cec.osd_name.data,         \
>                                    this->cec.osd_name.length));
>          break;
>       case CEC_OPCODE_GIVE_DEVICE_VENDOR_ID:
>          TRY(tmdlHdmiCecDeviceVendorID(this->cec.inst,              \
>                                        this->cec.vendor_id));
>          break;
>       case CEC_OPCODE_REQUEST_ACTIVE_SOURCE:
>          if (this->cec.source_status == CEC_POWER_STATUS_ON) {
>             if (this->cec.initiator != 0x0F) {
>                if (receiver == 0x0F) {
>                   TRY(tmdlHdmiCecActiveSource(this->cec.inst,this->cec.phy_addr));
>                }
>             }
>          }
>          break;
>       case CEC_OPCODE_ACTIVE_SOURCE:
>          if (this->cec.source_status == CEC_POWER_STATUS_ON) {
>             this->cec.source_status = CEC_POWER_STATUS_STANDBY;
>             hdmi_disable(1);
>             this->cec.power = tmPowerOn;
>             TRY(tmdlHdmiCecSetPowerState(this->cec.inst,this->cec.power)); /* keeps CEC alive */
>          }
>          break;
>       case CEC_OPCODE_GIVE_DEVICE_POWER_STATUS:
>          TRY(tmdlHdmiCecReportPowerStatus(this->cec.inst,               \
>                                           this->cec.initiator,          \
>                                           this->cec.source_status));
>          break;
>       case CEC_OPCODE_STANDBY:
>          /* mind recording device can only be stopped by appli */ 
>          if (this->cec.device_type != CEC_DEVICE_TYPE_REC_DEVICE) {
>             this->cec.source_status = CEC_POWER_STATUS_STANDBY;
>             hdmi_disable(1);
>             this->cec.power = tmPowerOn;
>             TRY(tmdlHdmiCecSetPowerState(this->cec.inst,this->cec.power));  /* keeps CEC alive */
>          }
>          break;
>       case CEC_OPCODE_ROUTING_INFORMATION:
>       case CEC_OPCODE_SET_STREAM_PATH:
>          /* wake-up if called */
>          if (this->cec.phy_addr == (((int)this->cec.frame.data[1] << 8) + this->cec.frame.data[2])) {
>             if (this->cec.source_status != CEC_POWER_STATUS_ON) {
>                this->cec.source_status = CEC_POWER_STATUS_ON;
>                hdmi_enable();
>             }
>             TRY(tmdlHdmiCecActiveSource(this->cec.inst,this->cec.phy_addr));
>          }
>          break;
> /*       case /\* NEW DECK ??? *\/ */
>       case CEC_OPCODE_ROUTING_CHANGE:
>          /* wake-up if called */
>          if (this->cec.phy_addr == (((int)this->cec.frame.data[3] << 8) + this->cec.frame.data[4])) {
>             if (this->cec.source_status != CEC_POWER_STATUS_ON) {
>                this->cec.source_status = CEC_POWER_STATUS_ON;
>                hdmi_enable();
>             }
>             TRY(tmdlHdmiCecActiveSource(this->cec.inst,this->cec.phy_addr));
>          }
>          break;
>       case CEC_OPCODE_ABORT_MESSAGE:
>          if (this->cec.phy_addr == (((int)this->cec.frame.data[3] << 8) + this->cec.frame.data[4])) {
>             TRY(tmdlHdmiCecFeatureAbort(this->cec.inst, \
>                                         this->cec.initiator, \
>                                         this->cec.feature_abort.FeatureOpcode, \
>                                         this->cec.feature_abort.AbortReason));
>          }
>          break;
>       case CEC_OPCODE_MENU_REQUEST:
> #ifdef TWL4030_HACK
>          this->cec.menu_status = CEC_MENU_STATE_ACTIVATE;
>          TRY(tmdlHdmiCecMenuStatus(this->cec.inst, \
>                                    this->cec.initiator, \
>                                    this->cec.menu_status));
>          break;
> #endif
>       case CEC_OPCODE_USER_CONTROL_PRESSED:
>          switch (this->cec.frame.data[1]) {
> #ifdef TWL4030_HACK /* AL : hack to bypass keypad */
>          case CEC_REMOTE_BUTTON_SELECT:
>             user_control(353,64);
>             break;
>          case CEC_REMOTE_BUTTON_UP:
>             user_control(103,128);
>             break;
>          case CEC_REMOTE_BUTTON_DOWN:
>             user_control(108,128);
>             break;
>          case CEC_REMOTE_BUTTON_LEFT:
>             user_control(105,128);
>             break;
>          case CEC_REMOTE_BUTTON_RIGHT:
>             user_control(106,128);
>             break;
>          case CEC_REMOTE_BUTTON_EXIT:
>             user_control(14,8);
>             break;
> #endif
>          case CEC_REMOTE_BUTTON_POWER:
>             this->cec.source_status = CEC_POWER_STATUS_ON;
>             hdmi_enable();
>             break;
>          default:
>             this->cec.feature_abort.FeatureOpcode=opcode;
>             this->cec.feature_abort.AbortReason=CEC_ABORT_INVALID_OPERAND;
>             TRY(tmdlHdmiCecFeatureAbort(this->cec.inst, \
>                                         this->cec.initiator, \
>                                         this->cec.feature_abort.FeatureOpcode, \
>                                         this->cec.feature_abort.AbortReason));
>             break;
>          }
>          break;
>       case CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN:
> 	   //[jaeseong.gim] comment dout
> 	   //user_control(59,8);
>          break;
>       case CEC_OPCODE_FEATURE_ABORT:
>          /* stop any state machine transition */
>          break;
>       case CEC_OPCODE_VENDOR_COMMAND:
>       case CEC_OPCODE_DEVICE_VENDOR_ID:
>          /* hopefully will be handle in userspace */
>          break;
>       default:
>          if (receiver != 0x0F) {
>             this->cec.feature_abort.FeatureOpcode=opcode;
>             this->cec.feature_abort.AbortReason=CEC_ABORT_UNKNOWN_OPCODE;
>             TRY(tmdlHdmiCecFeatureAbort(this->cec.inst,                 \
>                                         this->cec.initiator,            \
>                                         this->cec.feature_abort.FeatureOpcode, \
>                                         this->cec.feature_abort.AbortReason));
>          }
>          break;
>       }
>       this->driver.poll_done = true;
>       wake_up_interruptible(&this->driver.wait);
>    }
>    else if (event == TMDL_HDMICEC_CALLBACK_STATUS) {
> 
>       this->cec.frame.count = length;
>       this->cec.frame.addr = data[1]; /* .AddressByte */
>       initiator = (this->cec.frame.addr >> 4) & 0x0F;
>       receiver = this->cec.frame.addr & 0x0F;
>       memcpy(&this->cec.frame.data,&data[2],length-2); /* .DataBytes[], length - siezof(length,addr)  */
>       opcode=this->cec.frame.data[0];
>       this->cec.frame.service = CEC_TX_DONE;
> 
>       if (length==POLLING_LENGTH) {
>          if (opcode == CEC_MSG_FAIL_DEST_NOT_ACK) {
>             /* no echo means it's mine ! */
>             TRY(tmdlHdmiCecSetLogicalAddress(this->cec.inst,this->cec.rx_addr));
>             TRY(tmdlHdmiCecReportPhysicalAddress(this->cec.inst,        \
>                                                  this->cec.phy_addr,    \
>                                                  this->cec.device_type));
>             /* DEVICE VENDOR ID sending after logicial address allocation according to spec 1.4 */
>             TRY(tmdlHdmiCecDeviceVendorID(this->cec.inst, this->cec.vendor_id));
>          }
>          else if (opcode == CEC_MSG_SUCCESS) {
>             /* try next one */
>             this->cec.rx_addr=get_next_logical_addr(this->cec.device_type,this->cec.rx_addr);
>             if (this->cec.rx_addr != CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST) {
>                TRY(tmdlHdmiCecPollingMessage(this->cec.inst,this->cec.rx_addr));
>             }
>             else {
>                /* no more room, keep and claim unregistred */
>                TRY(tmdlHdmiCecSetLogicalAddress(this->cec.inst,this->cec.rx_addr));
>                TRY(tmdlHdmiCecReportPhysicalAddress(this->cec.inst,     \
>                                                     this->cec.phy_addr, \
>                                                     this->cec.device_type));
>             }
>          }
>          else {
>             printk(KERN_INFO "ACK [%x--->%x] %s\n",initiator,receiver,cec_rxstatus(opcode));
>          }
>       }
>       else {
>          if (CEC_MSG_SUCCESS != opcode) {
>             printk(KERN_INFO "ACK [%x--->%x] %s\n",initiator,receiver,cec_rxstatus(opcode));
>          }
>       }
> 
>       this->driver.poll_done = true;
>       wake_up_interruptible(&this->driver.wait);
> 
>    }
>    else {
>       LOG(KERN_ERR,"Oups ! Callback got invalid event %d !\n",event);
>    }
> 
>  TRY_DONE:
>    (void)err;
> }
> 
> /*
>  *  DevLib CEC opening
>  */
> static int hdmi_cec_init(cec_instance *this)
> {
>    int err=0;
> 
>    /* Real opening */
>    TRY(tmdlHdmiCecOpen(&this->cec.inst));
> 
> /*    this->cec.vendor_id = 0x006037;   /\* NXP (IEEE OUI) *\/ */
> /*    this->cec.vendor_id = 0x0000f0;   /\* Samsung *\/ */
>    this->cec.vendor_id = 0x00e091;   /* LGE */
> 
> /*    this->cec.version = CEC_VERSION_1_4; */
>    this->cec.version = CEC_VERSION_1_3a;
>    this->cec.osd_name.data[0]=0x54; /* TDA19989 by default */
>    this->cec.osd_name.data[1]=0x44;
>    this->cec.osd_name.data[2]=0x41;
>    this->cec.osd_name.data[3]=0x31;
>    this->cec.osd_name.data[4]=0x39;
>    this->cec.osd_name.data[5]=0x39;
>    this->cec.osd_name.data[6]=0x38;
>    this->cec.osd_name.data[7]=0x39;
>    this->cec.osd_name.length=8;
>    
>    TRY(tmdlHdmiCecRegisterCallbacks(this->cec.inst,eventCallbackCEC));
>        
>    this->cec.phy_addr = param_addr;
>    this->cec.device_type = device_type(param_device);
> 
>  TRY_DONE:
>    return err;
> }
> 
> 
> /*
>  *
>  * ENTRY POINTS
>  * ------------
>  * LEVEL 3
>  *
>  * - 
>  *
>  */
> 
> 
> 
> /*
>  *  ioctl driver :: opening
>  */
> 
> static int this_cdev_open(struct inode *pInode, struct file *pFile)
> {
>    cec_instance *this;
>    int minor=iminor(pInode);
> 
>    if(minor >= MAX_MINOR) {
>       printk(KERN_ERR "hdmicec:%s:only one cec opening please\n",__func__);
>       return -EINVAL;
>    }
> 
>    if ((pFile->private_data != NULL) && (pFile->private_data != &our_instance)) {
>       printk(KERN_ERR "hdmicec:%s:pFile missmatch\n",__func__);
>    }
>    this = pFile->private_data = &our_instance;
>    down(&this->driver.sem);
> 
>    LOG(KERN_INFO,"major:%d minor:%d user:%d\n", imajor(pInode), iminor(pInode), this->driver.user_counter);
> 
>    if ((this->driver.user_counter++) && (this->driver.minor == minor)) {
>       /* init already done */
>       up(&this->driver.sem);
>       return 0;
>    }
>    this->driver.minor = minor;
> 
> 
>    up(&this->driver.sem);
>    return 0;
> }
> 
> /*
>  *  ioctl driver :: ioctl
>  */
> static int this_cdev_ioctl(struct inode *pInode, struct file *pFile, unsigned int cmd, unsigned long arg)
> {
>    cec_instance* this = pFile->private_data;
>    int err=0;
> 
>    LOG(KERN_INFO,":%s\n",cec_ioctl(_IOC_NR(cmd)));
> 
>    BUG_ON(this->driver.minor!=iminor(pInode));
>    if (_IOC_TYPE(cmd) != CEC_IOCTL_BASE) {
>       printk(KERN_INFO "hdmicec:%s:unknown ioctl type: %x\n",__func__,_IOC_TYPE(cmd));
>       return -ENOIOCTLCMD;
>    }
> 
>    if (_IOC_DIR(cmd) & _IOC_READ) 
>       err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd)) || !arg;
>    else if (_IOC_DIR(cmd) & _IOC_WRITE)
>       err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd)) || !arg;
>    if (err) {
>       printk(KERN_ERR "hdmicec:%s:argument access denied (check address vs value)\n",__func__);
>       printk(KERN_ERR "_IOC_DIR:%d arg:%lx\n",_IOC_DIR(cmd),arg);
>       return -EFAULT;
>    }
>    
>    down(&this->driver.sem);
> 
>    /* Check DevLib consistancy here */
> 
>    switch ( _IOC_NR(cmd) )
>       {
>       case CEC_VERBOSE_ON_CMD:
>          {
>             printk(KERN_INFO "verbose on\n");
>             this->param.verbose=1;
>             break;
>          }
> 
>       case CEC_VERBOSE_OFF_CMD:
>          {
>             printk(KERN_INFO "verbose off\n");
>             this->param.verbose=0;
>             break;
>          }
> 
>       case CEC_BYEBYE_CMD:
>          {
>             LOG(KERN_INFO,"callback release request\n");
>             this->cec.frame.service=CEC_RELEASE;
>             this->driver.poll_done = true;
>             wake_up_interruptible(&this->driver.wait);
>             break;
>          }
> 
>          /*
>            no param
>          */
> 
>       case CEC_IOCTL_DISABLE_CALIBRATION_CMD:
>          {
>             TRY(tmdlHdmiCecDisableCalibration(this->cec.inst));
>             break;
>          }
> 
>       case CEC_IOCTL_INSTANCE_CONFIG_CMD:
>          {
>             TRY(tmdlHdmiCecInstanceConfig(this->cec.inst));
>             break;
>          }
> 
>       case CEC_IOCTL_REQUEST_ACTIVE_SRC_CMD:
>          {
>             TRY(tmdlHdmiCecRequestActiveSource(this->cec.inst));
>             break;
>          }
> 
>       case CEC_IOCTL_ABORT_MSG_CMD:
>          {
>             TRY(tmdlHdmiCecAbortMessage(this->cec.inst,this->cec.initiator));
>             break;
>          }
> 
>       case CEC_IOCTL_GET_MENU_LANGUAGE_CMD:
>          {
>             TRY(tmdlHdmiCecGetMenuLanguage(this->cec.inst,this->cec.initiator));
>             break;
>          }
> 
>       case CEC_IOCTL_GIVE_AUDIO_STATUS_CMD:
>          {
>             TRY(tmdlHdmiCecGiveAudioStatus(this->cec.inst,this->cec.initiator));
>             break;
>          }
> 
>       case CEC_IOCTL_GIVE_DEVICE_POWER_STATUS_CMD:
>          {
>             TRY(tmdlHdmiCecGiveDevicePowerStatus(this->cec.inst,this->cec.initiator));
>             break;
>          }
> 
>       case CEC_IOCTL_GIVE_DEVICE_VENDOR_ID_CMD:
>          {
>             TRY(tmdlHdmiCecGiveDeviceVendorID(this->cec.inst,this->cec.initiator));
>             break;
>          }
> 
>       case CEC_IOCTL_GIVE_OSD_NAME_CMD:
>          {
>             TRY(tmdlHdmiCecGiveOsdName(this->cec.inst,this->cec.initiator));
>             break;
>          }
> 
>       case CEC_IOCTL_GIVE_PHY_ADDR_CMD:
>          {
>             TRY(tmdlHdmiCecGivePhysicalAddress(this->cec.inst,this->cec.initiator));
>             break;
>          }
> 
>       case CEC_IOCTL_GIVE_SYS_AUDIO_MODE_STATUS_CMD:
>          {
>             TRY(tmdlHdmiCecGiveSystemAudioModeStatus(this->cec.inst,this->cec.initiator));
>             break;
>          }
> 
>       case CEC_IOCTL_IMAGE_VIEW_ON_CMD:
>          {
>             TRY(tmdlHdmiCecImageViewOn(this->cec.inst,this->cec.initiator));
>             break;
>          }
> 
>       case CEC_IOCTL_POLLING_MSG_CMD:
>          {
>             TRY(tmdlHdmiCecPollingMessage(this->cec.inst,this->cec.rx_addr));
>             break;
>          }
> 
>       case CEC_IOCTL_REC_OFF_CMD:
>          {
>             TRY(tmdlHdmiCecRecordOff(this->cec.inst,this->cec.initiator));
>             break;
>          }
> 
>       case CEC_IOCTL_REC_ON_OWN_SRC_CMD:
>          {
>             TRY(tmdlHdmiCecRecordOnOwnSource(this->cec.inst,this->cec.initiator));
>             break;
>          }
> 
>       case CEC_IOCTL_REC_TV_SCREEN_CMD:
>          {
>             TRY(tmdlHdmiCecRecordTvScreen(this->cec.inst,this->cec.initiator));
>             break;
>          }
> 
>       case CEC_IOCTL_STANDBY_CMD:
>          {
>             TRY(tmdlHdmiCecStandby(this->cec.inst,this->cec.initiator));
>             break;
>          }
> 
>       case CEC_IOCTL_TEXT_VIEW_ON_CMD:
>          {
>             TRY(tmdlHdmiCecTextViewOn(this->cec.inst,this->cec.initiator));
>             break;
>          }
> 
>       case CEC_IOCTL_TUNER_STEP_DECREMENT_CMD:
>          {
>             TRY(tmdlHdmiCecTunerStepDecrement(this->cec.inst,this->cec.initiator));
>             break;
>          }
> 
>       case CEC_IOCTL_TUNER_STEP_INCREMENT_CMD:
>          {
>             TRY(tmdlHdmiCecTunerStepIncrement(this->cec.inst,this->cec.initiator));
>             break;
>          }
> 
>       case CEC_IOCTL_USER_CTRL_RELEASED_CMD:
>          {
>             TRY(tmdlHdmiCecUserControlReleased(this->cec.inst,this->cec.initiator));
>             break;
>          }
> 
>       case CEC_IOCTL_VENDOR_REMOTE_BUTTON_UP_CMD:
>          {
>             TRY(tmdlHdmiCecVendorRemoteButtonUp(this->cec.inst,this->cec.initiator));
>             break;
>          }
> 
>       case CEC_IOCTL_ROUTING_INFORMATION_CMD:
>          {
>             TRY(tmdlHdmiCecRoutingInformation(this->cec.inst,this->cec.phy_addr));
>             break;
>          }
> 
>       case CEC_IOCTL_SET_STREAM_PATH_CMD:
>          {
>             TRY(tmdlHdmiCecSetStreamPath(this->cec.inst,this->cec.phy_addr));
>             break;
>          }
> 
>       case CEC_IOCTL_ACTIVE_SRC_CMD:
>          {
>             /* NEW first do a <image view on> */
>             /* NEW when switch by DSS and was inactive */
>             TRY(tmdlHdmiCecActiveSource(this->cec.inst,this->cec.phy_addr));
>             break;
>          }
> 
>       case CEC_IOCTL_SYS_AUDIO_MODE_REQUEST_CMD:
>          {
>             TRY(tmdlHdmiCecSystemAudioModeRequest(this->cec.inst, \
>                                                   this->cec.initiator, \
>                                                   this->cec.phy_addr));
>             break;
>          }
> 
>          /*
>            1 param
>          */
> 
>       case CEC_IOCTL_RX_ADDR_CMD:
>          {
>             /* 	    BUG_ON(copy_from_user(&this->cec.rx_addr,(unsigned char*)arg,sizeof(unsigned char)) != 0); */
>             this->cec.rx_addr=arg;
>             TRY(tmdlHdmiCecSetLogicalAddress(this->cec.inst,this->cec.rx_addr));
>             break;
>          }
> 
>       case CEC_IOCTL_PHY_ADDR_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.phy_addr,(unsigned short*)arg,sizeof(unsigned short)) != 0);
>             break;
>          }
> 
>       case CEC_IOCTL_GET_CEC_VERSION_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.version,(cec_version*)arg,sizeof(cec_version)) != 0);
>             TRY(tmdlHdmiCecGetCecVersion(this->cec.inst,this->cec.version));
>             break;
>          }
> 
>       case CEC_IOCTL_GET_SW_VERSION_CMD:
>          {
>             TRY(tmdlHdmiCecGetSWVersion(&this->cec.sw_version));
>             BUG_ON(copy_to_user((cec_sw_version*)arg,&this->cec.sw_version,sizeof(cec_sw_version)) != 0);
>             break;
>          }
> 
>       case CEC_IOCTL_SET_POWER_STATE_CMD:
>          {
>             /* NEW : log : please use DSS */
>             BUG_ON(copy_from_user(&this->cec.power,(cec_power*)arg,sizeof(cec_power)) != 0);
>             TRY(tmdlHdmiCecSetPowerState(this->cec.inst,this->cec.power));
>             break;
>          }
> 
>       case CEC_IOCTL_GET_POWER_STATE_CMD:
>          {
>             TRY(tmdlHdmiCecGetPowerState(this->cec.inst,&this->cec.power));
>             BUG_ON(copy_to_user((cec_power*)arg,&this->cec.power,sizeof(cec_power)) != 0);
>             break;
>          }
> 
>       case CEC_IOCTL_INSTANCE_SETUP_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.setup,(cec_setup*)arg,sizeof(cec_setup)) != 0);
>             TRY(tmdlHdmiCecInstanceSetup(this->cec.inst,&this->cec.setup));
>             break;
>          }
> 
>       case CEC_IOCTL_GET_INSTANCE_SETUP_CMD:
>          {
>             TRY(tmdlHdmiCecGetInstanceSetup(this->cec.inst,&this->cec.setup));
>             BUG_ON(copy_to_user((cec_setup*)arg,&this->cec.setup,sizeof(cec_setup)) != 0);
>             break;
>          }
> 
>          /*
>            case CEC_IOCTL_ENABLE_EVENT_CMD:
>            {
>            BUG_ON(copy_from_user(&this->cec.an_event,(cec_event*)arg,sizeof(cec_event)) != 0);
>            TRY(tmdlHdmiCecEnableEvent(this->cec.inst,this->cec.an_event));
>            break;
>            }
> 
>            case CEC_IOCTL_DISABLE_EVENT_CMD:
>            {
>            BUG_ON(copy_from_user(&this->cec.an_event,(cec_event*)arg,sizeof(cec_event)) != 0);
>            TRY(tmdlHdmiCecDisableEvent(this->cec.inst,this->cec.an_event));
>            break;
>            }
>          */
> 
>       case CEC_IOCTL_SET_MENU_LANGUAGE_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.clock,(cec_string*)arg,sizeof(cec_string)) != 0);
>             TRY(tmdlHdmiCecSetMenuLanguage(this->cec.inst,this->cec.string.data));
>             break;
>          }
> 
>       case CEC_IOCTL_ENABLE_CALIBRATION_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.clock,(cec_clock*)arg,sizeof(cec_clock)) != 0);
>             TRY(tmdlHdmiCecEnableCalibration(this->cec.inst,this->cec.clock));
>             break;
>          }
> 
>          /*
>            >1 param
>          */
> 
>       case CEC_IOCTL_WAIT_FRAME_CMD:
>          {
>             this->cec.frame.service = CEC_WAITING;
>             this->driver.poll_done = false;
>             up(&this->driver.sem);
>             if (wait_event_interruptible(this->driver.wait,this->driver.poll_done)) return -ERESTARTSYS;
>             down(&this->driver.sem);
>             BUG_ON(copy_to_user((cec_frame*)arg,&this->cec.frame,sizeof(cec_frame)) != 0);
>             break;
>          }
> 
>       case CEC_IOCTL_VERSION_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.version,(cec_version*)arg,sizeof(cec_version)) != 0);
>             TRY(tmdlHdmiCecVersion(this->cec.inst, \
>                                    this->cec.initiator, \
>                                    this->cec.version));
>             break;
>          }
> 
>       case CEC_IOCTL_CLEAR_ANALOGUE_TIMER_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.analog_timer,(cec_analogue_timer*)arg,sizeof(cec_analogue_timer)) != 0);
>             TRY(tmdlHdmiCecClearAnalogueTimer(this->cec.inst, \
>                                               this->cec.initiator, \
>                                               this->cec.analog_timer.DayOfMonth, \
>                                               this->cec.analog_timer.MonthOfYear, \
>                                               this->cec.analog_timer.StartTime, \
>                                               &this->cec.analog_timer.Duration, \
>                                               this->cec.analog_timer.RecordingSequence, \
>                                               this->cec.analog_timer.AnalogueBroadcastType, \
>                                               this->cec.analog_timer.AnalogueFrequency, \
>                                               this->cec.analog_timer.BroadcastSystem));
>             break;
>          }
> 
>       case CEC_IOCTL_CLEAR_DIGITAL_TIMER_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.digital_timer,(cec_digital_timer*)arg,sizeof(cec_digital_timer)) != 0);
>             TRY(tmdlHdmiCecClearDigitalTimer(this->cec.inst, \
>                                              this->cec.initiator, \
>                                              this->cec.digital_timer.DayOfMonth, \
>                                              this->cec.digital_timer.MonthOfYear, \
>                                              this->cec.digital_timer.StartTime, \
>                                              &this->cec.digital_timer.Duration, \
>                                              this->cec.digital_timer.RecordingSequence, \
>                                              &this->cec.digital_timer.ServiceIdentification));
>             break;
>          }
> 
>       case CEC_IOCTL_CLEAR_EXT_TIMER_WITH_EXT_PLUG_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.etwep,(cec_ext_timer_with_ext_plug*)arg,sizeof(cec_ext_timer_with_ext_plug)) != 0);
>             TRY(tmdlHdmiCecClearExternalTimerWithExternalPlug(this->cec.inst, \
>                                                               this->cec.initiator, \
>                                                               this->cec.etwep.DayOfMonth, \
>                                                               this->cec.etwep.MonthOfYear, \
>                                                               this->cec.etwep.StartTime, \
>                                                               &this->cec.etwep.Duration, \
>                                                               this->cec.etwep.RecordingSequence, \
>                                                               this->cec.etwep.ExternalPlug));
>             break;
>          }
> 
>       case CEC_IOCTL_CLEAR_EXT_TIMER_WITH_PHY_ADDR_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.etwpa,(cec_ext_timer_with_phy_addr*)arg,sizeof(cec_ext_timer_with_phy_addr)) != 0);
>             TRY(tmdlHdmiCecClearExternalTimerWithPhysicalAddress(this->cec.inst, \
>                                                                  this->cec.initiator, \
>                                                                  this->cec.etwpa.DayOfMonth, \
>                                                                  this->cec.etwpa.MonthOfYear, \
>                                                                  this->cec.etwpa.StartTime, \
>                                                                  &this->cec.etwpa.Duration, \
>                                                                  this->cec.etwpa.RecordingSequence, \
>                                                                  this->cec.etwpa.ExternalPhysicalAddress));
>             break;
>          }
> 
>       case CEC_IOCTL_DECK_CTRL_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.deck_ctrl,(cec_deck_ctrl*)arg,sizeof(cec_deck_ctrl)) != 0);
>             TRY(tmdlHdmiCecDeckControl(this->cec.inst, \
>                                        this->cec.initiator, \
>                                        this->cec.deck_ctrl));
>             break;
>          }
> 
>       case CEC_IOCTL_DECK_STATUS_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.deck_status,(cec_deck_status*)arg,sizeof(cec_deck_status)) != 0);
>             TRY(tmdlHdmiCecDeckStatus(this->cec.inst, \
>                                       this->cec.initiator, \
>                                       this->cec.deck_status));
>             break;
>          }
> 
>       case CEC_IOCTL_DEVICE_VENDOR_ID_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.vendor_id,(unsigned long*)arg,sizeof(unsigned long)) != 0);
>             TRY(tmdlHdmiCecDeviceVendorID(this->cec.inst, \
>                                           this->cec.vendor_id));
>             break;
>          }
> 
>       case CEC_IOCTL_FEATURE_ABORT_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.feature_abort,(cec_feature_abort*)arg,sizeof(cec_feature_abort)) != 0);
>             TRY(tmdlHdmiCecFeatureAbort(this->cec.inst, \
>                                         this->cec.initiator, \
>                                         this->cec.feature_abort.FeatureOpcode, \
>                                         this->cec.feature_abort.AbortReason));
>             break;
>          }
> 
>       case CEC_IOCTL_GIVE_DECK_STATUS_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.satus_request,(cec_status_request*)arg,sizeof(cec_status_request)) != 0);
>             TRY(tmdlHdmiCecGiveDeckStatus(this->cec.inst, \
>                                           this->cec.initiator, \
>                                           this->cec.satus_request));
>             break;
>          }
> 
>       case CEC_IOCTL_GIVE_TUNER_DEVICE_STATUS_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.satus_request,(cec_status_request*)arg,sizeof(cec_status_request*)) != 0);
>             TRY(tmdlHdmiCecGiveTunerDeviceStatus(this->cec.inst, \
>                                                  this->cec.initiator, \
>                                                  this->cec.satus_request));
>             break;
>          }
> 
>       case CEC_IOCTL_INACTIVE_SRC_CMD:
>          {
>             /* NEW first stand by video */
>             /* NEW when hdmi_disable and was active */
>             TRY(tmdlHdmiCecInactiveSource(this->cec.inst, \
>                                           this->cec.initiator, \
>                                           this->cec.phy_addr));
>             break;
>          }
> 
>       case CEC_IOCTL_MENU_REQUEST_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.menu_request,(cec_menu_request*)arg,sizeof(cec_menu_request)) != 0);
>             TRY(tmdlHdmiCecMenuRequest(this->cec.inst, \
>                                        this->cec.initiator, \
>                                        this->cec.menu_request));
>             break;
>          }
> 
>       case CEC_IOCTL_MENU_STATUS_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.menu_status,(cec_menu_status*)arg,sizeof(cec_menu_status)) != 0);
>             TRY(tmdlHdmiCecMenuStatus(this->cec.inst, \
>                                       this->cec.initiator, \
>                                       this->cec.menu_status));
>             break;
>          }
> 
>       case CEC_IOCTL_PLAY_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.play,(cec_play*)arg,sizeof(cec_play)) != 0);
>             TRY(tmdlHdmiCecPlay(this->cec.inst, \
>                                 this->cec.initiator, \
>                                 this->cec.play));
>             break;
>          }
> 
>       case CEC_IOCTL_REC_ON_ANALOGUE_SERVICE_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.analog_service,(cec_analogue_service*)arg,sizeof(cec_analogue_service)) != 0);
>             TRY(tmdlHdmiCecRecordOnAnalogueService(this->cec.inst, \
>                                                    this->cec.initiator, \
>                                                    this->cec.analog_service.AnalogueBroadcastType, \
>                                                    this->cec.analog_service.AnalogueFrequency, \
>                                                    this->cec.analog_service.BroadcastSystem));
>             break;
>          }
> 
>       case CEC_IOCTL_REC_ON_DIGITAL_SERVICE_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.digital_service,(cec_digital_service*)arg,sizeof(cec_digital_service)) != 0);
>             TRY(tmdlHdmiCecRecordOnDigitalService(this->cec.inst, \
>                                                   this->cec.initiator, \
>                                                   &this->cec.digital_service));
>             break;
>          }
> 
>       case CEC_IOCTL_REC_ON_EXT_PHY_ADDR_CMD:
>          {
>             TRY(tmdlHdmiCecRecordOnExternalPhysicalAddress(this->cec.inst, \
>                                                            this->cec.initiator, \
>                                                            this->cec.phy_addr));
>             break;
>          }
> 
>       case CEC_IOCTL_REC_ON_EXT_PLUG_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.ext_plug,(cec_ext_plug*)arg,sizeof(cec_ext_plug)) != 0);
>             TRY(tmdlHdmiCecRecordOnExternalPlug(this->cec.inst, \
>                                                 this->cec.initiator, \
>                                                 this->cec.ext_plug));
>             break;
>          }
> 
>       case CEC_IOCTL_REC_STATUS_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.rec_status,(cec_rec_status*)arg,sizeof(cec_rec_status)) != 0);
>             TRY(tmdlHdmiCecRecordStatus(this->cec.inst, \
>                                         this->cec.initiator, \
>                                         this->cec.rec_status));
>             break;
>          }
> 
>       case CEC_IOCTL_REPORT_AUDIO_STATUS_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.audio_status,(cec_audio_status*)arg,sizeof(cec_audio_status)) != 0);
>             TRY(tmdlHdmiCecReportAudioStatus(this->cec.inst, \
>                                              this->cec.initiator, \
>                                              &this->cec.audio_status));
>             break;
>          }
> 
>       case CEC_IOCTL_REPORT_PHY_ADDR_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.device_type,(cec_device_type*)arg,sizeof(cec_device_type)) != 0);
>             TRY(tmdlHdmiCecReportPhysicalAddress(this->cec.inst, \
>                                                  this->cec.phy_addr, \
>                                                  this->cec.device_type));
>             break;
>          }
> 
>       case CEC_IOCTL_REPORT_POWER_STATUS_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.source_status,(cec_power_status*)arg,sizeof(cec_power_status)) != 0);
>             TRY(tmdlHdmiCecReportPowerStatus(this->cec.inst, \
>                                              this->cec.initiator, \
>                                              this->cec.source_status));
>             break;
>          }
> 
>       case CEC_IOCTL_SELECT_ANALOGUE_SERVICE_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.analog_service,(cec_analogue_service*)arg,sizeof(cec_analogue_service)) != 0);
>             TRY(tmdlHdmiCecSelectAnalogueService(this->cec.inst, \
>                                                  this->cec.initiator, \
>                                                  this->cec.analog_service.AnalogueBroadcastType, \
>                                                  this->cec.analog_service.AnalogueFrequency, \
>                                                  this->cec.analog_service.BroadcastSystem));
>             break;
>          }
> 
>       case CEC_IOCTL_SELECT_DIGITAL_SERVICE_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.digital_service,(cec_digital_service*)arg,sizeof(cec_digital_service)) != 0);
>             TRY(tmdlHdmiCecSelectDigitalService(this->cec.inst, \
>                                                 this->cec.initiator, \
>                                                 &this->cec.digital_service));
>             break;
>          }
> 
>       case CEC_IOCTL_SET_ANALOGUE_TIMER_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.analog_timer,(cec_analogue_timer*)arg,sizeof(cec_analogue_timer)) != 0);
>             TRY(tmdlHdmiCecSetAnalogueTimer(this->cec.inst, \
>                                             this->cec.initiator, \
>                                             this->cec.analog_timer.DayOfMonth, \
>                                             this->cec.analog_timer.MonthOfYear, \
>                                             this->cec.analog_timer.StartTime, \
>                                             &this->cec.analog_timer.Duration, \
>                                             this->cec.analog_timer.RecordingSequence, \
>                                             this->cec.analog_timer.AnalogueBroadcastType, \
>                                             this->cec.analog_timer.AnalogueFrequency, \
>                                             this->cec.analog_timer.BroadcastSystem));
>             break;
>          }
> 
>       case CEC_IOCTL_SET_AUDIO_RATE_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.audio_rate,(cec_audio_rate*)arg,sizeof(cec_audio_rate)) != 0);
>             TRY(tmdlHdmiCecSetAudioRate(this->cec.inst, \
>                                         this->cec.initiator, \
>                                         this->cec.audio_rate));
>             break;
>          }
> 
>       case CEC_IOCTL_SET_DIGITAL_TIMER_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.digital_timer,(cec_digital_timer*)arg,sizeof(cec_digital_timer)) != 0);
>             TRY(tmdlHdmiCecSetDigitalTimer(this->cec.inst, \
>                                            this->cec.initiator, \
>                                            this->cec.digital_timer.DayOfMonth, \
>                                            this->cec.digital_timer.MonthOfYear, \
>                                            this->cec.digital_timer.StartTime, \
>                                            &this->cec.digital_timer.Duration, \
>                                            this->cec.digital_timer.RecordingSequence, \
>                                            &this->cec.digital_timer.ServiceIdentification));
>             break;
>          }
> 
>       case CEC_IOCTL_SET_EXT_TIMER_WITH_EXT_PLUG_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.etwep,(cec_ext_timer_with_ext_plug*)arg,sizeof(cec_ext_timer_with_ext_plug)) != 0);
>             TRY(tmdlHdmiCecSetExternalTimerWithExternalPlug(this->cec.inst, \
>                                                             this->cec.initiator, \
>                                                             this->cec.etwep.DayOfMonth, \
>                                                             this->cec.etwep.MonthOfYear, \
>                                                             this->cec.etwep.StartTime, \
>                                                             &this->cec.etwep.Duration, \
>                                                             this->cec.etwep.RecordingSequence, \
>                                                             this->cec.etwep.ExternalPlug));
>             break;
>          }
> 
>       case CEC_IOCTL_SET_EXT_TIMER_WITH_PHY_ADDR_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.etwpa,(cec_ext_timer_with_phy_addr*)arg,sizeof(cec_ext_timer_with_phy_addr)) != 0);
>             TRY(tmdlHdmiCecSetExternalTimerWithPhysicalAddress(this->cec.inst, \
>                                                                this->cec.initiator, \
>                                                                this->cec.etwpa.DayOfMonth, \
>                                                                this->cec.etwpa.MonthOfYear, \
>                                                                this->cec.etwpa.StartTime, \
>                                                                &this->cec.etwpa.Duration, \
>                                                                this->cec.etwpa.RecordingSequence, \
>                                                                this->cec.etwpa.ExternalPhysicalAddress));
>             break;
>          }
> 
>       case CEC_IOCTL_SET_SYS_AUDIO_MODE_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.sys_audio_status,(cec_sys_audio_status*)arg,sizeof(cec_sys_audio_status)) != 0);
>             TRY(tmdlHdmiCecSetSystemAudioMode(this->cec.inst, \
>                                               this->cec.initiator, \
>                                               this->cec.sys_audio_status));
>             break;
>          }
> 
>       case CEC_IOCTL_SYS_AUDIO_MODE_STATUS_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.sys_audio_status,(cec_sys_audio_status*)arg,sizeof(cec_sys_audio_status)) != 0);
>             TRY(tmdlHdmiCecSystemAudioModeStatus(this->cec.inst, \
>                                                  this->cec.initiator, \
>                                                  this->cec.sys_audio_status));
>             break;
>          }
> 
>       case CEC_IOCTL_TIMER_CLEARED_STATUS_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.timer_cleared_status,(cec_timer_cleared_status*)arg,sizeof(cec_timer_cleared_status)) != 0);
>             TRY(tmdlHdmiCecTimerClearedStatus(this->cec.inst, \
>                                               this->cec.initiator, \
>                                               this->cec.timer_cleared_status));
>             break;
>          }
> 
>       case CEC_IOCTL_TIMER_STATUS_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.timer_status,(cec_timer_status*)arg,sizeof(cec_timer_status)) != 0);
>             TRY(tmdlHdmiCecTimerStatus(this->cec.inst, \
>                                        this->cec.initiator, \
>                                        &this->cec.timer_status));
>             break;
>          }
> 
>       case CEC_IOCTL_TUNER_DEVICE_STATUS_ANALOGUE_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.tdsa,(cec_tuner_device_status_analogue*)arg,sizeof(cec_tuner_device_status_analogue)) != 0);
>             TRY(tmdlHdmiCecTunerDeviceStatusAnalogue(this->cec.inst, \
>                                                      this->cec.initiator, \
>                                                      this->cec.tdsa.RecordingFlag, \
>                                                      this->cec.tdsa.TunerDisplayInfo, \
>                                                      this->cec.tdsa.AnalogueBroadcastType, \
>                                                      this->cec.tdsa.AnalogueFrequency, \
>                                                      this->cec.tdsa.BroadcastSystem));
>             break;
>          }
> 
>       case CEC_IOCTL_TUNER_DEVICE_STATUS_DIGITAL_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.tdsd,(cec_tuner_device_status_digital*)arg,sizeof(cec_tuner_device_status_digital)) != 0);
>             TRY(tmdlHdmiCecTunerDeviceStatusDigital(this->cec.inst, \
>                                                     this->cec.initiator, \
>                                                     this->cec.tdsd.RecordingFlag, \
>                                                     this->cec.tdsd.TunerDisplayInfo, \
>                                                     &this->cec.tdsd.ServiceIdentification));
>             break;
>          }
> 
>       case CEC_IOCTL_USER_CTRL_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.user_ctrl,(cec_user_ctrl*)arg,sizeof(cec_user_ctrl)) != 0);
>             TRY(tmdlHdmiCecUserControlPressed(this->cec.inst, \
>                                               this->cec.initiator, \
>                                               this->cec.user_ctrl));
>             break;
>          }
> 
>       case CEC_IOCTL_USER_CTRL_PLAY_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.play,(cec_play*)arg,sizeof(cec_play)) != 0);
>             TRY(tmdlHdmiCecUserControlPressedPlay(this->cec.inst, \
>                                                   this->cec.initiator, \
>                                                   this->cec.play));
>             break;
>          }
> 
>       case CEC_IOCTL_USER_CTRL_SELECT_AUDIOINPUT_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.select,(unsigned char*)arg,sizeof(unsigned char)) != 0);
>             TRY(tmdlHdmiCecUserControlPressedSelectAudioInput(this->cec.inst, \
>                                                               this->cec.initiator, \
>                                                               this->cec.select));
>             break;
>          }
> 
>       case CEC_IOCTL_USER_CTRL_SELECT_AVINPUT_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.select,(unsigned char*)arg,sizeof(unsigned char)) != 0);
>             TRY(tmdlHdmiCecUserControlPressedSelectAVInput(this->cec.inst, \
>                                                            this->cec.initiator, \
>                                                            this->cec.select));
>             break;
>          }
> 
>       case CEC_IOCTL_USER_CTRL_SELECT_MEDIA_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.select,(unsigned char*)arg,sizeof(unsigned char)) != 0);
>             TRY(tmdlHdmiCecUserControlPressedSelectMedia(this->cec.inst, \
>                                                          this->cec.initiator, \
>                                                          this->cec.select));
>             break;
>          }
> 
>       case CEC_IOCTL_USER_CTRL_TUNE_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.user_ctrl_tune,(cec_user_ctrl_tune*)arg,sizeof(cec_user_ctrl_tune)) != 0);
>             TRY(tmdlHdmiCecUserControlPressedTune(this->cec.inst, \
>                                                   this->cec.initiator, \
>                                                   &this->cec.user_ctrl_tune));
>             break;
>          }
> 
>       case CEC_IOCTL_SET_OSD_NAME_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.osd_name,(cec_string*)arg,sizeof(cec_string)) != 0);
>             TRY(tmdlHdmiCecSetOsdName(this->cec.inst,      \
>                                       this->cec.initiator, \
>                                       this->cec.osd_name.data, \
>                                       this->cec.osd_name.length));
>             break;
>          }
> 
>       case CEC_IOCTL_SET_OSD_STRING_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.osd_string,(cec_osd_string*)arg,sizeof(cec_osd_string)) != 0);
>             TRY(tmdlHdmiCecSetOsdString(this->cec.inst, \
>                                         this->cec.initiator, \
>                                         this->cec.osd_string.DisplayControl, \
>                                         this->cec.osd_string.data, \
>                                         this->cec.osd_string.length));
>             break;
>          }
> 
>       case CEC_IOCTL_SET_TIMER_PROGRAM_TITLE_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.string,(cec_string*)arg,sizeof(cec_string)) != 0);
>             TRY(tmdlHdmiCecSetTimerProgramTitle(this->cec.inst, \
>                                                 this->cec.initiator, \
>                                                 this->cec.string.data, \
>                                                 this->cec.string.length));
>             break;
>          }
> 
>       case CEC_IOCTL_VENDOR_COMMAND_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.string,(cec_string*)arg,sizeof(cec_string)) != 0);
>             TRY(tmdlHdmiCecVendorCommand(this->cec.inst, \
>                                          this->cec.initiator, \
>                                          this->cec.string.data, \
>                                          this->cec.string.length));
>             break;
>          }
> 
>       case CEC_IOCTL_VENDOR_REMOTE_BUTTON_DOWN_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.string,(cec_string*)arg,sizeof(cec_string)) != 0);
>             TRY(tmdlHdmiCecVendorRemoteButtonDown(this->cec.inst, \
>                                                   this->cec.initiator, \
>                                                   this->cec.string.data, \
>                                                   this->cec.string.length));
>             break;
>          }
> 
>       case CEC_IOCTL_VENDOR_COMMAND_WITH_ID_CMD:
>          {
>             BUG_ON(copy_from_user(&this->cec.vcwi,(cec_vendor_command_with_id*)arg,sizeof(cec_vendor_command_with_id)) != 0);
>             TRY(tmdlHdmiCecVendorCommandWithID(this->cec.inst,	\
>                                                this->cec.initiator,	\
>                                                this->cec.vcwi.VendorID, \
>                                                this->cec.vcwi.cmd.data, \
>                                                this->cec.vcwi.cmd.length));
>             break;
>          }
> 
>          /*       case : */
>          /* 	 { */
>          /* 	    BUG_ON(copy_from_user(&this->cec.,(*)arg,sizeof()) != 0); */
>          /* 	    TRY((this->cec.inst, \ */
>          /* 		 this->cec.,	 \ */
>          /* 		 &this->cec.)); */
>          /* 	    break; */
>          /* 	 } */
> 
>       default:
>          {
>             /* unrecognized ioctl */	
>             printk(KERN_INFO " unknown ioctl %x\n",cmd);
>             up(&this->driver.sem);
>             return -ENOIOCTLCMD;
>          }
>       }
> 
>  TRY_DONE:
>    up(&this->driver.sem);
>    return err;
> }
> 
> /*
>  *  ioctl driver :: releasing
>  */
> static int this_cdev_release(struct inode *pInode, struct file *pFile)
> {
>    cec_instance* this = pFile->private_data;
>    int minor = iminor(pInode);
> 
>    LOG(KERN_INFO,"called\n");
> 
>    if(minor >= MAX_MINOR) {
>       return -EINVAL;
>    }
> 
>    BUG_ON(this->driver.minor!=iminor(pInode));
>    down(&this->driver.sem);
> 
>    this->driver.user_counter--;
>    if(this->driver.user_counter == 0) {
>       pFile->private_data = NULL;
>    }
>    else {
>       LOG(KERN_INFO,"Still %d user pending\n",this->driver.user_counter);
>    }
> 
>    up(&this->driver.sem);
>    return 0;
> }
> 
> /*
>  *  I2C client :: creation
>  */
> static int __devinit this_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
> {
>    cec_instance *this=&our_instance;
>    int err=0;
> 
>    LOG(KERN_INFO,"called\n");
> 
>    /*
>      I2C setup
>    */
>    if (this->driver.i2c_client) {
>       dev_err(&this->driver.i2c_client->dev, "<%s> CEC Device already created \n",
>               __func__);
>       return -ENODEV;
>    }
> 
>    this->driver.i2c_client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
>    if (!this->driver.i2c_client) {
>       return -ENOMEM;
>    }
>    memset(this->driver.i2c_client, 0, sizeof(struct i2c_client));
> 
>    strncpy(this->driver.i2c_client->name, CEC_NAME, I2C_NAME_SIZE);
>    this->driver.i2c_client->addr = TDA99XCEC_I2C_SLAVEADDRESS;
>    this->driver.i2c_client->adapter = client->adapter;
> 
>    i2c_set_clientdata(client, this->driver.i2c_client);
> 
>    tmdlHdmiCecGetSWVersion(&this->cec.sw_version);
>    LOG(KERN_INFO,"HDMI CEC SW Version:%lu.%lu compatibility:%lu\n", \
>        this->cec.sw_version.majorVersionNr,\
>        this->cec.sw_version.minorVersionNr,\
>        this->cec.sw_version.compatibilityNr);
> 
>    /* I2C ok, then let's startup CEC */
> 
>    /* prepare event */
>    this->driver.poll_done = true; /* currently idle */
>    init_waitqueue_head(&this->driver.wait);
> #ifndef IRQ
>    init_timer(&this->driver.timer); /* do it before request_irq */
>    this->driver.timer.function=polling_timeout;
>    this->driver.timer.data=0;
>    this->driver.timer.expires = jiffies + HZ; /* start polling in one sec */
>    add_timer(&this->driver.timer);
> #else
>    register_cec_interrupt((cec_callback_t)cec_interrupt);
> #endif
> 
> #ifndef IRQ
>    /* FRO calibration */
>    err=gpio_request(TDA_IRQ_CALIB,"tda19989 calibration");
>    if (err < 0) {
>       printk(KERN_ERR "hdmicec:%s:cannot use GPIO 107\n",__func__);
>       goto i2c_out;
>    }
>    /* turn GPIO into IRQ */
>    gpio_direction_input(TDA_IRQ_CALIB);
>    msleep(1);
>    if (request_irq(gpio_to_irq(TDA_IRQ_CALIB), \
>                    tda_irq, IRQF_TRIGGER_FALLING|IRQF_DISABLED, "TDA IRQ", NULL)) {
>       printk(KERN_ERR "hdmicec:%s:Cannot request irq, err:%d\n",__func__,err);
>       gpio_free(TDA_IRQ_CALIB);
>       goto i2c_out;
>    }
> #endif
> 
>    err = hdmi_cec_init(this);
>    if (err) goto i2c_out;
>    this->cec.rx_addr=CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
> 
>    if (get_hpd_status()) {
>       cec_on(this);
>       disable_irq(gpio_to_irq(TDA_IRQ_CALIB));
>       cec_interrupt(NULL); /* initiate polling */
>       enable_irq(gpio_to_irq(TDA_IRQ_CALIB));
>    }
>    else {
>       cec_standby(this);
>    }
> 
>    return 0;
> 
>  i2c_out:
>    LOG(KERN_INFO,"HDMICEC eject: this->driver.i2c_client removed\n");
>    tmdlHdmiCecClose(this->cec.inst);
>    kfree(this->driver.i2c_client);
>    this->driver.i2c_client = NULL;
> 
>    return err;
> }
> 
> /*
>  *  I2C client :: destroy
>  */
> static int this_i2c_remove(struct i2c_client *client)
> {
>    cec_instance *this=&our_instance;
>    int err=0;
> 
>    LOG(KERN_INFO,"called\n");
> 
>    err=tmdlHdmiCecClose(this->cec.inst);
> 
>    if (!client->adapter) {
>       dev_err(&this->driver.i2c_client->dev, "<%s> No CEC Device \n",
>               __func__);
>       return -ENODEV;
>    }
>    kfree(this->driver.i2c_client);
>    this->driver.i2c_client = NULL;
> 
>    return err;
> }
> 
> /*
>  *  I2C client driver (backend)
>  *  -----------------
>  */
> static struct i2c_driver this_i2c_driver = {
>    .driver = {
>       .owner = THIS_MODULE,
>       .name = CEC_NAME,
>    },
>    .probe = this_i2c_probe,
>    .remove = this_i2c_remove,
>    .id_table = this_i2c_id,
> };
> 
> /*
>  *  ioctl driver (userland frontend)
>  *  ------------
>  */
> static struct file_operations this_cdev_fops = {
>  owner:    THIS_MODULE,
>  open:     this_cdev_open,
>  release:  this_cdev_release,
>  ioctl:    this_cdev_ioctl,
> };
> 
> /*
>  *  Module :: start up
>  */
> static int __init cec_init(void)
> {
>    cec_instance *this=&our_instance;
>    dev_t dev=0;
>    int err=0;
> 
>    /* 
>       general device context
>    */
>    memset(this,0,sizeof(cec_instance));
>    this->param.verbose = param_verbose;
>    this->param.major = param_major;
>    this->param.minor = param_minor;
> 
>    /* Hello word */
>    printk(KERN_INFO "%s(%s) %d.%d.%d compiled: %s %s %s\n", HDMICEC_NAME, TDA_NAME, TDA_VERSION_MAJOR,
>           TDA_VERSION_MINOR, TDA_VERSION_PATCHLEVEL, __DATE__, __TIME__, TDA_VERSION_EXTRA);
>    if (this->param.verbose) LOG(KERN_INFO,".verbose mode\n");
> 
>    /*
>      plug I2C (backend : Hw interfacing)
>    */
>    err = i2c_add_driver(&this_i2c_driver);
>    if (err < 0) {
>       printk(KERN_ERR "Driver registration failed\n");
>       return -ENODEV;
>    }
> 
>    if (this->driver.i2c_client == NULL) {
>       printk(KERN_ERR "this->driver.i2c_client not allocated\n");
>       err = -ENODEV;
>       goto init_out;
>    }
> 
>    /*
>      cdev init (userland frontend)
>    */
> 
>    /* arbitray range of device numbers */
>    if (this->param.major) {
>       /* user force major number @ insmod */
>       dev = MKDEV(this->param.major, this->param.minor);
>       err = register_chrdev_region(dev,MAX_MINOR,HDMICEC_NAME);
>       if (err) {
>          printk(KERN_ERR "unable to register %s, dev=%d %s\n",HDMICEC_NAME,dev,ERR_TO_STR(err));
>          goto init_out;
>       }
>    } else {
>       /* fully dynamic major number */
>       err = alloc_chrdev_region(&dev, this->param.minor, MAX_MINOR,HDMICEC_NAME);
>       if (err) {
>          printk(KERN_ERR "unable to alloc chrdev region for %s, dev=%d %s\n",HDMICEC_NAME,dev,ERR_TO_STR(err));
>          goto init_out;
>       }
>       this->param.major = MAJOR(dev);
>    }
> 
>    cdev_init(this_cdev, &this_cdev_fops);
>    this_cdev->owner = THIS_MODULE;
> 
>    this->driver.class = class_create(THIS_MODULE, HDMICEC_NAME);
>    if (IS_ERR(this->driver.class)) {
>       printk(KERN_INFO "Error creating mmap device class.\n");
>       err =-EIO;
>       goto init_out;
>    }
>    this->driver.dev = device_create(this->driver.class, NULL, dev, NULL, HDMICEC_NAME);
> 
>    this->driver.devno = dev;
>    err = cdev_add(this_cdev, this->driver.devno, MAX_MINOR);
>    if (err){
>       printk(KERN_INFO "unable to add device for %s, ipp_driver.devno=%d %s\n",HDMICEC_NAME,this->driver.devno,ERR_TO_STR(err));
>       device_destroy(this->driver.class,this->driver.devno);
>       class_destroy(this->driver.class);
>       unregister_chrdev_region(this->driver.devno, MAX_MINOR);
>       goto init_out;
>    }   
> 
> #ifdef TWL4030_HACK
>    /* AL : hack to bypass keypad */
>    gkp_input = get_twm4030_input();
> #endif
> 
>    /* 
>       general device context
>    */
>    init_MUTEX(&this->driver.sem);
>    this->driver.deinit_req=0;
>    
>    return 0;
> 
>  init_out:
>    i2c_del_driver(&this_i2c_driver);
>    return err;
> }
> 
> /*
>  *  Module :: shut down
>  */
> static void __exit cec_exit(void)
> {
>    cec_instance *this=&our_instance;
>    
>    LOG(KERN_INFO,"called\n");
>    
> #ifndef IRQ
>    free_irq(gpio_to_irq(TDA_IRQ_CALIB), NULL);
> #endif
>    
>    unregister_cec_interrupt();
>    this->driver.deinit_req=1;
> #ifndef IRQ
>    if (wait_event_interruptible(this->driver.wait,this->driver.deinit_req>1)) {
>       /* oups... just wait... */
>       msleep(CHECK_EVERY_XX_MS*20);
>    }
> #endif
>    
> #ifndef IRQ
>    /* release GPIO */ 
>    gpio_free(TDA_IRQ_CALIB);
> #endif
> 
>    /* unregister cdevice */
>    cdev_del(this_cdev);
>    unregister_chrdev_region(this->driver.devno, MAX_MINOR);
> 
>    /* unregister device */
>    device_destroy(this->driver.class,this->driver.devno);
>    class_destroy(this->driver.class);
> 
>    /* unregister i2c */
>    i2c_del_driver(&this_i2c_driver);
> 
> }
> 
> 
> /*
>  *  Module
>  *  ------
>  */
> /* late_initcall(cec_init); */
> //[jaeseong.gim] module or built-in option
> #ifdef MODULE
> module_init(cec_init);
> #else
> late_initcall(cec_init);
> #endif
> module_exit(cec_exit);
> 
> /*
>  *  Disclamer
>  *  ---------
>  */
> MODULE_LICENSE("GPL");
> MODULE_AUTHOR("Andre Lepine <andre.lepine@nxp.com>");
> MODULE_DESCRIPTION(HDMICEC_NAME " driver");
diff ./tda998x_cec.h /home/jaeseong.gim/android/kernel/drivers/video/hdmi/tda998x_cec.h
1,139c1,140
< /*****************************************************************************/
< /* Copyright (c) 2009 NXP Semiconductors BV                                  */
< /*                                                                           */
< /* This program is free software; you can redistribute it and/or modify      */
< /* it under the terms of the GNU General Public License as published by      */
< /* the Free Software Foundation, using version 2 of the License.             */
< /*                                                                           */
< /* This program is distributed in the hope that it will be useful,           */
< /* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
< /* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              */
< /* GNU General Public License for more details.                              */
< /*                                                                           */
< /* You should have received a copy of the GNU General Public License         */
< /* along with this program; if not, write to the Free Software               */
< /* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307       */
< /* USA.                                                                      */
< /*                                                                           */
< /*****************************************************************************/
< 
< #ifndef __cec_h__
< #define __cec_h__
< 
< #include "tda998x_ioctl.h"
< 
< #define HDMICEC_NAME "hdmicec"
< 
< #define CEC_MAJOR 234 /* old-style interval of device numbers */
< #define MAX_MINOR 1 /* 1 minor but 2 access : 1 more for pooling */
< 
< /* common I2C define with kernel */
< /* should be the same as arch/arm/mach-omap2/board-zoom2.c */
< #define CEC_NAME "tda99Xcec"
< #define TDA99XCEC_I2C_SLAVEADDRESS 0x34
< 
< #define TDA_IRQ_CALIB 107
< #define POLLING_LENGTH 3
< 
< #define EDID_BLOCK_COUNT    4
< #define EDID_BLOCK_SIZE     128
< 
< #ifdef GPL
< #define CHECK_EVERY_XX_MS 500 /* ms */
< #else
< #define CHECK_EVERY_XX_MS 10 /* ms */
< #endif
< 
< #define LOG(type,fmt,args...) {if (this->param.verbose) {printk(type HDMICEC_NAME":%s:" fmt, __func__, ## args);}}
< /* not found the kernel "strerror" one! If someone knows, please replace it */
< #define ERR_TO_STR(e)((e == -ENODATA)?"ENODATA, no data available":\
<                       (e == -ENOMEM)? "ENOMEM, no memory available":\
<                       (e == -EINVAL)? "EINVAL, invalid argument":\
<                       (e == -EIO)? "EIO, input/output error":\
<                       (e == -ETIMEDOUT)? "ETIMEOUT, timeout has expired":\
<                       (e == -EBUSY)? "EBUSY, device or resource busy":\
<                       (e == -ENOENT)? "ENOENT, no such file or directory":\
<                       (e == -EACCES)? "EACCES, permission denied":\
<                       (e == 0)?       "":\
<                       "!UNKNOWN!")
< 
< #define TRY(fct) { \
<       err=(fct); \
<       if (err) { \
< 	 printk(KERN_ERR "%s? in %s line %d\n",hdmi_cec_err_string(err),__func__,__LINE__); \
< 	 goto TRY_DONE; \
<       } \
<    }
< 
< typedef void (*cec_callback_t) (struct work_struct *dummy);
< 
< typedef struct {
<    /* module params */
<    struct { 
<       int verbose;
<       int major;
<       int minor;
<    } param;
<    /* driver */
<    struct {
<       struct class *class;
<       struct device *dev;
<       int devno;
<       struct i2c_client *i2c_client;
<       struct semaphore sem;
<       int user_counter;
<       int minor;
<       wait_queue_head_t wait;
<       bool poll_done;
<       int deinit_req;
<       struct timer_list timer;
<    } driver;
<    /* cec */
<    struct {
<       int inst;
<       unsigned char rx_addr;
<       unsigned short phy_addr;
<       unsigned char initiator;
<       cec_version version;
<       cec_sw_version sw_version;
<       cec_power power;
<       cec_setup setup;
<       cec_clock clock;
<       cec_analogue_timer analog_timer;
<       cec_digital_timer digital_timer;
<       cec_ext_timer_with_ext_plug etwep;
<       cec_ext_timer_with_phy_addr etwpa;
<       cec_deck_ctrl deck_ctrl;
<       cec_deck_status deck_status;
<       unsigned long vendor_id;
<       cec_feature_abort feature_abort;
<       cec_status_request satus_request;
<       cec_menu_request menu_request;
<       cec_menu_status menu_status;
<       cec_play play;
<       cec_analogue_service analog_service;
<       cec_digital_service digital_service;
<       cec_ext_plug ext_plug;
<       cec_rec_status rec_status;
<       cec_audio_status audio_status;
<       cec_device_type device_type;
<       cec_power_status source_status;
<       cec_audio_rate audio_rate;
<       cec_sys_audio_status sys_audio_status;
<       cec_timer_cleared_status timer_cleared_status;
<       cec_timer_status timer_status;
<       cec_tuner_device_status_analogue tdsa;
<       cec_tuner_device_status_digital tdsd;
<       cec_user_ctrl user_ctrl;
<       unsigned char select;
<       cec_user_ctrl_tune user_ctrl_tune;
<       cec_frame frame;
<       bool byebye;
<       cec_string string;
<       cec_string osd_name;
<       cec_osd_string osd_string;
<       cec_vendor_command_with_id vcwi;
<    } cec;
< } cec_instance;
< 
< #endif /* __cec_h__ */
---
> /*****************************************************************************/
> /* Copyright (c) 2009 NXP Semiconductors BV                                  */
> /*                                                                           */
> /* This program is free software; you can redistribute it and/or modify      */
> /* it under the terms of the GNU General Public License as published by      */
> /* the Free Software Foundation, using version 2 of the License.             */
> /*                                                                           */
> /* This program is distributed in the hope that it will be useful,           */
> /* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
> /* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              */
> /* GNU General Public License for more details.                              */
> /*                                                                           */
> /* You should have received a copy of the GNU General Public License         */
> /* along with this program; if not, write to the Free Software               */
> /* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307       */
> /* USA.                                                                      */
> /*                                                                           */
> /*****************************************************************************/
> 
> #ifndef __cec_h__
> #define __cec_h__
> 
> #include "tda998x_ioctl.h"
> 
> #define HDMICEC_NAME "hdmicec"
> 
> #define CEC_MAJOR 234 /* old-style interval of device numbers */
> #define MAX_MINOR 1 /* 1 minor but 2 access : 1 more for pooling */
> 
> /* common I2C define with kernel */
> /* should be the same as arch/arm/mach-omap2/board-zoom2.c */
> #define CEC_NAME "tda99Xcec"
> #define TDA99XCEC_I2C_SLAVEADDRESS 0x34
> 
> //[jaeseong.gim] 107->104
> #define TDA_IRQ_CALIB 104
> #define POLLING_LENGTH 3
> 
> #define EDID_BLOCK_COUNT    4
> #define EDID_BLOCK_SIZE     128
> 
> #ifdef GPL
> #define CHECK_EVERY_XX_MS 500 /* ms */
> #else
> #define CHECK_EVERY_XX_MS 10 /* ms */
> #endif
> 
> #define LOG(type,fmt,args...) {if (this->param.verbose) {printk(type HDMICEC_NAME":%s:" fmt, __func__, ## args);}}
> /* not found the kernel "strerror" one! If someone knows, please replace it */
> #define ERR_TO_STR(e)((e == -ENODATA)?"ENODATA, no data available":\
>                       (e == -ENOMEM)? "ENOMEM, no memory available":\
>                       (e == -EINVAL)? "EINVAL, invalid argument":\
>                       (e == -EIO)? "EIO, input/output error":\
>                       (e == -ETIMEDOUT)? "ETIMEOUT, timeout has expired":\
>                       (e == -EBUSY)? "EBUSY, device or resource busy":\
>                       (e == -ENOENT)? "ENOENT, no such file or directory":\
>                       (e == -EACCES)? "EACCES, permission denied":\
>                       (e == 0)?       "":\
>                       "!UNKNOWN!")
> 
> #define TRY(fct) { \
>       err=(fct); \
>       if (err) { \
> 	 printk(KERN_ERR "%s? in %s line %d\n",hdmi_cec_err_string(err),__func__,__LINE__); \
> 	 goto TRY_DONE; \
>       } \
>    }
> 
> typedef void (*cec_callback_t) (struct work_struct *dummy);
> 
> typedef struct {
>    /* module params */
>    struct { 
>       int verbose;
>       int major;
>       int minor;
>    } param;
>    /* driver */
>    struct {
>       struct class *class;
>       struct device *dev;
>       int devno;
>       struct i2c_client *i2c_client;
>       struct semaphore sem;
>       int user_counter;
>       int minor;
>       wait_queue_head_t wait;
>       bool poll_done;
>       int deinit_req;
>       struct timer_list timer;
>    } driver;
>    /* cec */
>    struct {
>       int inst;
>       unsigned char rx_addr;
>       unsigned short phy_addr;
>       unsigned char initiator;
>       cec_version version;
>       cec_sw_version sw_version;
>       cec_power power;
>       cec_setup setup;
>       cec_clock clock;
>       cec_analogue_timer analog_timer;
>       cec_digital_timer digital_timer;
>       cec_ext_timer_with_ext_plug etwep;
>       cec_ext_timer_with_phy_addr etwpa;
>       cec_deck_ctrl deck_ctrl;
>       cec_deck_status deck_status;
>       unsigned long vendor_id;
>       cec_feature_abort feature_abort;
>       cec_status_request satus_request;
>       cec_menu_request menu_request;
>       cec_menu_status menu_status;
>       cec_play play;
>       cec_analogue_service analog_service;
>       cec_digital_service digital_service;
>       cec_ext_plug ext_plug;
>       cec_rec_status rec_status;
>       cec_audio_status audio_status;
>       cec_device_type device_type;
>       cec_power_status source_status;
>       cec_audio_rate audio_rate;
>       cec_sys_audio_status sys_audio_status;
>       cec_timer_cleared_status timer_cleared_status;
>       cec_timer_status timer_status;
>       cec_tuner_device_status_analogue tdsa;
>       cec_tuner_device_status_digital tdsd;
>       cec_user_ctrl user_ctrl;
>       unsigned char select;
>       cec_user_ctrl_tune user_ctrl_tune;
>       cec_frame frame;
>       bool byebye;
>       cec_string string;
>       cec_string osd_name;
>       cec_osd_string osd_string;
>       cec_vendor_command_with_id vcwi;
>    } cec;
> } cec_instance;
> 
> #endif /* __cec_h__ */
diff ./tda998x_ioctl.h /home/jaeseong.gim/android/kernel/drivers/video/hdmi/tda998x_ioctl.h
1,1121c1,1119
< /**
<  * Copyright (C) 2006 NXP N.V., All Rights Reserved.
<  * This source code and any compilation or derivative thereof is the proprietary
<  * information of NXP N.V. and is confidential in nature. Under no circumstances
<  * is this software to be  exposed to or placed under an Open Source License of
<  * any type without the expressed written permission of NXP N.V.
<  *
<  * Version       Revision: 1.0
<  *
<  * Date          Date: 27/10/09
<  *
<  * Brief         API for the TDA1998x HDMI Transmitters
<  *
<  **/
< 
< #include <linux/types.h>
< 
< #ifndef __tx_ioctl__
< #define __tx_ioctl__
< 
< #ifdef __tx_h__
< 
< #define TRANS_TYPE 1
< 
< #if TRANS_TYPE
< 
< #define EXAMPLE_MAX_SVD 30
< 
< /*
<   trans-type
< */
< typedef tmSWVersion_t tda_version;
< typedef tmPowerState_t tda_power;
< typedef tmdlHdmiTxInstanceSetupInfo_t tda_setup;
< typedef tmdlHdmiTxCapabilities_t tda_capabilities;
< typedef tmdlHdmiTxVideoOutConfig_t tda_video_out;
< typedef tmdlHdmiTxVideoInConfig_t tda_video_in;
< typedef tmdlHdmiTxSinkType_t tda_sink;
< typedef tmdlHdmiTxAudioInConfig_t tda_audio_in;
< typedef tmdlHdmiTxEdidAudioDesc_t tda_edid_audio_desc;
< typedef tmdlHdmiTxShortVidDesc_t tda_edid_video_desc;
< typedef tmdlHdmiTxEvent_t tda_event;
< typedef tmdlHdmiTxInstanceSetupInfo_t tda_setup_info;
< typedef tmdlHdmiTxEdidVideoTimings_t tda_edid_video_timings;
< typedef tmdlHdmiTxPictAspectRatio_t tda_edid_tv_aspect_ratio;
< typedef tmdlHdmiTxHdcpCheck_t tda_hdcp_status;
< #if defined (TMFL_TDA19989) || defined (TMFL_TDA9984) 
< typedef tmdlHdmiTxHdcpStatus_t tda_hdcp_fail;
< #endif
< #ifdef TMFL_TDA19989
< typedef tmdlHdmiTxEdidLatency_t tda_edid_latency;
< #endif
< 
< typedef struct {
<    Bool enable;
<    tmdlHdmiTxGamutData_t data;
< } tda_gammut;
< 
< typedef struct {
<    Bool enable;
<    tmdlHdmiTxVsPktData_t data;
< } tda_vs_infoframe;
< 
< typedef struct {
<    Bool enable;
<    tmdlHdmiTxSpdIfData_t data;
< } tda_spd_infoframe;
< 
< typedef struct {
<    Bool enable;
<    tmdlHdmiTxMpsIfData_t data;
< } tda_mps_infoframe;
< 
< typedef struct {
<    Bool enable;
<    tmdlHdmiTxIsrc1PktData_t data;
< } tda_isrc1;
< 
< typedef struct {
<    Bool enable;
<    tmdlHdmiTxIsrc2PktData_t data;
< } tda_isrc2;
< 
< typedef struct {
<    Bool enable;
<    tmdlHdmiTxAcpPktData_t data;
< } tda_acp;
< 
< typedef struct {
<    Bool enable;
<    tmdlHdmiTxGcpPktData_t data;
< } tda_gcp;
< 
< typedef struct {
<    Bool enable;
<    tmdlHdmiTxAviIfData_t data;
< } tda_video_infoframe;
< 
< typedef struct {
<    Bool enable;
<    tmdlHdmiTxAudIfData_t data;
< } tda_audio_infoframe;
< 
< typedef struct {
<    tmdlHdmiTxVidFmt_t id;
<    tmdlHdmiTxVidFmtSpecs_t spec;
< } tda_video_format;
< 
< typedef struct {
<    tda_video_in video_in;
<    tda_video_out video_out;
<    tda_audio_in audio_in; /* Mind tda_set_audio_in if you change this */
<    tda_sink sink; /* Mind tda_set_audio_in if you change this */
< } tda_set_in_out;
< 
< typedef struct {
<    tda_audio_in audio_in;
<    tda_sink sink;
< } tda_set_audio_in;
< 
< typedef struct {
<    tda_edid_audio_desc desc[EXAMPLE_MAX_SVD];
<    unsigned int max;
<    unsigned int written;
<    unsigned char flags;
< } tda_edid_audio_caps;
< 
< typedef struct {
<    tda_edid_video_desc desc[EXAMPLE_MAX_SVD];
<    unsigned int max;
<    unsigned int written;
<    unsigned char flags;
< } tda_edid_video_caps;
< 
< typedef struct {
<    tmdlHdmiTxEdidStatus_t status;
<    unsigned char block_count;
< } tda_edid;
< 
< typedef struct {
<    tmdlHdmiTxEdidVideoTimings_t desc[EXAMPLE_MAX_SVD];
<    unsigned char max;
<    unsigned char written;
< } tda_edid_dtd;
< 
< typedef struct {
<    tmdlHdmiTxEdidFirstMD_t desc1[EXAMPLE_MAX_SVD];
<    tmdlHdmiTxEdidSecondMD_t desc2[EXAMPLE_MAX_SVD];
<    tmdlHdmiTxEdidOtherMD_t other[EXAMPLE_MAX_SVD];
<    unsigned char max;
<    unsigned char written;
< } tda_edid_md;
< 
< #else 
< 
< #error do not compiled this !
< 
< typedef enum
< {
<     TDA_HDCP_ACTIVE         = 0,    /**< HDCP encryption status switched to active */
<     TDA_HDCP_INACTIVE       = 1,    /**< HDCP encryption status switched to inactive */
<     TDA_HPD_ACTIVE          = 2,    /**< Hotplug status switched to active */
<     TDA_HPD_INACTIVE        = 3,    /**< Hotplug status switched to inactive */
<     TDA_RX_KEYS_RECEIVED    = 4,    /**< Receiver(s) key(s) received */
<     TDA_RX_DEVICE_ACTIVE    = 5,    /**< Rx device is connected and active */
<     TDA_RX_DEVICE_INACTIVE  = 6,    /**< Rx device is connected but inactive (standby) */
<     TDA_EDID_RECEIVED       = 7,    /**< EDID has been received */
<     TDA_VS_RPT_RECEIVED     = 8,    /**< VS interrupt has been received */              
< #ifdef HDMI_TX_REPEATER_ISR_MODE
<     TDA_B_STATUS            = 9,    /**< TX received BStatus */
< #endif /* HDMI_TX_REPEATER_ISR_MODE */
<     TDA_DEBUG_EVENT_1       = 10     /**< This is a debug event */
< } tda_event;
< 
< typedef struct {
<     unsigned char format;         /* EIA/CEA861 mode */
<     unsigned char channels;       /* number of channels */
<     unsigned char supportedFreqs; /* bitmask of supported frequencies */
<     unsigned char supportedRes;   /* bitmask of supported resolutions (LPCM only) */
<     unsigned char maxBitrate;     /* Maximum bitrate divided by 8KHz (compressed formats only) */
< } tda_edid_audio_desc;
< 
< typedef enum {
<     TDA_EDID_READ                = 0,   /**< All blocks read OK */
<     TDA_EDID_READ_INCOMPLETE     = 1,   /**< All blocks read OK but buffer too small to return all of them */
<     TDA_EDID_ERROR_CHK_BLOCK_0   = 2,   /**< Block 0 checksum error */
<     TDA_EDID_ERROR_CHK           = 3,   /**< Block 0 OK, checksum error in one or more other blocks */
<     TDA_EDID_NOT_READ            = 4,   /**< EDID not read */
<     TDA_EDID_STATUS_INVALID      = 5    /**< Invalid   */
< } tda_edid_status;
< 
< typedef struct {
<    int HBR;              /**< High Bitrate Audio packet */
<    int DST;              /**< Direct Stream Transport audio packet */
<    int oneBitAudio;      /**< One Bit Audio sample packet */
< } tda_audio_packet;
< 
< typedef enum {
<     TDA_AFMT_SPDIF      = 0, /**< SPDIF */
<     TDA_AFMT_I2S        = 1, /**< I2S */
<     TDA_AFMT_OBA        = 2, /**< One bit audio / DSD */
<     TDA_AFMT_DST        = 3, /**< DST */
<     TDA_AFMT_HBR        = 4  /**< HBR */
< } tda_audio_format;
< 
< typedef enum {
<     TDA_AFS_32K           = 0, /**< 32kHz    */
<     TDA_AFS_44K           = 1, /**< 44.1kHz  */
<     TDA_AFS_48K           = 2, /**< 48kHz    */
<     TDA_AFS_88K           = 3, /**< 88.2kHz  */
<     TDA_AFS_96K           = 4, /**< 96kHz    */
<     TDA_AFS_176K          = 5, /**< 176.4kHz */
<     TDA_AFS_192K          = 6  /**< 192kHz   */
< } tda_audio_rate;
< 
< typedef enum {
<     TDA_I2SQ_16BITS       = 16, /**< 16 bits */
<     TDA_I2SQ_32BITS       = 32, /**< 32 bits */
<     TDA_I2SQ_OTHERS       = 0   /**< for SPDIF and DSD */
< } tda_audio_I2S_qualifier;
< 
< typedef enum {
<     TDA_I2SFOR_PHILIPS_L   = 0,	/**< Philips like format */
<     TDA_I2SFOR_OTH_L       = 2,	/**< Other non Philips left justified */
<     TDA_I2SFOR_OTH_R	   = 3,	/**< Other non Philips right justified */
<     TDA_I2SFOR_INVALID     = 4	/**< Invalid format */
< } tda_audio_I2S_format;
< 
< typedef enum {
<     TDA_DSTRATE_SINGLE  = 0,    /**< Single transfer rate */
<     TDA_DSTRATE_DOUBLE  = 1     /**< Double data rate */
< } tda_dst_rate;
< 
< typedef struct {
<     int    simplayHd;          /**< Enable simplayHD support */
<     int    repeaterEnable;     /**< Enable repeater mode */
<     unsigned char   *pEdidBuffer;       /**< Pointer to raw EDID data */
<     unsigned long  edidBufferSize;     /**< Size of buffer for raw EDID data */
< } tda_instance_setup_info;
< 
< typedef enum {
<     TDA_VFMT_NULL               = 0,    /**< Not a valid format...        */
<     TDA_VFMT_NO_CHANGE          = 0,    /**< ...or no change required     */
<     TDA_VFMT_MIN                = 1,    /**< Lowest valid format          */
<     TDA_VFMT_TV_MIN             = 1,    /**< Lowest valid TV format       */
<     TDA_VFMT_01_640x480p_60Hz   = 1,    /**< Format 01 640  x 480p  60Hz  */
<     TDA_VFMT_02_720x480p_60Hz   = 2,    /**< Format 02 720  x 480p  60Hz  */
<     TDA_VFMT_03_720x480p_60Hz   = 3,    /**< Format 03 720  x 480p  60Hz  */
<     TDA_VFMT_04_1280x720p_60Hz  = 4,    /**< Format 04 1280 x 720p  60Hz  */
<     TDA_VFMT_05_1920x1080i_60Hz = 5,    /**< Format 05 1920 x 1080i 60Hz  */
<     TDA_VFMT_06_720x480i_60Hz   = 6,    /**< Format 06 720  x 480i  60Hz  */
<     TDA_VFMT_07_720x480i_60Hz   = 7,    /**< Format 07 720  x 480i  60Hz  */
<     TDA_VFMT_08_720x240p_60Hz   = 8,    /**< Format 08 720  x 240p  60Hz  */
<     TDA_VFMT_09_720x240p_60Hz   = 9,    /**< Format 09 720  x 240p  60Hz  */
<     TDA_VFMT_10_720x480i_60Hz   = 10,   /**< Format 10 720  x 480i  60Hz  */
<     TDA_VFMT_11_720x480i_60Hz   = 11,   /**< Format 11 720  x 480i  60Hz  */
<     TDA_VFMT_12_720x240p_60Hz   = 12,   /**< Format 12 720  x 240p  60Hz  */
<     TDA_VFMT_13_720x240p_60Hz   = 13,   /**< Format 13 720  x 240p  60Hz  */
<     TDA_VFMT_14_1440x480p_60Hz  = 14,   /**< Format 14 1440 x 480p  60Hz  */
<     TDA_VFMT_15_1440x480p_60Hz  = 15,   /**< Format 15 1440 x 480p  60Hz  */
<     TDA_VFMT_16_1920x1080p_60Hz = 16,   /**< Format 16 1920 x 1080p 60Hz  */
<     TDA_VFMT_17_720x576p_50Hz   = 17,   /**< Format 17 720  x 576p  50Hz  */
<     TDA_VFMT_18_720x576p_50Hz   = 18,   /**< Format 18 720  x 576p  50Hz  */
<     TDA_VFMT_19_1280x720p_50Hz  = 19,   /**< Format 19 1280 x 720p  50Hz  */
<     TDA_VFMT_20_1920x1080i_50Hz = 20,   /**< Format 20 1920 x 1080i 50Hz  */
<     TDA_VFMT_21_720x576i_50Hz   = 21,   /**< Format 21 720  x 576i  50Hz  */
<     TDA_VFMT_22_720x576i_50Hz   = 22,   /**< Format 22 720  x 576i  50Hz  */
<     TDA_VFMT_23_720x288p_50Hz   = 23,   /**< Format 23 720  x 288p  50Hz  */
<     TDA_VFMT_24_720x288p_50Hz   = 24,   /**< Format 24 720  x 288p  50Hz  */
<     TDA_VFMT_25_720x576i_50Hz   = 25,   /**< Format 25 720  x 576i  50Hz  */
<     TDA_VFMT_26_720x576i_50Hz   = 26,   /**< Format 26 720  x 576i  50Hz  */
<     TDA_VFMT_27_720x288p_50Hz   = 27,   /**< Format 27 720  x 288p  50Hz  */
<     TDA_VFMT_28_720x288p_50Hz   = 28,   /**< Format 28 720  x 288p  50Hz  */
<     TDA_VFMT_29_1440x576p_50Hz  = 29,   /**< Format 29 1440 x 576p  50Hz  */
<     TDA_VFMT_30_1440x576p_50Hz  = 30,   /**< Format 30 1440 x 576p  50Hz  */
<     TDA_VFMT_31_1920x1080p_50Hz = 31,   /**< Format 31 1920 x 1080p 50Hz  */
<     TDA_VFMT_32_1920x1080p_24Hz = 32,   /**< Format 32 1920 x 1080p 24Hz  */
<     TDA_VFMT_33_1920x1080p_25Hz = 33,   /**< Format 33 1920 x 1080p 25Hz  */
<     TDA_VFMT_34_1920x1080p_30Hz = 34,   /**< Format 34 1920 x 1080p 30Hz  */
<     TDA_VFMT_TV_MAX             = 34,   /**< Highest valid TV format      */
<     TDA_VFMT_TV_NO_REG_MIN      = 32,   /**< Lowest TV format without prefetched table */
<     TDA_VFMT_TV_NUM             = 35,   /**< Number of TV formats & null  */
<     TDA_VFMT_PC_MIN             = 128,  /**< Lowest valid PC format       */
<     TDA_VFMT_PC_640x480p_60Hz   = 128,  /**< PC format 128                */
<     TDA_VFMT_PC_800x600p_60Hz   = 129,  /**< PC format 129                */
<     TDA_VFMT_PC_1152x960p_60Hz  = 130,  /**< PC format 130                */
<     TDA_VFMT_PC_1024x768p_60Hz  = 131,  /**< PC format 131                */
<     TDA_VFMT_PC_1280x768p_60Hz  = 132,  /**< PC format 132                */
<     TDA_VFMT_PC_1280x1024p_60Hz = 133,  /**< PC format 133                */
<     TDA_VFMT_PC_1360x768p_60Hz  = 134,  /**< PC format 134                */
<     TDA_VFMT_PC_1400x1050p_60Hz = 135,  /**< PC format 135                */
<     TDA_VFMT_PC_1600x1200p_60Hz = 136,  /**< PC format 136                */
<     TDA_VFMT_PC_1024x768p_70Hz  = 137,  /**< PC format 137                */
<     TDA_VFMT_PC_640x480p_72Hz   = 138,  /**< PC format 138                */
<     TDA_VFMT_PC_800x600p_72Hz   = 139,  /**< PC format 139                */
<     TDA_VFMT_PC_640x480p_75Hz   = 140,  /**< PC format 140                */
<     TDA_VFMT_PC_1024x768p_75Hz  = 141,  /**< PC format 141                */
<     TDA_VFMT_PC_800x600p_75Hz   = 142,  /**< PC format 142                */
<     TDA_VFMT_PC_1024x864p_75Hz  = 143,  /**< PC format 143                */
<     TDA_VFMT_PC_1280x1024p_75Hz = 144,  /**< PC format 144                */
<     TDA_VFMT_PC_640x350p_85Hz   = 145,  /**< PC format 145                */
<     TDA_VFMT_PC_640x400p_85Hz   = 146,  /**< PC format 146                */
<     TDA_VFMT_PC_720x400p_85Hz   = 147,  /**< PC format 147                */
<     TDA_VFMT_PC_640x480p_85Hz   = 148,  /**< PC format 148                */
<     TDA_VFMT_PC_800x600p_85Hz   = 149,  /**< PC format 149                */
<     TDA_VFMT_PC_1024x768p_85Hz  = 150,  /**< PC format 150                */
<     TDA_VFMT_PC_1152x864p_85Hz  = 151,  /**< PC format 151                */
<     TDA_VFMT_PC_1280x960p_85Hz  = 152,  /**< PC format 152                */
<     TDA_VFMT_PC_1280x1024p_85Hz = 153,  /**< PC format 153                */
<     TDA_VFMT_PC_1024x768i_87Hz  = 154,  /**< PC format 154                */
<     TDA_VFMT_PC_MAX             = 154,  /**< Highest valid PC format      */
<     TDA_VFMT_PC_NUM             = (1+154-128)   /**< Number of PC formats         */
< } tda_video_fmt_id;
< 
< typedef struct {
<     tda_video_fmt_id videoFormat;            /**< Video format as defined by EIA/CEA 861-D */
<     int              nativeVideoFormat;   /**< True if format is the preferred video format */
< } tda_edid_video_desc;
< 
< typedef struct {
<     tda_video_fmt_id videoFormat;            /**< Video format as defined by EIA/CEA 861-D */
<     int              nativeVideoFormat;   /**< True if format is the preferred video format */
< } tda_short_video_desc;
< 
< typedef enum {
<     TDA_P_ASPECT_RATIO_UNDEFINED    = 0,    /**< Undefined picture aspect ratio */
<     TDA_P_ASPECT_RATIO_6_5          = 1,    /**< 6:5 picture aspect ratio (PAR) */
<     TDA_P_ASPECT_RATIO_5_4          = 2,    /**< 5:4 PAR */
<     TDA_P_ASPECT_RATIO_4_3          = 3,    /**< 4:3 PAR */
<     TDA_P_ASPECT_RATIO_16_10        = 4,    /**< 16:10 PAR */
<     TDA_P_ASPECT_RATIO_5_3          = 5,    /**< 5:3 PAR */
<     TDA_P_ASPECT_RATIO_16_9         = 6,    /**< 16:9 PAR */
<     TDA_P_ASPECT_RATIO_9_5          = 7     /**< 9:5 PAR */
< } tda_pict_aspect_ratio;
< 
< typedef enum {
<     TDA_VFREQ_24Hz      = 0,    /**< 24Hz          */
<     TDA_VFREQ_25Hz      = 1,    /**< 25Hz          */
<     TDA_VFREQ_30Hz      = 2,    /**< 30Hz          */
<     TDA_VFREQ_50Hz      = 3,    /**< 50Hz          */
<     TDA_VFREQ_59Hz      = 4,    /**< 59.94Hz       */
<     TDA_VFREQ_60Hz      = 5,    /**< 60Hz          */
<     TDA_VFREQ_70Hz      = 6,    /**< 70Hz          */
<     TDA_VFREQ_72Hz      = 7,    /**< 72Hz          */
<     TDA_VFREQ_75Hz      = 8,    /**< 75Hz          */
<     TDA_VFREQ_85Hz      = 9,    /**< 85Hz          */
<     TDA_VFREQ_87Hz      = 10,   /**< 87Hz          */
<     TDA_VFREQ_INVALID   = 11,   /**< Invalid       */
<     TDA_VFREQ_NUM       = 11    /**< No. of values */
< } tda_vfreq;
< 
< typedef struct {
<     unsigned short                      width;         /**< Width of the frame in pixels */
<     unsigned short                      height;        /**< Height of the frame in pixels */
<     int                        interlaced;    /**< Interlaced mode (True/False) */
<     tda_vfreq           vfrequency;    /**< Vertical frequency in Hz */
<     tda_pict_aspect_ratio aspectRatio;   /**< Picture aspect ratio (H:V) */
< } tda_video_fmt_specs;
< 
< typedef enum {
<     TDA_VINMODE_CCIR656     = 0,    /**< CCIR656 */
<     TDA_VINMODE_RGB444      = 1,    /**< RGB444  */
<     TDA_VINMODE_YUV444      = 2,    /**< YUV444  */
<     TDA_VINMODE_YUV422      = 3,    /**< YUV422  */
<     TDA_VINMODE_NO_CHANGE   = 4,    /**< No change */
<     TDA_VINMODE_INVALID     = 5     /**< Invalid */
< } tda_vinmode;
< 
< typedef enum {
<     TDA_SYNCSRC_EMBEDDED = 0, /**< Embedded sync */
<     TDA_SYNCSRC_EXT_VREF = 1, /**< External sync Vref, Href, Fref */
<     TDA_SYNCSRC_EXT_VS   = 2  /**< External sync Vs, Hs */
< } tda_sync_source;
< 
< typedef enum {
<     TDA_PIXRATE_DOUBLE          = 0,        /**< Double pixel rate */
<     TDA_PIXRATE_SINGLE          = 1,        /**< Single pixel rate */
<     TDA_PIXRATE_SINGLE_REPEATED = 2         /**< Single pixel repeated */
< } tda_pix_rate;
< 
< typedef struct {
<    tda_video_fmt_id       format;     /**< Video format as defined by EIA/CEA 861-D */
<    tda_vinmode      mode;       /**< Video mode (CCIR, RGB, YUV, etc.) */
<    tda_sync_source   syncSource; /**< Sync source type */
<    tda_pix_rate      pixelRate;  /**< Pixel rate */
< } tda_video_in;
< 
< typedef enum {
<     TDA_VOUTMODE_RGB444     = 0,    /**< RGB444    */
<     TDA_VOUTMODE_YUV422     = 1,    /**< YUV422    */
<     TDA_VOUTMODE_YUV444     = 2     /**< YUV444    */
< } tda_vout_mode;
< 
< typedef enum {
<     TDA_VQR_DEFAULT = 0, /* Follow HDMI spec. */
<     TDA_RGB_FULL    = 1, /* Force RGB FULL , DVI only */
<     TDA_RGB_LIMITED = 2  /* Force RGB LIMITED , DVI only */
< } tda_vqr;
< 
< typedef enum {
<     TDA_COLORDEPTH_24   = 0,    /**< 8 bits per color */
<     TDA_COLORDEPTH_30   = 1,    /**< 10 bits per color */
<     TDA_COLORDEPTH_36   = 2,    /**< 12 bits per color */
<     TDA_COLORDEPTH_48   = 3     /**< 16 bits per color */
< } tda_color_depth;
< 
< typedef struct {
<    tda_video_fmt_id       format;     /**< Video format as defined by EIA/CEA 861-D */
<    tda_vout_mode     mode;       /**< Video mode (CCIR, RGB, YUV, etc.) */
<    tda_color_depth  colorDepth; /**< Color depth */
<    tda_vqr          dviVqr;     /**< VQR applied in DVI mode */ 
< } tda_video_out;
< 
< typedef struct {
<    tda_audio_format          format;             /**< Audio format (I2S, SPDIF, etc.) */
<    tda_audio_rate            rate;               /**< Audio sampling rate */
<    tda_audio_I2S_format       i2sFormat;          /**< I2S format of the audio input */
<    tda_audio_I2S_qualifier    i2sQualifier;       /**< I2S qualifier of the audio input (8,16,32 bits) */
<    tda_dst_rate              dstRate;            /**< DST data transfer rate */
<    unsigned char                            channelAllocation;  /**< Ref to CEA-861D p85 */
< } tda_audio_in;
< 
< typedef enum {
<     TDA_SINK_DVI  = 0, /**< DVI  */
<     TDA_SINK_HDMI = 1, /**< HDMI */
<     TDA_SINK_EDID = 2  /**< As currently defined in EDID */
< } tda_sink;
< 
<  typedef enum {
<      TDA_DEVICE_UNKNOWN,   /**< HW device is unknown */
<      TDA_DEVICE_TDA9984,   /**< HW device is IC TDA9984 */
<      TDA_DEVICE_TDA9989,   /**< HW device is IC TDA9989 */
<      TDA_DEVICE_TDA9981,   /**< HW device is IC TDA9981 */
<      TDA_DEVICE_TDA9983,   /**< HW device is IC TDA9983 */
<      TDA_DEVICE_TDA19989   /**< HW device is IC TDA19989 */
<  } tda_device_version;
< 
< typedef enum {
<    TDA_HDMI_VERSION_UNKNOWN, /**< Unknown   */
<    TDA_HDMI_VERSION_1_1,     /**< HDMI 1.1  */
<    TDA_HDMI_VERSION_1_2a,    /**< HDMI 1.2a */
<    TDA_HDMI_VERSION_1_3a     /**< HDMI 1.3  */
< } tda_hdmi_version;
<  
< typedef struct {
<    int HBR;              /**< High Bitrate Audio packet */
<    int DST;              /**< Direct Stream Transport audio packet */
<    int oneBitAudio;      /**< One Bit Audio sample packet */
< } tda_audio_packet;
< 
< typedef enum {
<     TDA_COLORDEPTH_24   = 0,    /**< 8 bits per color */
<     TDA_COLORDEPTH_30   = 1,    /**< 10 bits per color */
<     TDA_COLORDEPTH_36   = 2,    /**< 12 bits per color */
<     TDA_COLORDEPTH_48   = 3     /**< 16 bits per color */
< } tda_color_depth;
< 
< typedef struct {
<     tda_device_version deviceVersion;  /**< HW device version */
<     tda_hdmi_version hdmiVersion;    /**< Supported HDMI standard version  */
<     tda_audio_packet audioPacket;    /**< Supported audio packets */
<     tda_color_depth colorDepth;     /**< Supported color depth */
<     int hdcp;           /**< Supported Hdcp encryption (True/False) */
<    int scaler;         /**< Supported scaler (True/False) */
< } tda_capabilities;
< 
< typedef struct {
<     unsigned long compatibilityNr;        // Interface compatibility number
<     unsigned long majorVersionNr;         // Interface major version number
<     unsigned long minorVersionNr;         // Interface minor version number
< } tda_version;
< 
< typedef enum
< {
<     PowerOn,                          // Device powered on      (D0 state)
<     PowerStandby,                     // Device power standby   (D1 state)
<     PowerSuspend,                     // Device power suspended (D2 state)
<     PowerOff                          // Device powered off     (D3 state)
< } tda_powerXXX;
< 
< typedef struct {
<     unsigned int simplayHd;          /**< Enable simplayHD support */
<     unsigned int repeaterEnable;     /**< Enable repeater mode */
<     unsigned char *pEdidBuffer;       /**< Pointer to raw EDID data */
<     unsigned long edidBufferSize;     /**< Size of buffer for raw EDID data */
< } tda_setup;
< 
< typedef struct {
<    tda_video_fmt_id id;
<    tda_video_fmt_specs spec;
< } tda_video_format;
< 
< typedef struct {
<    tda_video_in video_in;
<    tda_video_out video_out;
<    tda_audio_in audio_in;
< } tda_set_in_out;
< 
< typedef struct {
<    tda_edid_audio_desc desc;
<    unsigned int max;
<    unsigned int written;
<    unsigned char flags;
< } tda_edid_audio_caps;
< 
< typedef struct {
<    tda_edid_video_desc desc;
<    unsigned int max;
<    unsigned int written;
<    unsigned char flags;
< } tda_edid_video_caps;
< 
< typedef struct {
<    tda_edid_status status;
<    unsigned char block_count;
< } tda_edid;
< 
< #endif
< 
< #define TDA_IOCTL_BASE 0x40
< #define RELEASE 0xFF
< 
< enum {
<    /* driver specific */
<    TDA_VERBOSE_ON_CMD = 0,
<    TDA_VERBOSE_OFF_CMD,
<    TDA_BYEBYE_CMD,
<    /* HDMI Tx */
<    TDA_GET_SW_VERSION_CMD,
<    TDA_SET_POWER_CMD,
<    TDA_GET_POWER_CMD,
<    TDA_SETUP_CMD,
<    TDA_GET_SETUP_CMD,
<    TDA_WAIT_EVENT_CMD,
<    TDA_ENABLE_EVENT_CMD,
<    TDA_DISABLE_EVENT_CMD,
<    TDA_GET_VIDEO_SPEC_CMD,
<    TDA_SET_INPUT_OUTPUT_CMD,
<    TDA_SET_AUDIO_INPUT_CMD,
<    TDA_SET_VIDEO_INFOFRAME_CMD,
<    TDA_SET_AUDIO_INFOFRAME_CMD,
<    TDA_SET_ACP_CMD,
<    TDA_SET_GCP_CMD,
<    TDA_SET_ISRC1_CMD,
<    TDA_SET_ISRC2_CMD,
<    TDA_SET_MPS_INFOFRAME_CMD,
<    TDA_SET_SPD_INFOFRAME_CMD,
<    TDA_SET_VS_INFOFRAME_CMD,
<    TDA_SET_AUDIO_MUTE_CMD,
<    TDA_RESET_AUDIO_CTS_CMD,
<    TDA_GET_EDID_STATUS_CMD,
<    TDA_GET_EDID_AUDIO_CAPS_CMD,
<    TDA_GET_EDID_VIDEO_CAPS_CMD,
<    TDA_GET_EDID_VIDEO_PREF_CMD,
<    TDA_GET_EDID_SINK_TYPE_CMD,
<    TDA_GET_EDID_SOURCE_ADDRESS_CMD,
<    TDA_SET_GAMMUT_CMD,
<    TDA_GET_EDID_DTD_CMD,
<    TDA_GET_EDID_MD_CMD,
<    TDA_GET_EDID_TV_ASPECT_RATIO_CMD,
<    TDA_GET_EDID_LATENCY_CMD,
<    TDA_SET_HDCP_CMD,
<    TDA_GET_HDCP_STATUS_CMD,
< };
< 
< 
< /* driver specific */
< #define TDA_IOCTL_VERBOSE_ON     _IO(TDA_IOCTL_BASE, TDA_VERBOSE_ON_CMD)
< #define TDA_IOCTL_VERBOSE_OFF     _IO(TDA_IOCTL_BASE, TDA_VERBOSE_OFF_CMD)
< #define TDA_IOCTL_BYEBYE     _IO(TDA_IOCTL_BASE, TDA_BYEBYE_CMD)
< /* HDMI Tx */
< #define TDA_IOCTL_GET_SW_VERSION     _IOWR(TDA_IOCTL_BASE, TDA_GET_SW_VERSION_CMD,tda_version)
< #define TDA_IOCTL_SET_POWER     _IOWR(TDA_IOCTL_BASE, TDA_SET_POWER_CMD,tda_power)
< #define TDA_IOCTL_GET_POWER     _IOWR(TDA_IOCTL_BASE, TDA_GET_POWER_CMD,tda_power)
< #define TDA_IOCTL_SETUP     _IOWR(TDA_IOCTL_BASE, TDA_SETUP_CMD,tda_setup_info)
< #define TDA_IOCTL_GET_SETUP     _IOWR(TDA_IOCTL_BASE, TDA_GET_SETUP_CMD,tda_setup_info)
< #define TDA_IOCTL_WAIT_EVENT     _IOWR(TDA_IOCTL_BASE, TDA_WAIT_EVENT_CMD,tda_event)
< #define TDA_IOCTL_ENABLE_EVENT     _IOWR(TDA_IOCTL_BASE, TDA_ENABLE_EVENT_CMD,tda_event)
< #define TDA_IOCTL_DISABLE_EVENT     _IOWR(TDA_IOCTL_BASE, TDA_DISABLE_EVENT_CMD,tda_event)
< #define TDA_IOCTL_GET_VIDEO_SPEC     _IOWR(TDA_IOCTL_BASE, TDA_GET_VIDEO_SPEC_CMD,tda_video_format)
< #define TDA_IOCTL_SET_INPUT_OUTPUT     _IOWR(TDA_IOCTL_BASE, TDA_SET_INPUT_OUTPUT_CMD,tda_set_in_out)
< #define TDA_IOCTL_SET_AUDIO_INPUT     _IOWR(TDA_IOCTL_BASE, TDA_SET_AUDIO_INPUT_CMD,tda_audio_in)
< #define TDA_IOCTL_SET_VIDEO_INFOFRAME     _IOWR(TDA_IOCTL_BASE, TDA_SET_VIDEO_INFOFRAME_CMD,tda_video_infoframe)
< #define TDA_IOCTL_SET_AUDIO_INFOFRAME     _IOWR(TDA_IOCTL_BASE, TDA_SET_AUDIO_INFOFRAME_CMD,tda_audio_infoframe)
< #define TDA_IOCTL_SET_ACP     _IOWR(TDA_IOCTL_BASE, TDA_SET_ACP_CMD,tda_acp)
< #define TDA_IOCTL_SET_GCP     _IOWR(TDA_IOCTL_BASE, TDA_SET_GCP_CMD,tda_gcp)
< #define TDA_IOCTL_SET_ISRC1     _IOWR(TDA_IOCTL_BASE, TDA_SET_ISRC1_CMD,tda_isrc1)
< #define TDA_IOCTL_SET_ISRC2     _IOWR(TDA_IOCTL_BASE, TDA_SET_ISRC2_CMD,tda_isrc2)
< #define TDA_IOCTL_SET_MPS_INFOFRAME     _IOWR(TDA_IOCTL_BASE, TDA_SET_MPS_INFOFRAME_CMD,tda_mps_infoframe)
< #define TDA_IOCTL_SET_SPD_INFOFRAME     _IOWR(TDA_IOCTL_BASE, TDA_SET_SPD_INFOFRAME_CMD,tda_spd_infoframe)
< #define TDA_IOCTL_SET_VS_INFOFRAME     _IOWR(TDA_IOCTL_BASE, TDA_SET_VS_INFOFRAME_CMD,tda_vs_infoframe)
< #define TDA_IOCTL_SET_AUDIO_MUTE     _IOWR(TDA_IOCTL_BASE, TDA_SET_AUDIO_MUTE_CMD,bool)
< #define TDA_IOCTL_RESET_AUDIO_CTS     _IO(TDA_IOCTL_BASE, TDA_RESET_AUDIO_CTS_CMD)
< #define TDA_IOCTL_GET_EDID_STATUS     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_STATUS_CMD,tda_edid)
< #define TDA_IOCTL_GET_EDID_AUDIO_CAPS     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_AUDIO_CAPS_CMD,tda_edid_audio_caps)
< #define TDA_IOCTL_GET_EDID_VIDEO_CAPS     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_VIDEO_CAPS_CMD,tda_edid_video_caps)
< #define TDA_IOCTL_GET_EDID_VIDEO_PREF     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_VIDEO_PREF_CMD,tda_edid_video_timings)
< #define TDA_IOCTL_GET_EDID_SINK_TYPE     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_SINK_TYPE_CMD,tda_sink)
< #define TDA_IOCTL_GET_EDID_SOURCE_ADDRESS     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_SOURCE_ADDRESS_CMD,unsigned short)
< #define TDA_IOCTL_SET_GAMMUT     _IOWR(TDA_IOCTL_BASE, TDA_SET_GAMMUT_CMD,tda_gammut)
< #define TDA_IOCTL_GET_EDID_DTD     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_DTD_CMD,tda_edid_dtd)
< #define TDA_IOCTL_GET_EDID_MD     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_MD_CMD,tda_edid_md)
< #define TDA_IOCTL_GET_EDID_TV_ASPECT_RATIO     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_TV_ASPECT_RATIO_CMD,tda_edid_tv_aspect_ratio)
< #ifdef TMFL_TDA19989
< #define TDA_IOCTL_GET_EDID_LATENCY     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_LATENCY_CMD,tda_edid_latency)
< #define TDA_IOCTL_SET_HDCP     _IOWR(TDA_IOCTL_BASE, TDA_SET_HDCP_CMD,bool)
< #define TDA_IOCTL_GET_HDCP_STATUS     _IOWR(TDA_IOCTL_BASE, TDA_GET_HDCP_STATUS_CMD,tda_hdcp_status)
< #endif
< 
< 
< /* --- Full list --- */
< 
< /* legend: */
< /* ------- */
< /* [ ] : not supported */
< /* [x] : IOCTL */
< /* [i] : open, init... */
< 
< /* [x] tmdlHdmiTxGetSWVersion */
< /* [ ] tmdlHdmiTxGetNumberOfUnits */
< /* [i] tmdlHdmiTxGetCapabilities */
< /* [ ] tmdlHdmiTxGetCapabilitiesM */
< /* [i] tmdlHdmiTxOpen */
< /* [ ] tmdlHdmiTxOpenM */
< /* [i] tmdlHdmiTxClose */
< /* [x] tmdlHdmiTxSetPowerState */
< /* [x] tmdlHdmiTxGetPowerState */
< /* [ ] tmdlHdmiTxInstanceConfig */
< /* [xi] tmdlHdmiTxInstanceSetup */
< /* [x] tmdlHdmiTxGetInstanceSetup */
< /* [x] tmdlHdmiTxHandleInterrupt see IOCTL_WAIT_EVENT */
< /* [i] tmdlHdmiTxRegisterCallbacks */
< /* [x] tmdlHdmiTxEnableEvent */
< /* [x] tmdlHdmiTxDisableEvent */
< /* [x] tmdlHdmiTxGetVideoFormatSpecs */
< /* [x] tmdlHdmiTxSetInputOutput */
< /* [x] tmdlHdmiTxSetAudioInput */
< /* [x] tmdlHdmiTxSetVideoInfoframe */
< /* [x] tmdlHdmiTxSetAudioInfoframe */
< /* [x] tmdlHdmiTxSetACPPacket */
< /* [x] tmdlHdmiTxSetGeneralControlPacket */
< /* [x] tmdlHdmiTxSetISRC1Packet */
< /* [x] tmdlHdmiTxSetISRC2Packet */
< /* [x] tmdlHdmiTxSetMPSInfoframe */
< /* [x] tmdlHdmiTxSetSpdInfoframe */
< /* [x] tmdlHdmiTxSetVsInfoframe */
< /* [ ] tmdlHdmiTxDebugSetNullPacket */
< /* [ ] tmdlHdmiTxDebugSetSingleNullPacket */
< /* [x] tmdlHdmiTxSetAudioMute */
< /* [x] tmdlHdmiTxResetAudioCts */
< /* [x] tmdlHdmiTxGetEdidStatus */
< /* [x] tmdlHdmiTxGetEdidAudioCaps */
< /* [x] tmdlHdmiTxGetEdidVideoCaps */
< /* [x] tmdlHdmiTxGetEdidVideoPreferred */
< /* [x] tmdlHdmiTxGetEdidSinkType */
< /* [x] tmdlHdmiTxGetEdidSourceAddress */
< /* [ ] tmdlHdmiTxGetKsvList */
< /* [ ] tmdlHdmiTxGetDepth */
< /* [ ] tmdlHdmiTxGeneSHA_1_IT */
< /* [ ] tmdlHdmiTxSetHdcp */
< /* [ ] tmdlHdmiTxGetHdcpState */
< /* [ ] tmdlHdmiTxHdcpCheck */
< /* [x] tmdlHdmiTxSetGamutPacket */
< /* [x] tmdlHdmiTxGetEdidDetailledTimingDescriptors */
< /* [x] tmdlHdmiTxGetEdidMonitorDescriptors */
< /* [x] tmdlHdmiTxGetEdidTVPictureRatio */
< /* [ ] tmdlHdmiTxSetHDCPRevocationList */
< /* [ ] tmdlHdmiTxGetHdcpFailStatus */
< /* [x] tmdlHdmiTxGetEdidLatencyInfo */
< /* [ ] tmdlHdmiTxSetBScreen */
< /* [ ] tmdlHdmiTxRemoveBScreen */
< 
< 
< #endif /* __tx_h__ */
< #endif /* __tx_ioctl__ */
< 
< #ifndef __cec_ioctl__
< #define __cec_ioctl__
< 
< #ifdef __cec_h__
< 
< typedef struct {
<    UInt8 DayOfMonth;
<    UInt8 MonthOfYear;
<    UInt16 StartTime;
<    tmdlHdmiCECDuration_t Duration;
<    UInt8 RecordingSequence;
<    tmdlHdmiCECAnalogueBroadcastType_t AnalogueBroadcastType;
<    UInt16 AnalogueFrequency;
<    tmdlHdmiCECBroadcastSystem_t BroadcastSystem;
< } cec_analogue_timer;
< 
< typedef struct {
<    UInt8 DayOfMonth;
<    UInt8 MonthOfYear;
<    UInt16 StartTime;
<    tmdlHdmiCECDuration_t Duration;
<    UInt8 RecordingSequence;
<    tmdlHdmiCECDigitalServiceIdentification_t ServiceIdentification;
< } cec_digital_timer;
< 
< typedef struct {
<    UInt8 DayOfMonth;
<    UInt8 MonthOfYear;
<    UInt16 StartTime;
<    tmdlHdmiCECDuration_t Duration;
<    UInt8 RecordingSequence;
<    tmdlHdmiCECExternalPlug_t ExternalPlug;
< } cec_ext_timer_with_ext_plug;
< 
< typedef struct {
<    UInt8 DayOfMonth;
<    UInt8 MonthOfYear;
<    UInt16 StartTime;
<    tmdlHdmiCECDuration_t Duration;
<    UInt8 RecordingSequence;
<    tmdlHdmiCECExternalPhysicalAddress_t ExternalPhysicalAddress;
< } cec_ext_timer_with_phy_addr;
< 
< typedef struct {
<    tmdlHdmiCECFeatureOpcode_t FeatureOpcode;
<    tmdlHdmiCECAbortReason_t AbortReason;
< } cec_feature_abort;
< 
< typedef struct {
<    tmdlHdmiCECAnalogueBroadcastType_t AnalogueBroadcastType;
<    UInt16 AnalogueFrequency;
<    tmdlHdmiCECBroadcastSystem_t BroadcastSystem;
< } cec_analogue_service;
< 
< typedef struct {
<    UInt16 OriginalAddress;
<    UInt16 NewAddress;
< } cec_routing_change;
< 
< typedef struct {
<    char data[15];
<    unsigned char length;
< } cec_string;
< 
< typedef struct {
<    tmdlHdmiCECDisplayControl_t DisplayControl;
<    char data[15];
<    unsigned char length;
< } cec_osd_string;
< 
< typedef struct {
<    tmdlHdmiCECRecordingFlag_t RecordingFlag;
<    tmdlHdmiCECTunerDisplayInfo_t TunerDisplayInfo;
<    tmdlHdmiCECAnalogueBroadcastType_t AnalogueBroadcastType;
<    UInt16 AnalogueFrequency;
<    tmdlHdmiCECBroadcastSystem_t BroadcastSystem;
< } cec_tuner_device_status_analogue;
< 
< typedef struct {
<    tmdlHdmiCECRecordingFlag_t RecordingFlag;
<    tmdlHdmiCECTunerDisplayInfo_t TunerDisplayInfo;
<    tmdlHdmiCECDigitalServiceIdentification_t ServiceIdentification;
< } cec_tuner_device_status_digital;
< 
< typedef struct {
<    unsigned long VendorID;
<    cec_string cmd;
< } cec_vendor_command_with_id;
< 
< /*
<   typedef struct {
<   UInt8 *pData;
<   UInt16 lenData;
<   } cec_send_msg;
< */
< 
< typedef struct
< {
<    unsigned char count;
<    unsigned char service;
<    unsigned char addr;
<    unsigned char data[15];
< } cec_frame;
< /* typedef tmdlHdmiCecFrameFormat_t cec_frame; */
< 
< typedef tmSWVersion_t cec_sw_version;
< typedef tmPowerState_t cec_power;
< typedef tmdlHdmiCecInstanceSetup_t cec_setup;
< typedef tmdlHdmiCecEvent_t cec_event;
< typedef tmdlHdmiCecClockSource_t cec_clock;
< typedef tmdlHdmiCECSystemAudioStatus_t cec_sys_audio_status;
< typedef tmdlHdmiCECAudioRate_t cec_audio_rate;
< typedef tmdlHdmiCECDigitalServiceIdentification_t cec_digital_service;
< typedef tmdlHdmiCECVersion_t cec_version;
< typedef tmdlHdmiCECDecControlMode_t cec_deck_ctrl;
< typedef tmdlHdmiCECDecInfo_t cec_deck_status;
< typedef tmdlHdmiCECStatusRequest_t cec_status_request;
< typedef tmdlHdmiCECMenuRequestType_t cec_menu_request;
< typedef tmdlHdmiCECMenuState_t cec_menu_status;
< typedef tmdlHdmiCECPlayMode_t cec_play;
< typedef tmdlHdmiCECExternalPlug_t cec_ext_plug;
< typedef tmdlHdmiCECRecordStatusInfo_t cec_rec_status;
< typedef tmdlHdmiCECAudioStatus_t cec_audio_status;
< typedef tmdlHdmiCECPowerStatus_t cec_power_status;
< typedef tmdlHdmiCECTimerClearedStatusData_t cec_timer_cleared_status;
< typedef tmdlHdmiCECTimerStatusData_t cec_timer_status;
< typedef tmdlHdmiCECUserRemoteControlCommand_t cec_user_ctrl;
< typedef tmdlHdmiCECChannelIdentifier_t cec_user_ctrl_tune;
< typedef tmdlHdmiCECDeviceType_t cec_device_type;
< 
< #define CEC_IOCTL_BASE 0x40
< 
< /* service */
< enum {
<    CEC_WAITING = 0x80,
<    CEC_RELEASE,
<    CEC_RX_DONE,
<    CEC_TX_DONE
< };
< 
< enum {
<    /* driver specific */
<    CEC_VERBOSE_ON_CMD = 0,
<    CEC_VERBOSE_OFF_CMD,
<    CEC_BYEBYE_CMD,
< 
<    /* CEC */
<    CEC_IOCTL_RX_ADDR_CMD, /* receiver logical address selector */
<    CEC_IOCTL_PHY_ADDR_CMD, /* physical address selector */
<    CEC_IOCTL_WAIT_FRAME_CMD,
<    CEC_IOCTL_ABORT_MSG_CMD,
<    CEC_IOCTL_ACTIVE_SRC_CMD,
<    CEC_IOCTL_VERSION_CMD,
<    CEC_IOCTL_CLEAR_ANALOGUE_TIMER_CMD,
<    CEC_IOCTL_CLEAR_DIGITAL_TIMER_CMD,
<    CEC_IOCTL_CLEAR_EXT_TIMER_WITH_EXT_PLUG_CMD,
<    CEC_IOCTL_CLEAR_EXT_TIMER_WITH_PHY_ADDR_CMD,
<    CEC_IOCTL_DECK_CTRL_CMD,
<    CEC_IOCTL_DECK_STATUS_CMD,
<    CEC_IOCTL_DEVICE_VENDOR_ID_CMD,
<    CEC_IOCTL_FEATURE_ABORT_CMD,
<    CEC_IOCTL_GET_CEC_VERSION_CMD,
<    CEC_IOCTL_GET_MENU_LANGUAGE_CMD,
<    CEC_IOCTL_GIVE_AUDIO_STATUS_CMD,
<    CEC_IOCTL_GIVE_DECK_STATUS_CMD,
<    CEC_IOCTL_GIVE_DEVICE_POWER_STATUS_CMD,
<    CEC_IOCTL_GIVE_DEVICE_VENDOR_ID_CMD,
<    CEC_IOCTL_GIVE_OSD_NAME_CMD,
<    CEC_IOCTL_GIVE_PHY_ADDR_CMD,
<    CEC_IOCTL_GIVE_SYS_AUDIO_MODE_STATUS_CMD,
<    CEC_IOCTL_GIVE_TUNER_DEVICE_STATUS_CMD,
<    CEC_IOCTL_IMAGE_VIEW_ON_CMD,
<    CEC_IOCTL_INACTIVE_SRC_CMD,
<    CEC_IOCTL_MENU_REQUEST_CMD,
<    CEC_IOCTL_MENU_STATUS_CMD,
<    CEC_IOCTL_PLAY_CMD,
<    CEC_IOCTL_POLLING_MSG_CMD,
<    CEC_IOCTL_REC_OFF_CMD,
<    CEC_IOCTL_REC_ON_ANALOGUE_SERVICE_CMD,
<    CEC_IOCTL_REC_ON_DIGITAL_SERVICE_CMD,
<    CEC_IOCTL_REC_ON_EXT_PHY_ADDR_CMD,
<    CEC_IOCTL_REC_ON_EXT_PLUG_CMD,
<    CEC_IOCTL_REC_ON_OWN_SRC_CMD,
<    CEC_IOCTL_REC_STATUS_CMD,
<    CEC_IOCTL_REC_TV_SCREEN_CMD,
<    CEC_IOCTL_REPORT_AUDIO_STATUS_CMD,
<    CEC_IOCTL_REPORT_PHY_ADDR_CMD,
<    CEC_IOCTL_REPORT_POWER_STATUS_CMD,
<    CEC_IOCTL_REQUEST_ACTIVE_SRC_CMD,
<    CEC_IOCTL_ROUTING_CHANGE_CMD,
<    CEC_IOCTL_ROUTING_INFORMATION_CMD,
<    CEC_IOCTL_SELECT_ANALOGUE_SERVICE_CMD,
<    CEC_IOCTL_SELECT_DIGITAL_SERVICE_CMD,
<    CEC_IOCTL_SET_ANALOGUE_TIMER_CMD,
<    CEC_IOCTL_SET_AUDIO_RATE_CMD,
<    CEC_IOCTL_SET_DIGITAL_TIMER_CMD,
<    CEC_IOCTL_SET_EXT_TIMER_WITH_EXT_PLUG_CMD,
<    CEC_IOCTL_SET_EXT_TIMER_WITH_PHY_ADDR_CMD,
<    CEC_IOCTL_SET_MENU_LANGUAGE_CMD,
<    CEC_IOCTL_SET_OSD_NAME_CMD,
<    CEC_IOCTL_SET_OSD_STRING_CMD,
<    CEC_IOCTL_SET_STREAM_PATH_CMD,
<    CEC_IOCTL_SET_SYS_AUDIO_MODE_CMD,
<    CEC_IOCTL_SET_TIMER_PROGRAM_TITLE_CMD,
<    CEC_IOCTL_STANDBY_CMD,
<    CEC_IOCTL_SYS_AUDIO_MODE_REQUEST_CMD,
<    CEC_IOCTL_SYS_AUDIO_MODE_STATUS_CMD,
<    CEC_IOCTL_TEXT_VIEW_ON_CMD,
<    CEC_IOCTL_TIMER_CLEARED_STATUS_CMD,
<    CEC_IOCTL_TIMER_STATUS_CMD,
<    CEC_IOCTL_TUNER_DEVICE_STATUS_ANALOGUE_CMD,
<    CEC_IOCTL_TUNER_DEVICE_STATUS_DIGITAL_CMD,
<    CEC_IOCTL_TUNER_STEP_DECREMENT_CMD,
<    CEC_IOCTL_TUNER_STEP_INCREMENT_CMD,
<    CEC_IOCTL_USER_CTRL_CMD,
<    CEC_IOCTL_USER_CTRL_PLAY_CMD,
<    CEC_IOCTL_USER_CTRL_SELECT_AUDIOINPUT_CMD,
<    CEC_IOCTL_USER_CTRL_SELECT_AVINPUT_CMD,
<    CEC_IOCTL_USER_CTRL_SELECT_MEDIA_CMD,
<    CEC_IOCTL_USER_CTRL_TUNE_CMD,
<    CEC_IOCTL_USER_CTRL_RELEASED_CMD,
<    CEC_IOCTL_VENDOR_COMMAND_CMD,
<    CEC_IOCTL_VENDOR_COMMAND_WITH_ID_CMD,
<    CEC_IOCTL_VENDOR_REMOTE_BUTTON_DOWN_CMD,
<    CEC_IOCTL_VENDOR_REMOTE_BUTTON_UP_CMD,
<    CEC_IOCTL_GET_SW_VERSION_CMD,
<    CEC_IOCTL_SET_POWER_STATE_CMD,
<    CEC_IOCTL_GET_POWER_STATE_CMD,
<    CEC_IOCTL_INSTANCE_CONFIG_CMD,
<    CEC_IOCTL_INSTANCE_SETUP_CMD,
<    CEC_IOCTL_GET_INSTANCE_SETUP_CMD,
<    CEC_IOCTL_ENABLE_EVENT_CMD,
<    CEC_IOCTL_DISABLE_EVENT_CMD,
<    CEC_IOCTL_ENABLE_CALIBRATION_CMD,
<    CEC_IOCTL_DISABLE_CALIBRATION_CMD,
<    CEC_IOCTL_SEND_MSG_CMD,
<    CEC_IOCTL_SET_REGISTER_CMD
< };
< 
< 
< /* driver specific */
< #define CEC_IOCTL_VERBOSE_ON       _IO(CEC_IOCTL_BASE, CEC_VERBOSE_ON_CMD)
< #define CEC_IOCTL_VERBOSE_OFF      _IO(CEC_IOCTL_BASE, CEC_VERBOSE_OFF_CMD)
< #define CEC_IOCTL_BYEBYE      _IO(CEC_IOCTL_BASE, CEC_BYEBYE_CMD)
< 
< /* CEC */
< #define CEC_IOCTL_RX_ADDR      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_RX_ADDR_CMD,unsigned char)
< #define CEC_IOCTL_PHY_ADDR      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_PHY_ADDR_CMD,unsigned short)
< #define CEC_IOCTL_WAIT_FRAME      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_WAIT_FRAME_CMD,cec_frame)
< #define CEC_IOCTL_ABORT_MSG      _IO(CEC_IOCTL_BASE,CEC_IOCTL_ABORT_MSG_CMD)
< #define CEC_IOCTL_ACTIVE_SRC      _IO(CEC_IOCTL_BASE,CEC_IOCTL_ACTIVE_SRC_CMD)
< #define CEC_IOCTL_VERSION      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_VERSION_CMD,cec_version)
< #define CEC_IOCTL_CLEAR_ANALOGUE_TIMER      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_CLEAR_ANALOGUE_TIMER_CMD,cec_analogue_timer)
< #define CEC_IOCTL_CLEAR_DIGITAL_TIMER      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_CLEAR_DIGITAL_TIMER_CMD,cec_digital_timer)
< #define CEC_IOCTL_CLEAR_EXT_TIMER_WITH_EXT_PLUG      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_CLEAR_EXT_TIMER_WITH_EXT_PLUG_CMD,cec_ext_timer_with_ext_plug)
< #define CEC_IOCTL_CLEAR_EXT_TIMER_WITH_PHY_ADDR      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_CLEAR_EXT_TIMER_WITH_PHY_ADDR_CMD,cec_ext_timer_with_phy_addr)
< #define CEC_IOCTL_DECK_CTRL      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_DECK_CTRL_CMD,cec_deck_ctrl)
< #define CEC_IOCTL_DECK_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_DECK_STATUS_CMD,cec_deck_status)
< #define CEC_IOCTL_DEVICE_VENDOR_ID      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_DEVICE_VENDOR_ID_CMD,unsigned long)
< #define CEC_IOCTL_FEATURE_ABORT      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_FEATURE_ABORT_CMD,cec_feature_abort)
< #define CEC_IOCTL_GET_CEC_VERSION      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_GET_CEC_VERSION_CMD,unsigned char)
< #define CEC_IOCTL_GET_MENU_LANGUAGE      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GET_MENU_LANGUAGE_CMD)
< #define CEC_IOCTL_GIVE_AUDIO_STATUS      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_AUDIO_STATUS_CMD)
< #define CEC_IOCTL_GIVE_DECK_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_DECK_STATUS_CMD,cec_status_request)
< #define CEC_IOCTL_GIVE_DEVICE_POWER_STATUS      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_DEVICE_POWER_STATUS_CMD)
< #define CEC_IOCTL_GIVE_DEVICE_VENDOR_ID      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_DEVICE_VENDOR_ID_CMD)
< #define CEC_IOCTL_GIVE_OSD_NAME      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_OSD_NAME_CMD)
< #define CEC_IOCTL_GIVE_PHY_ADDR      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_PHY_ADDR_CMD)
< #define CEC_IOCTL_GIVE_SYS_AUDIO_MODE_STATUS      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_SYS_AUDIO_MODE_STATUS_CMD)
< #define CEC_IOCTL_GIVE_TUNER_DEVICE_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_TUNER_DEVICE_STATUS_CMD,cec_status_request)
< #define CEC_IOCTL_IMAGE_VIEW_ON      _IO(CEC_IOCTL_BASE,CEC_IOCTL_IMAGE_VIEW_ON_CMD)
< #define CEC_IOCTL_INACTIVE_SRC      _IO(CEC_IOCTL_BASE,CEC_IOCTL_INACTIVE_SRC_CMD)
< #define CEC_IOCTL_MENU_REQUEST      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_MENU_REQUEST_CMD,cec_menu_request)
< #define CEC_IOCTL_MENU_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_MENU_STATUS_CMD,cec_menu_status)
< #define CEC_IOCTL_PLAY      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_PLAY_CMD,cec_play)
< #define CEC_IOCTL_POLLING_MSG      _IO(CEC_IOCTL_BASE,CEC_IOCTL_POLLING_MSG_CMD)
< #define CEC_IOCTL_REC_OFF      _IO(CEC_IOCTL_BASE,CEC_IOCTL_REC_OFF_CMD)
< #define CEC_IOCTL_REC_ON_ANALOGUE_SERVICE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REC_ON_ANALOGUE_SERVICE_CMD,cec_analogue_service)
< #define CEC_IOCTL_REC_ON_DIGITAL_SERVICE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REC_ON_DIGITAL_SERVICE_CMD,cec_digital_service)
< #define CEC_IOCTL_REC_ON_EXT_PHY_ADDR      _IO(CEC_IOCTL_BASE,CEC_IOCTL_REC_ON_EXT_PHY_ADDR_CMD)
< #define CEC_IOCTL_REC_ON_EXT_PLUG      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REC_ON_EXT_PLUG_CMD,cec_ext_plug)
< #define CEC_IOCTL_REC_ON_OWN_SRC      _IO(CEC_IOCTL_BASE,CEC_IOCTL_REC_ON_OWN_SRC_CMD)
< #define CEC_IOCTL_REC_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REC_STATUS_CMD,cec_rec_status)
< #define CEC_IOCTL_REC_TV_SCREEN      _IO(CEC_IOCTL_BASE,CEC_IOCTL_REC_TV_SCREEN_CMD)
< #define CEC_IOCTL_REPORT_AUDIO_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REPORT_AUDIO_STATUS_CMD,cec_audio_status)
< #define CEC_IOCTL_REPORT_PHY_ADDR      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REPORT_PHY_ADDR_CMD,cec_device_type)
< #define CEC_IOCTL_REPORT_POWER_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REPORT_POWER_STATUS_CMD,cec_power_status)
< #define CEC_IOCTL_REQUEST_ACTIVE_SRC      _IO(CEC_IOCTL_BASE,CEC_IOCTL_REQUEST_ACTIVE_SRC_CMD)
< #define CEC_IOCTL_ROUTING_CHANGE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_ROUTING_CHANGE_CMD,cec_routing_change)
< #define CEC_IOCTL_ROUTING_INFORMATION      _IO(CEC_IOCTL_BASE,CEC_IOCTL_ROUTING_INFORMATION_CMD)
< #define CEC_IOCTL_SELECT_ANALOGUE_SERVICE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SELECT_ANALOGUE_SERVICE_CMD,cec_analogue_service)
< #define CEC_IOCTL_SELECT_DIGITAL_SERVICE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SELECT_DIGITAL_SERVICE_CMD,cec_digital_service)
< #define CEC_IOCTL_SET_ANALOGUE_TIMER      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_ANALOGUE_TIMER_CMD,cec_analogue_timer)
< #define CEC_IOCTL_SET_AUDIO_RATE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_AUDIO_RATE_CMD,cec_audio_rate)
< #define CEC_IOCTL_SET_DIGITAL_TIMER      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_DIGITAL_TIMER_CMD,cec_digital_timer)
< #define CEC_IOCTL_SET_EXT_TIMER_WITH_EXT_PLUG      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_EXT_TIMER_WITH_EXT_PLUG_CMD,cec_ext_timer_with_ext_plug)
< #define CEC_IOCTL_SET_EXT_TIMER_WITH_PHY_ADDR      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_EXT_TIMER_WITH_PHY_ADDR_CMD,cec_ext_timer_with_phy_addr)
< #define CEC_IOCTL_SET_MENU_LANGUAGE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_MENU_LANGUAGE_CMD,cec_string)
< #define CEC_IOCTL_SET_OSD_NAME      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_OSD_NAME_CMD,cec_string)
< #define CEC_IOCTL_SET_OSD_STRING      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_OSD_STRING_CMD,cec_osd_string)
< #define CEC_IOCTL_SET_STREAM_PATH      _IO(CEC_IOCTL_BASE,CEC_IOCTL_SET_STREAM_PATH_CMD)
< #define CEC_IOCTL_SET_SYS_AUDIO_MODE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_SYS_AUDIO_MODE_CMD,cec_sys_audio_status)
< #define CEC_IOCTL_SET_TIMER_PROGRAM_TITLE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_TIMER_PROGRAM_TITLE_CMD,cec_string)
< #define CEC_IOCTL_STANDBY      _IO(CEC_IOCTL_BASE,CEC_IOCTL_STANDBY_CMD)
< #define CEC_IOCTL_SYS_AUDIO_MODE_REQUEST      _IO(CEC_IOCTL_BASE,CEC_IOCTL_SYS_AUDIO_MODE_REQUEST_CMD)
< #define CEC_IOCTL_SYS_AUDIO_MODE_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SYS_AUDIO_MODE_STATUS_CMD,cec_sys_audio_status)
< #define CEC_IOCTL_TEXT_VIEW_ON      _IO(CEC_IOCTL_BASE,CEC_IOCTL_TEXT_VIEW_ON_CMD)
< #define CEC_IOCTL_TIMER_CLEARED_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_TIMER_CLEARED_STATUS_CMD,cec_timer_cleared_status)
< #define CEC_IOCTL_TIMER_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_TIMER_STATUS_CMD,cec_timer_status)
< #define CEC_IOCTL_TUNER_DEVICE_STATUS_ANALOGUE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_TUNER_DEVICE_STATUS_ANALOGUE_CMD,cec_tuner_device_status_analogue)
< #define CEC_IOCTL_TUNER_DEVICE_STATUS_DIGITAL      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_TUNER_DEVICE_STATUS_DIGITAL_CMD,cec_tuner_device_status_digital)
< #define CEC_IOCTL_TUNER_STEP_DECREMENT      _IO(CEC_IOCTL_BASE,CEC_IOCTL_TUNER_STEP_DECREMENT_CMD)
< #define CEC_IOCTL_TUNER_STEP_INCREMENT      _IO(CEC_IOCTL_BASE,CEC_IOCTL_TUNER_STEP_INCREMENT_CMD)
< #define CEC_IOCTL_USER_CTRL_PRESSED      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_CMD,cec_user_ctrl)
< #define CEC_IOCTL_USER_CTRL_PLAY      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_PLAY_CMD,cec_play)
< #define CEC_IOCTL_USER_CTRL_SELECT_AUDIOINPUT      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_SELECT_AUDIOINPUT_CMD,unsigned char)
< #define CEC_IOCTL_USER_CTRL_SELECT_AVINPUT      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_SELECT_AVINPUT_CMD,unsigned char)
< #define CEC_IOCTL_USER_CTRL_SELECT_MEDIA      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_SELECT_MEDIA_CMD,unsigned char)
< #define CEC_IOCTL_USER_CTRL_TUNE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_TUNE_CMD,cec_user_ctrl_tune)
< #define CEC_IOCTL_USER_CTRL_RELEASED      _IO(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_RELEASED_CMD)
< #define CEC_IOCTL_VENDOR_COMMAND      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_VENDOR_COMMAND_CMD,cec_string)
< #define CEC_IOCTL_VENDOR_COMMAND_WITH_ID      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_VENDOR_COMMAND_WITH_ID_CMD,cec_vendor_command_with_id)
< #define CEC_IOCTL_VENDOR_REMOTE_BUTTON_DOWN      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_VENDOR_REMOTE_BUTTON_DOWN_CMD,cec_string)
< #define CEC_IOCTL_VENDOR_REMOTE_BUTTON_UP      _IO(CEC_IOCTL_BASE,CEC_IOCTL_VENDOR_REMOTE_BUTTON_UP_CMD)
< #define CEC_IOCTL_GET_SW_VERSION      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_GET_SW_VERSION_CMD,cec_sw_version)
< #define CEC_IOCTL_SET_POWER_STATE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_POWER_STATE_CMD,cec_power)
< #define CEC_IOCTL_GET_POWER_STATE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_GET_POWER_STATE_CMD,cec_power)
< #define CEC_IOCTL_INSTANCE_CONFIG      _IO(CEC_IOCTL_BASE,CEC_IOCTL_INSTANCE_CONFIG_CMD)
< #define CEC_IOCTL_INSTANCE_SETUP      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_INSTANCE_SETUP_CMD,cec_setup)
< #define CEC_IOCTL_GET_INSTANCE_SETUP      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_GET_INSTANCE_SETUP_CMD,cec_setup)
< #define CEC_IOCTL_ENABLE_EVENT      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_ENABLE_EVENT_CMD,cec_event)
< #define CEC_IOCTL_DISABLE_EVENT      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_DISABLE_EVENT_CMD,cec_event)
< #define CEC_IOCTL_ENABLE_CALIBRATION      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_ENABLE_CALIBRATION_CMD,cec_clock)
< #define CEC_IOCTL_DISABLE_CALIBRATION      _IO(CEC_IOCTL_BASE,CEC_IOCTL_DISABLE_CALIBRATION_CMD)
< //#define CEC_IOCTL_SEND_MSG      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SEND_MSG_CMD,cec_send_msg)
< 
< /* --- Full list --- */
< 
< /* legend: */
< /* ------- */
< /* [ ] : not supported */
< /* [x] : IOCTL */
< /* [i] : open, init... */
< 
< /* [ ] tmdlHdmiCecAbortMessage */
< /* [ ] tmdlHdmiCecActiveSource */
< /* [ ] tmdlHdmiCecVersion */
< /* [ ] tmdlHdmiCecClearAnalogueTimer */
< /* [ ] tmdlHdmiCecClearDigitalTimer */
< /* [ ] tmdlHdmiCecClearExternalTimerWithExternalPlug */
< /* [ ] tmdlHdmiCecClearExternalTimerWithPhysicalAddress */
< /* [ ] tmdlHdmiCecDeckControl */
< /* [ ] tmdlHdmiCecDeckStatus */
< /* [ ] tmdlHdmiCecDeviceVendorID */
< /* [ ] tmdlHdmiCecFeatureAbort */
< /* [ ] tmdlHdmiCecGetCecVersion */
< /* [ ] tmdlHdmiCecGetMenuLanguage */
< /* [ ] tmdlHdmiCecGiveAudioStatus */
< /* [ ] tmdlHdmiCecGiveDeckStatus */
< /* [ ] tmdlHdmiCecGiveDevicePowerStatus */
< /* [ ] tmdlHdmiCecGiveDeviceVendorID */
< /* [ ] tmdlHdmiCecGiveOsdName */
< /* [ ] tmdlHdmiCecGivePhysicalAddress */
< /* [ ] tmdlHdmiCecGiveSystemAudioModeStatus */
< /* [ ] tmdlHdmiCecGiveTunerDeviceStatus */
< /* [ ] tmdlHdmiCecImageViewOn */
< /* [ ] tmdlHdmiCecInactiveSource */
< /* [ ] tmdlHdmiCecMenuRequest */
< /* [ ] tmdlHdmiCecMenuStatus */
< /* [ ] tmdlHdmiCecPlay */
< /* [ ] tmdlHdmiCecPollingMessage */
< /* [ ] tmdlHdmiCecRecordOff */
< /* [ ] tmdlHdmiCecRecordOnAnalogueService */
< /* [ ] tmdlHdmiCecRecordOnDigitalService */
< /* [ ] tmdlHdmiCecRecordOnExternalPhysicalAddress */
< /* [ ] tmdlHdmiCecRecordOnExternalPlug */
< /* [ ] tmdlHdmiCecRecordOnOwnSource */
< /* [ ] tmdlHdmiCecRecordStatus */
< /* [ ] tmdlHdmiCecRecordTvScreen */
< /* [ ] tmdlHdmiCecReportAudioStatus */
< /* [ ] tmdlHdmiCecReportPhysicalAddress */
< /* [ ] tmdlHdmiCecReportPowerStatus */
< /* [ ] tmdlHdmiCecRequestActiveSource */
< /* [ ] tmdlHdmiCecRoutingChange */
< /* [ ] tmdlHdmiCecRoutingInformation */
< /* [ ] tmdlHdmiCecSelectAnalogueService */
< /* [ ] tmdlHdmiCecSelectDigitalService */
< /* [ ] tmdlHdmiCecSetAnalogueTimer */
< /* [ ] tmdlHdmiCecSetAudioRate */
< /* [ ] tmdlHdmiCecSetDigitalTimer */
< /* [ ] tmdlHdmiCecSetExternalTimerWithExternalPlug */
< /* [ ] tmdlHdmiCecSetExternalTimerWithPhysicalAddress */
< /* [ ] tmdlHdmiCecSetMenuLanguage */
< /* [ ] tmdlHdmiCecSetOsdName */
< /* [ ] tmdlHdmiCecSetOsdString */
< /* [ ] tmdlHdmiCecSetStreamPath */
< /* [ ] tmdlHdmiCecSetSystemAudioMode */
< /* [ ] tmdlHdmiCecSetTimerProgramTitle */
< /* [ ] tmdlHdmiCecStandby */
< /* [ ] tmdlHdmiCecSystemAudioModeRequest */
< /* [ ] tmdlHdmiCecSystemAudioModeStatus */
< /* [ ] tmdlHdmiCecTextViewOn */
< /* [ ] tmdlHdmiCecTimerClearedStatus */
< /* [ ] tmdlHdmiCecTimerStatus */
< /* [ ] tmdlHdmiCecTunerDeviceStatusAnalogue */
< /* [ ] tmdlHdmiCecTunerDeviceStatusDigital */
< /* [ ] tmdlHdmiCecTunerStepDecrement */
< /* [ ] tmdlHdmiCecTunerStepIncrement */
< /* [ ] tmdlHdmiCecUserControlPressed */
< /* [ ] tmdlHdmiCecUserControlPressedPlay */
< /* [ ] tmdlHdmiCecUserControlPressedSelectAudioInput */
< /* [ ] tmdlHdmiCecUserControlPressedSelectAVInput */
< /* [ ] tmdlHdmiCecUserControlPressedSelectMedia */
< /* [ ] tmdlHdmiCecUserControlPressedTune */
< /* [ ] tmdlHdmiCecUserControlReleased */
< /* [ ] tmdlHdmiCecVendorCommand */
< /* [ ] tmdlHdmiCecVendorCommandWithID */
< /* [ ] tmdlHdmiCecVendorRemoteButtonDown */
< /* [ ] tmdlHdmiCecVendorRemoteButtonUp */
< /* [ ] tmdlHdmiCecGetSWVersion */
< /* [ ] tmdlHdmiCecGetNumberOfUnits */
< /* [ ] tmdlHdmiCecGetCapabilities */
< /* [ ] tmdlHdmiCecGetCapabilitiesM */
< /* [ ] tmdlHdmiCecOpen */
< /* [ ] tmdlHdmiCecOpenM */
< /* [ ] tmdlHdmiCecClose */
< /* [ ] tmdlHdmiCecSetPowerState */
< /* [ ] tmdlHdmiCecGetPowerState */
< /* [ ] tmdlHdmiCecInstanceConfig */
< /* [ ] tmdlHdmiCecInstanceSetup */
< /* [ ] tmdlHdmiCecGetInstanceSetup */
< /* [ ] tmdlHdmiCecHandleInterrupt */
< /* [ ] tmdlHdmiCecRegisterCallbacks */
< /* [ ] tmdlHdmiCecSetAutoAnswer */
< /* [ ] tmdlHdmiCecSetLogicalAddress */
< /* [ ] tmdlHdmiCecEnableEvent */
< /* [ ] tmdlHdmiCecDisableEvent */
< /* [ ] tmdlHdmiCecEnableCalibration */
< /* [ ] tmdlHdmiCecDisableCalibration */
< /* [ ] tmdlHdmiCecSendMessage */
< /* [ ] tmdlHdmiCecSetRegister */
< 
< 
< #endif /* __cec_h__ */
< #endif /* __cec_ioctl__ */
---
> /**
>  * Copyright (C) 2006 NXP N.V., All Rights Reserved.
>  * This source code and any compilation or derivative thereof is the proprietary
>  * information of NXP N.V. and is confidential in nature. Under no circumstances
>  * is this software to be  exposed to or placed under an Open Source License of
>  * any type without the expressed written permission of NXP N.V.
>  *
>  * Version       Revision: 1.0
>  *
>  * Date          Date: 27/10/09
>  *
>  * Brief         API for the TDA1998x HDMI Transmitters
>  *
>  **/
> 
> #include <linux/types.h>
> 
> #ifndef __tx_ioctl__
> #define __tx_ioctl__
> 
> #ifdef __tx_h__
> 
> #define TRANS_TYPE 1
> 
> #if TRANS_TYPE
> 
> #define EXAMPLE_MAX_SVD 30
> 
> /*
>   trans-type
> */
> typedef tmSWVersion_t tda_version;
> typedef tmPowerState_t tda_power;
> typedef tmdlHdmiTxInstanceSetupInfo_t tda_setup;
> typedef tmdlHdmiTxCapabilities_t tda_capabilities;
> typedef tmdlHdmiTxVideoOutConfig_t tda_video_out;
> typedef tmdlHdmiTxVideoInConfig_t tda_video_in;
> typedef tmdlHdmiTxSinkType_t tda_sink;
> typedef tmdlHdmiTxAudioInConfig_t tda_audio_in;
> typedef tmdlHdmiTxEdidAudioDesc_t tda_edid_audio_desc;
> typedef tmdlHdmiTxShortVidDesc_t tda_edid_video_desc;
> typedef tmdlHdmiTxEvent_t tda_event;
> typedef tmdlHdmiTxInstanceSetupInfo_t tda_setup_info;
> typedef tmdlHdmiTxEdidVideoTimings_t tda_edid_video_timings;
> typedef tmdlHdmiTxPictAspectRatio_t tda_edid_tv_aspect_ratio;
> typedef tmdlHdmiTxHdcpCheck_t tda_hdcp_status;
> typedef tmdlHdmiTxHdcpStatus_t tda_hdcp_fail;
> #ifdef TMFL_TDA19989
> typedef tmdlHdmiTxEdidLatency_t tda_edid_latency;
> #endif
> 
> typedef struct {
>    Bool enable;
>    tmdlHdmiTxGamutData_t data;
> } tda_gammut;
> 
> typedef struct {
>    Bool enable;
>    tmdlHdmiTxVsPktData_t data;
> } tda_vs_infoframe;
> 
> typedef struct {
>    Bool enable;
>    tmdlHdmiTxSpdIfData_t data;
> } tda_spd_infoframe;
> 
> typedef struct {
>    Bool enable;
>    tmdlHdmiTxMpsIfData_t data;
> } tda_mps_infoframe;
> 
> typedef struct {
>    Bool enable;
>    tmdlHdmiTxIsrc1PktData_t data;
> } tda_isrc1;
> 
> typedef struct {
>    Bool enable;
>    tmdlHdmiTxIsrc2PktData_t data;
> } tda_isrc2;
> 
> typedef struct {
>    Bool enable;
>    tmdlHdmiTxAcpPktData_t data;
> } tda_acp;
> 
> typedef struct {
>    Bool enable;
>    tmdlHdmiTxGcpPktData_t data;
> } tda_gcp;
> 
> typedef struct {
>    Bool enable;
>    tmdlHdmiTxAviIfData_t data;
> } tda_video_infoframe;
> 
> typedef struct {
>    Bool enable;
>    tmdlHdmiTxAudIfData_t data;
> } tda_audio_infoframe;
> 
> typedef struct {
>    tmdlHdmiTxVidFmt_t id;
>    tmdlHdmiTxVidFmtSpecs_t spec;
> } tda_video_format;
> 
> typedef struct {
>    tda_video_in video_in;
>    tda_video_out video_out;
>    tda_audio_in audio_in; /* Mind tda_set_audio_in if you change this */
>    tda_sink sink; /* Mind tda_set_audio_in if you change this */
> } tda_set_in_out;
> 
> typedef struct {
>    tda_audio_in audio_in;
>    tda_sink sink;
> } tda_set_audio_in;
> 
> typedef struct {
>    tda_edid_audio_desc desc[EXAMPLE_MAX_SVD];
>    unsigned int max;
>    unsigned int written;
>    unsigned char flags;
> } tda_edid_audio_caps;
> 
> typedef struct {
>    tda_edid_video_desc desc[EXAMPLE_MAX_SVD];
>    unsigned int max;
>    unsigned int written;
>    unsigned char flags;
> } tda_edid_video_caps;
> 
> typedef struct {
>    tmdlHdmiTxEdidStatus_t status;
>    unsigned char block_count;
> } tda_edid;
> 
> typedef struct {
>    tmdlHdmiTxEdidVideoTimings_t desc[EXAMPLE_MAX_SVD];
>    unsigned char max;
>    unsigned char written;
> } tda_edid_dtd;
> 
> typedef struct {
>    tmdlHdmiTxEdidFirstMD_t desc1[EXAMPLE_MAX_SVD];
>    tmdlHdmiTxEdidSecondMD_t desc2[EXAMPLE_MAX_SVD];
>    tmdlHdmiTxEdidOtherMD_t other[EXAMPLE_MAX_SVD];
>    unsigned char max;
>    unsigned char written;
> } tda_edid_md;
> 
> #else 
> 
> #error do not compiled this !
> 
> typedef enum
> {
>     TDA_HDCP_ACTIVE         = 0,    /**< HDCP encryption status switched to active */
>     TDA_HDCP_INACTIVE       = 1,    /**< HDCP encryption status switched to inactive */
>     TDA_HPD_ACTIVE          = 2,    /**< Hotplug status switched to active */
>     TDA_HPD_INACTIVE        = 3,    /**< Hotplug status switched to inactive */
>     TDA_RX_KEYS_RECEIVED    = 4,    /**< Receiver(s) key(s) received */
>     TDA_RX_DEVICE_ACTIVE    = 5,    /**< Rx device is connected and active */
>     TDA_RX_DEVICE_INACTIVE  = 6,    /**< Rx device is connected but inactive (standby) */
>     TDA_EDID_RECEIVED       = 7,    /**< EDID has been received */
>     TDA_VS_RPT_RECEIVED     = 8,    /**< VS interrupt has been received */              
> #ifdef HDMI_TX_REPEATER_ISR_MODE
>     TDA_B_STATUS            = 9,    /**< TX received BStatus */
> #endif /* HDMI_TX_REPEATER_ISR_MODE */
>     TDA_DEBUG_EVENT_1       = 10     /**< This is a debug event */
> } tda_event;
> 
> typedef struct {
>     unsigned char format;         /* EIA/CEA861 mode */
>     unsigned char channels;       /* number of channels */
>     unsigned char supportedFreqs; /* bitmask of supported frequencies */
>     unsigned char supportedRes;   /* bitmask of supported resolutions (LPCM only) */
>     unsigned char maxBitrate;     /* Maximum bitrate divided by 8KHz (compressed formats only) */
> } tda_edid_audio_desc;
> 
> typedef enum {
>     TDA_EDID_READ                = 0,   /**< All blocks read OK */
>     TDA_EDID_READ_INCOMPLETE     = 1,   /**< All blocks read OK but buffer too small to return all of them */
>     TDA_EDID_ERROR_CHK_BLOCK_0   = 2,   /**< Block 0 checksum error */
>     TDA_EDID_ERROR_CHK           = 3,   /**< Block 0 OK, checksum error in one or more other blocks */
>     TDA_EDID_NOT_READ            = 4,   /**< EDID not read */
>     TDA_EDID_STATUS_INVALID      = 5    /**< Invalid   */
> } tda_edid_status;
> 
> typedef struct {
>    int HBR;              /**< High Bitrate Audio packet */
>    int DST;              /**< Direct Stream Transport audio packet */
>    int oneBitAudio;      /**< One Bit Audio sample packet */
> } tda_audio_packet;
> 
> typedef enum {
>     TDA_AFMT_SPDIF      = 0, /**< SPDIF */
>     TDA_AFMT_I2S        = 1, /**< I2S */
>     TDA_AFMT_OBA        = 2, /**< One bit audio / DSD */
>     TDA_AFMT_DST        = 3, /**< DST */
>     TDA_AFMT_HBR        = 4  /**< HBR */
> } tda_audio_format;
> 
> typedef enum {
>     TDA_AFS_32K           = 0, /**< 32kHz    */
>     TDA_AFS_44K           = 1, /**< 44.1kHz  */
>     TDA_AFS_48K           = 2, /**< 48kHz    */
>     TDA_AFS_88K           = 3, /**< 88.2kHz  */
>     TDA_AFS_96K           = 4, /**< 96kHz    */
>     TDA_AFS_176K          = 5, /**< 176.4kHz */
>     TDA_AFS_192K          = 6  /**< 192kHz   */
> } tda_audio_rate;
> 
> typedef enum {
>     TDA_I2SQ_16BITS       = 16, /**< 16 bits */
>     TDA_I2SQ_32BITS       = 32, /**< 32 bits */
>     TDA_I2SQ_OTHERS       = 0   /**< for SPDIF and DSD */
> } tda_audio_I2S_qualifier;
> 
> typedef enum {
>     TDA_I2SFOR_PHILIPS_L   = 0,	/**< Philips like format */
>     TDA_I2SFOR_OTH_L       = 2,	/**< Other non Philips left justified */
>     TDA_I2SFOR_OTH_R	   = 3,	/**< Other non Philips right justified */
>     TDA_I2SFOR_INVALID     = 4	/**< Invalid format */
> } tda_audio_I2S_format;
> 
> typedef enum {
>     TDA_DSTRATE_SINGLE  = 0,    /**< Single transfer rate */
>     TDA_DSTRATE_DOUBLE  = 1     /**< Double data rate */
> } tda_dst_rate;
> 
> typedef struct {
>     int    simplayHd;          /**< Enable simplayHD support */
>     int    repeaterEnable;     /**< Enable repeater mode */
>     unsigned char   *pEdidBuffer;       /**< Pointer to raw EDID data */
>     unsigned long  edidBufferSize;     /**< Size of buffer for raw EDID data */
> } tda_instance_setup_info;
> 
> typedef enum {
>     TDA_VFMT_NULL               = 0,    /**< Not a valid format...        */
>     TDA_VFMT_NO_CHANGE          = 0,    /**< ...or no change required     */
>     TDA_VFMT_MIN                = 1,    /**< Lowest valid format          */
>     TDA_VFMT_TV_MIN             = 1,    /**< Lowest valid TV format       */
>     TDA_VFMT_01_640x480p_60Hz   = 1,    /**< Format 01 640  x 480p  60Hz  */
>     TDA_VFMT_02_720x480p_60Hz   = 2,    /**< Format 02 720  x 480p  60Hz  */
>     TDA_VFMT_03_720x480p_60Hz   = 3,    /**< Format 03 720  x 480p  60Hz  */
>     TDA_VFMT_04_1280x720p_60Hz  = 4,    /**< Format 04 1280 x 720p  60Hz  */
>     TDA_VFMT_05_1920x1080i_60Hz = 5,    /**< Format 05 1920 x 1080i 60Hz  */
>     TDA_VFMT_06_720x480i_60Hz   = 6,    /**< Format 06 720  x 480i  60Hz  */
>     TDA_VFMT_07_720x480i_60Hz   = 7,    /**< Format 07 720  x 480i  60Hz  */
>     TDA_VFMT_08_720x240p_60Hz   = 8,    /**< Format 08 720  x 240p  60Hz  */
>     TDA_VFMT_09_720x240p_60Hz   = 9,    /**< Format 09 720  x 240p  60Hz  */
>     TDA_VFMT_10_720x480i_60Hz   = 10,   /**< Format 10 720  x 480i  60Hz  */
>     TDA_VFMT_11_720x480i_60Hz   = 11,   /**< Format 11 720  x 480i  60Hz  */
>     TDA_VFMT_12_720x240p_60Hz   = 12,   /**< Format 12 720  x 240p  60Hz  */
>     TDA_VFMT_13_720x240p_60Hz   = 13,   /**< Format 13 720  x 240p  60Hz  */
>     TDA_VFMT_14_1440x480p_60Hz  = 14,   /**< Format 14 1440 x 480p  60Hz  */
>     TDA_VFMT_15_1440x480p_60Hz  = 15,   /**< Format 15 1440 x 480p  60Hz  */
>     TDA_VFMT_16_1920x1080p_60Hz = 16,   /**< Format 16 1920 x 1080p 60Hz  */
>     TDA_VFMT_17_720x576p_50Hz   = 17,   /**< Format 17 720  x 576p  50Hz  */
>     TDA_VFMT_18_720x576p_50Hz   = 18,   /**< Format 18 720  x 576p  50Hz  */
>     TDA_VFMT_19_1280x720p_50Hz  = 19,   /**< Format 19 1280 x 720p  50Hz  */
>     TDA_VFMT_20_1920x1080i_50Hz = 20,   /**< Format 20 1920 x 1080i 50Hz  */
>     TDA_VFMT_21_720x576i_50Hz   = 21,   /**< Format 21 720  x 576i  50Hz  */
>     TDA_VFMT_22_720x576i_50Hz   = 22,   /**< Format 22 720  x 576i  50Hz  */
>     TDA_VFMT_23_720x288p_50Hz   = 23,   /**< Format 23 720  x 288p  50Hz  */
>     TDA_VFMT_24_720x288p_50Hz   = 24,   /**< Format 24 720  x 288p  50Hz  */
>     TDA_VFMT_25_720x576i_50Hz   = 25,   /**< Format 25 720  x 576i  50Hz  */
>     TDA_VFMT_26_720x576i_50Hz   = 26,   /**< Format 26 720  x 576i  50Hz  */
>     TDA_VFMT_27_720x288p_50Hz   = 27,   /**< Format 27 720  x 288p  50Hz  */
>     TDA_VFMT_28_720x288p_50Hz   = 28,   /**< Format 28 720  x 288p  50Hz  */
>     TDA_VFMT_29_1440x576p_50Hz  = 29,   /**< Format 29 1440 x 576p  50Hz  */
>     TDA_VFMT_30_1440x576p_50Hz  = 30,   /**< Format 30 1440 x 576p  50Hz  */
>     TDA_VFMT_31_1920x1080p_50Hz = 31,   /**< Format 31 1920 x 1080p 50Hz  */
>     TDA_VFMT_32_1920x1080p_24Hz = 32,   /**< Format 32 1920 x 1080p 24Hz  */
>     TDA_VFMT_33_1920x1080p_25Hz = 33,   /**< Format 33 1920 x 1080p 25Hz  */
>     TDA_VFMT_34_1920x1080p_30Hz = 34,   /**< Format 34 1920 x 1080p 30Hz  */
>     TDA_VFMT_TV_MAX             = 34,   /**< Highest valid TV format      */
>     TDA_VFMT_TV_NO_REG_MIN      = 32,   /**< Lowest TV format without prefetched table */
>     TDA_VFMT_TV_NUM             = 35,   /**< Number of TV formats & null  */
>     TDA_VFMT_PC_MIN             = 128,  /**< Lowest valid PC format       */
>     TDA_VFMT_PC_640x480p_60Hz   = 128,  /**< PC format 128                */
>     TDA_VFMT_PC_800x600p_60Hz   = 129,  /**< PC format 129                */
>     TDA_VFMT_PC_1152x960p_60Hz  = 130,  /**< PC format 130                */
>     TDA_VFMT_PC_1024x768p_60Hz  = 131,  /**< PC format 131                */
>     TDA_VFMT_PC_1280x768p_60Hz  = 132,  /**< PC format 132                */
>     TDA_VFMT_PC_1280x1024p_60Hz = 133,  /**< PC format 133                */
>     TDA_VFMT_PC_1360x768p_60Hz  = 134,  /**< PC format 134                */
>     TDA_VFMT_PC_1400x1050p_60Hz = 135,  /**< PC format 135                */
>     TDA_VFMT_PC_1600x1200p_60Hz = 136,  /**< PC format 136                */
>     TDA_VFMT_PC_1024x768p_70Hz  = 137,  /**< PC format 137                */
>     TDA_VFMT_PC_640x480p_72Hz   = 138,  /**< PC format 138                */
>     TDA_VFMT_PC_800x600p_72Hz   = 139,  /**< PC format 139                */
>     TDA_VFMT_PC_640x480p_75Hz   = 140,  /**< PC format 140                */
>     TDA_VFMT_PC_1024x768p_75Hz  = 141,  /**< PC format 141                */
>     TDA_VFMT_PC_800x600p_75Hz   = 142,  /**< PC format 142                */
>     TDA_VFMT_PC_1024x864p_75Hz  = 143,  /**< PC format 143                */
>     TDA_VFMT_PC_1280x1024p_75Hz = 144,  /**< PC format 144                */
>     TDA_VFMT_PC_640x350p_85Hz   = 145,  /**< PC format 145                */
>     TDA_VFMT_PC_640x400p_85Hz   = 146,  /**< PC format 146                */
>     TDA_VFMT_PC_720x400p_85Hz   = 147,  /**< PC format 147                */
>     TDA_VFMT_PC_640x480p_85Hz   = 148,  /**< PC format 148                */
>     TDA_VFMT_PC_800x600p_85Hz   = 149,  /**< PC format 149                */
>     TDA_VFMT_PC_1024x768p_85Hz  = 150,  /**< PC format 150                */
>     TDA_VFMT_PC_1152x864p_85Hz  = 151,  /**< PC format 151                */
>     TDA_VFMT_PC_1280x960p_85Hz  = 152,  /**< PC format 152                */
>     TDA_VFMT_PC_1280x1024p_85Hz = 153,  /**< PC format 153                */
>     TDA_VFMT_PC_1024x768i_87Hz  = 154,  /**< PC format 154                */
>     TDA_VFMT_PC_MAX             = 154,  /**< Highest valid PC format      */
>     TDA_VFMT_PC_NUM             = (1+154-128)   /**< Number of PC formats         */
> } tda_video_fmt_id;
> 
> typedef struct {
>     tda_video_fmt_id videoFormat;            /**< Video format as defined by EIA/CEA 861-D */
>     int              nativeVideoFormat;   /**< True if format is the preferred video format */
> } tda_edid_video_desc;
> 
> typedef struct {
>     tda_video_fmt_id videoFormat;            /**< Video format as defined by EIA/CEA 861-D */
>     int              nativeVideoFormat;   /**< True if format is the preferred video format */
> } tda_short_video_desc;
> 
> typedef enum {
>     TDA_P_ASPECT_RATIO_UNDEFINED    = 0,    /**< Undefined picture aspect ratio */
>     TDA_P_ASPECT_RATIO_6_5          = 1,    /**< 6:5 picture aspect ratio (PAR) */
>     TDA_P_ASPECT_RATIO_5_4          = 2,    /**< 5:4 PAR */
>     TDA_P_ASPECT_RATIO_4_3          = 3,    /**< 4:3 PAR */
>     TDA_P_ASPECT_RATIO_16_10        = 4,    /**< 16:10 PAR */
>     TDA_P_ASPECT_RATIO_5_3          = 5,    /**< 5:3 PAR */
>     TDA_P_ASPECT_RATIO_16_9         = 6,    /**< 16:9 PAR */
>     TDA_P_ASPECT_RATIO_9_5          = 7     /**< 9:5 PAR */
> } tda_pict_aspect_ratio;
> 
> typedef enum {
>     TDA_VFREQ_24Hz      = 0,    /**< 24Hz          */
>     TDA_VFREQ_25Hz      = 1,    /**< 25Hz          */
>     TDA_VFREQ_30Hz      = 2,    /**< 30Hz          */
>     TDA_VFREQ_50Hz      = 3,    /**< 50Hz          */
>     TDA_VFREQ_59Hz      = 4,    /**< 59.94Hz       */
>     TDA_VFREQ_60Hz      = 5,    /**< 60Hz          */
>     TDA_VFREQ_70Hz      = 6,    /**< 70Hz          */
>     TDA_VFREQ_72Hz      = 7,    /**< 72Hz          */
>     TDA_VFREQ_75Hz      = 8,    /**< 75Hz          */
>     TDA_VFREQ_85Hz      = 9,    /**< 85Hz          */
>     TDA_VFREQ_87Hz      = 10,   /**< 87Hz          */
>     TDA_VFREQ_INVALID   = 11,   /**< Invalid       */
>     TDA_VFREQ_NUM       = 11    /**< No. of values */
> } tda_vfreq;
> 
> typedef struct {
>     unsigned short                      width;         /**< Width of the frame in pixels */
>     unsigned short                      height;        /**< Height of the frame in pixels */
>     int                        interlaced;    /**< Interlaced mode (True/False) */
>     tda_vfreq           vfrequency;    /**< Vertical frequency in Hz */
>     tda_pict_aspect_ratio aspectRatio;   /**< Picture aspect ratio (H:V) */
> } tda_video_fmt_specs;
> 
> typedef enum {
>     TDA_VINMODE_CCIR656     = 0,    /**< CCIR656 */
>     TDA_VINMODE_RGB444      = 1,    /**< RGB444  */
>     TDA_VINMODE_YUV444      = 2,    /**< YUV444  */
>     TDA_VINMODE_YUV422      = 3,    /**< YUV422  */
>     TDA_VINMODE_NO_CHANGE   = 4,    /**< No change */
>     TDA_VINMODE_INVALID     = 5     /**< Invalid */
> } tda_vinmode;
> 
> typedef enum {
>     TDA_SYNCSRC_EMBEDDED = 0, /**< Embedded sync */
>     TDA_SYNCSRC_EXT_VREF = 1, /**< External sync Vref, Href, Fref */
>     TDA_SYNCSRC_EXT_VS   = 2  /**< External sync Vs, Hs */
> } tda_sync_source;
> 
> typedef enum {
>     TDA_PIXRATE_DOUBLE          = 0,        /**< Double pixel rate */
>     TDA_PIXRATE_SINGLE          = 1,        /**< Single pixel rate */
>     TDA_PIXRATE_SINGLE_REPEATED = 2         /**< Single pixel repeated */
> } tda_pix_rate;
> 
> typedef struct {
>    tda_video_fmt_id       format;     /**< Video format as defined by EIA/CEA 861-D */
>    tda_vinmode      mode;       /**< Video mode (CCIR, RGB, YUV, etc.) */
>    tda_sync_source   syncSource; /**< Sync source type */
>    tda_pix_rate      pixelRate;  /**< Pixel rate */
> } tda_video_in;
> 
> typedef enum {
>     TDA_VOUTMODE_RGB444     = 0,    /**< RGB444    */
>     TDA_VOUTMODE_YUV422     = 1,    /**< YUV422    */
>     TDA_VOUTMODE_YUV444     = 2     /**< YUV444    */
> } tda_vout_mode;
> 
> typedef enum {
>     TDA_VQR_DEFAULT = 0, /* Follow HDMI spec. */
>     TDA_RGB_FULL    = 1, /* Force RGB FULL , DVI only */
>     TDA_RGB_LIMITED = 2  /* Force RGB LIMITED , DVI only */
> } tda_vqr;
> 
> typedef enum {
>     TDA_COLORDEPTH_24   = 0,    /**< 8 bits per color */
>     TDA_COLORDEPTH_30   = 1,    /**< 10 bits per color */
>     TDA_COLORDEPTH_36   = 2,    /**< 12 bits per color */
>     TDA_COLORDEPTH_48   = 3     /**< 16 bits per color */
> } tda_color_depth;
> 
> typedef struct {
>    tda_video_fmt_id       format;     /**< Video format as defined by EIA/CEA 861-D */
>    tda_vout_mode     mode;       /**< Video mode (CCIR, RGB, YUV, etc.) */
>    tda_color_depth  colorDepth; /**< Color depth */
>    tda_vqr          dviVqr;     /**< VQR applied in DVI mode */ 
> } tda_video_out;
> 
> typedef struct {
>    tda_audio_format          format;             /**< Audio format (I2S, SPDIF, etc.) */
>    tda_audio_rate            rate;               /**< Audio sampling rate */
>    tda_audio_I2S_format       i2sFormat;          /**< I2S format of the audio input */
>    tda_audio_I2S_qualifier    i2sQualifier;       /**< I2S qualifier of the audio input (8,16,32 bits) */
>    tda_dst_rate              dstRate;            /**< DST data transfer rate */
>    unsigned char                            channelAllocation;  /**< Ref to CEA-861D p85 */
> } tda_audio_in;
> 
> typedef enum {
>     TDA_SINK_DVI  = 0, /**< DVI  */
>     TDA_SINK_HDMI = 1, /**< HDMI */
>     TDA_SINK_EDID = 2  /**< As currently defined in EDID */
> } tda_sink;
> 
>  typedef enum {
>      TDA_DEVICE_UNKNOWN,   /**< HW device is unknown */
>      TDA_DEVICE_TDA9984,   /**< HW device is IC TDA9984 */
>      TDA_DEVICE_TDA9989,   /**< HW device is IC TDA9989 */
>      TDA_DEVICE_TDA9981,   /**< HW device is IC TDA9981 */
>      TDA_DEVICE_TDA9983,   /**< HW device is IC TDA9983 */
>      TDA_DEVICE_TDA19989   /**< HW device is IC TDA19989 */
>  } tda_device_version;
> 
> typedef enum {
>    TDA_HDMI_VERSION_UNKNOWN, /**< Unknown   */
>    TDA_HDMI_VERSION_1_1,     /**< HDMI 1.1  */
>    TDA_HDMI_VERSION_1_2a,    /**< HDMI 1.2a */
>    TDA_HDMI_VERSION_1_3a     /**< HDMI 1.3  */
> } tda_hdmi_version;
>  
> typedef struct {
>    int HBR;              /**< High Bitrate Audio packet */
>    int DST;              /**< Direct Stream Transport audio packet */
>    int oneBitAudio;      /**< One Bit Audio sample packet */
> } tda_audio_packet;
> 
> typedef enum {
>     TDA_COLORDEPTH_24   = 0,    /**< 8 bits per color */
>     TDA_COLORDEPTH_30   = 1,    /**< 10 bits per color */
>     TDA_COLORDEPTH_36   = 2,    /**< 12 bits per color */
>     TDA_COLORDEPTH_48   = 3     /**< 16 bits per color */
> } tda_color_depth;
> 
> typedef struct {
>     tda_device_version deviceVersion;  /**< HW device version */
>     tda_hdmi_version hdmiVersion;    /**< Supported HDMI standard version  */
>     tda_audio_packet audioPacket;    /**< Supported audio packets */
>     tda_color_depth colorDepth;     /**< Supported color depth */
>     int hdcp;           /**< Supported Hdcp encryption (True/False) */
>    int scaler;         /**< Supported scaler (True/False) */
> } tda_capabilities;
> 
> typedef struct {
>     unsigned long compatibilityNr;        // Interface compatibility number
>     unsigned long majorVersionNr;         // Interface major version number
>     unsigned long minorVersionNr;         // Interface minor version number
> } tda_version;
> 
> typedef enum
> {
>     PowerOn,                          // Device powered on      (D0 state)
>     PowerStandby,                     // Device power standby   (D1 state)
>     PowerSuspend,                     // Device power suspended (D2 state)
>     PowerOff                          // Device powered off     (D3 state)
> } tda_powerXXX;
> 
> typedef struct {
>     unsigned int simplayHd;          /**< Enable simplayHD support */
>     unsigned int repeaterEnable;     /**< Enable repeater mode */
>     unsigned char *pEdidBuffer;       /**< Pointer to raw EDID data */
>     unsigned long edidBufferSize;     /**< Size of buffer for raw EDID data */
> } tda_setup;
> 
> typedef struct {
>    tda_video_fmt_id id;
>    tda_video_fmt_specs spec;
> } tda_video_format;
> 
> typedef struct {
>    tda_video_in video_in;
>    tda_video_out video_out;
>    tda_audio_in audio_in;
> } tda_set_in_out;
> 
> typedef struct {
>    tda_edid_audio_desc desc;
>    unsigned int max;
>    unsigned int written;
>    unsigned char flags;
> } tda_edid_audio_caps;
> 
> typedef struct {
>    tda_edid_video_desc desc;
>    unsigned int max;
>    unsigned int written;
>    unsigned char flags;
> } tda_edid_video_caps;
> 
> typedef struct {
>    tda_edid_status status;
>    unsigned char block_count;
> } tda_edid;
> 
> #endif
> 
> #define TDA_IOCTL_BASE 0x40
> #define RELEASE 0xFF
> 
> enum {
>    /* driver specific */
>    TDA_VERBOSE_ON_CMD = 0,
>    TDA_VERBOSE_OFF_CMD,
>    TDA_BYEBYE_CMD,
>    /* HDMI Tx */
>    TDA_GET_SW_VERSION_CMD,
>    TDA_SET_POWER_CMD,
>    TDA_GET_POWER_CMD,
>    TDA_SETUP_CMD,
>    TDA_GET_SETUP_CMD,
>    TDA_WAIT_EVENT_CMD,
>    TDA_ENABLE_EVENT_CMD,
>    TDA_DISABLE_EVENT_CMD,
>    TDA_GET_VIDEO_SPEC_CMD,
>    TDA_SET_INPUT_OUTPUT_CMD,
>    TDA_SET_AUDIO_INPUT_CMD,
>    TDA_SET_VIDEO_INFOFRAME_CMD,
>    TDA_SET_AUDIO_INFOFRAME_CMD,
>    TDA_SET_ACP_CMD,
>    TDA_SET_GCP_CMD,
>    TDA_SET_ISRC1_CMD,
>    TDA_SET_ISRC2_CMD,
>    TDA_SET_MPS_INFOFRAME_CMD,
>    TDA_SET_SPD_INFOFRAME_CMD,
>    TDA_SET_VS_INFOFRAME_CMD,
>    TDA_SET_AUDIO_MUTE_CMD,
>    TDA_RESET_AUDIO_CTS_CMD,
>    TDA_GET_EDID_STATUS_CMD,
>    TDA_GET_EDID_AUDIO_CAPS_CMD,
>    TDA_GET_EDID_VIDEO_CAPS_CMD,
>    TDA_GET_EDID_VIDEO_PREF_CMD,
>    TDA_GET_EDID_SINK_TYPE_CMD,
>    TDA_GET_EDID_SOURCE_ADDRESS_CMD,
>    TDA_SET_GAMMUT_CMD,
>    TDA_GET_EDID_DTD_CMD,
>    TDA_GET_EDID_MD_CMD,
>    TDA_GET_EDID_TV_ASPECT_RATIO_CMD,
>    TDA_GET_EDID_LATENCY_CMD,
>    TDA_SET_HDCP_CMD,
>    TDA_GET_HDCP_STATUS_CMD,
> };
> 
> 
> /* driver specific */
> #define TDA_IOCTL_VERBOSE_ON     _IO(TDA_IOCTL_BASE, TDA_VERBOSE_ON_CMD)
> #define TDA_IOCTL_VERBOSE_OFF     _IO(TDA_IOCTL_BASE, TDA_VERBOSE_OFF_CMD)
> #define TDA_IOCTL_BYEBYE     _IO(TDA_IOCTL_BASE, TDA_BYEBYE_CMD)
> /* HDMI Tx */
> #define TDA_IOCTL_GET_SW_VERSION     _IOWR(TDA_IOCTL_BASE, TDA_GET_SW_VERSION_CMD,tda_version)
> #define TDA_IOCTL_SET_POWER     _IOWR(TDA_IOCTL_BASE, TDA_SET_POWER_CMD,tda_power)
> #define TDA_IOCTL_GET_POWER     _IOWR(TDA_IOCTL_BASE, TDA_GET_POWER_CMD,tda_power)
> #define TDA_IOCTL_SETUP     _IOWR(TDA_IOCTL_BASE, TDA_SETUP_CMD,tda_setup_info)
> #define TDA_IOCTL_GET_SETUP     _IOWR(TDA_IOCTL_BASE, TDA_GET_SETUP_CMD,tda_setup_info)
> #define TDA_IOCTL_WAIT_EVENT     _IOWR(TDA_IOCTL_BASE, TDA_WAIT_EVENT_CMD,tda_event)
> #define TDA_IOCTL_ENABLE_EVENT     _IOWR(TDA_IOCTL_BASE, TDA_ENABLE_EVENT_CMD,tda_event)
> #define TDA_IOCTL_DISABLE_EVENT     _IOWR(TDA_IOCTL_BASE, TDA_DISABLE_EVENT_CMD,tda_event)
> #define TDA_IOCTL_GET_VIDEO_SPEC     _IOWR(TDA_IOCTL_BASE, TDA_GET_VIDEO_SPEC_CMD,tda_video_format)
> #define TDA_IOCTL_SET_INPUT_OUTPUT     _IOWR(TDA_IOCTL_BASE, TDA_SET_INPUT_OUTPUT_CMD,tda_set_in_out)
> #define TDA_IOCTL_SET_AUDIO_INPUT     _IOWR(TDA_IOCTL_BASE, TDA_SET_AUDIO_INPUT_CMD,tda_audio_in)
> #define TDA_IOCTL_SET_VIDEO_INFOFRAME     _IOWR(TDA_IOCTL_BASE, TDA_SET_VIDEO_INFOFRAME_CMD,tda_video_infoframe)
> #define TDA_IOCTL_SET_AUDIO_INFOFRAME     _IOWR(TDA_IOCTL_BASE, TDA_SET_AUDIO_INFOFRAME_CMD,tda_audio_infoframe)
> #define TDA_IOCTL_SET_ACP     _IOWR(TDA_IOCTL_BASE, TDA_SET_ACP_CMD,tda_acp)
> #define TDA_IOCTL_SET_GCP     _IOWR(TDA_IOCTL_BASE, TDA_SET_GCP_CMD,tda_gcp)
> #define TDA_IOCTL_SET_ISRC1     _IOWR(TDA_IOCTL_BASE, TDA_SET_ISRC1_CMD,tda_isrc1)
> #define TDA_IOCTL_SET_ISRC2     _IOWR(TDA_IOCTL_BASE, TDA_SET_ISRC2_CMD,tda_isrc2)
> #define TDA_IOCTL_SET_MPS_INFOFRAME     _IOWR(TDA_IOCTL_BASE, TDA_SET_MPS_INFOFRAME_CMD,tda_mps_infoframe)
> #define TDA_IOCTL_SET_SPD_INFOFRAME     _IOWR(TDA_IOCTL_BASE, TDA_SET_SPD_INFOFRAME_CMD,tda_spd_infoframe)
> #define TDA_IOCTL_SET_VS_INFOFRAME     _IOWR(TDA_IOCTL_BASE, TDA_SET_VS_INFOFRAME_CMD,tda_vs_infoframe)
> #define TDA_IOCTL_SET_AUDIO_MUTE     _IOWR(TDA_IOCTL_BASE, TDA_SET_AUDIO_MUTE_CMD,bool)
> #define TDA_IOCTL_RESET_AUDIO_CTS     _IO(TDA_IOCTL_BASE, TDA_RESET_AUDIO_CTS_CMD)
> #define TDA_IOCTL_GET_EDID_STATUS     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_STATUS_CMD,tda_edid)
> #define TDA_IOCTL_GET_EDID_AUDIO_CAPS     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_AUDIO_CAPS_CMD,tda_edid_audio_caps)
> #define TDA_IOCTL_GET_EDID_VIDEO_CAPS     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_VIDEO_CAPS_CMD,tda_edid_video_caps)
> #define TDA_IOCTL_GET_EDID_VIDEO_PREF     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_VIDEO_PREF_CMD,tda_edid_video_timings)
> #define TDA_IOCTL_GET_EDID_SINK_TYPE     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_SINK_TYPE_CMD,tda_sink)
> #define TDA_IOCTL_GET_EDID_SOURCE_ADDRESS     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_SOURCE_ADDRESS_CMD,unsigned short)
> #define TDA_IOCTL_SET_GAMMUT     _IOWR(TDA_IOCTL_BASE, TDA_SET_GAMMUT_CMD,tda_gammut)
> #define TDA_IOCTL_GET_EDID_DTD     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_DTD_CMD,tda_edid_dtd)
> #define TDA_IOCTL_GET_EDID_MD     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_MD_CMD,tda_edid_md)
> #define TDA_IOCTL_GET_EDID_TV_ASPECT_RATIO     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_TV_ASPECT_RATIO_CMD,tda_edid_tv_aspect_ratio)
> #ifdef TMFL_TDA19989
> #define TDA_IOCTL_GET_EDID_LATENCY     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_LATENCY_CMD,tda_edid_latency)
> #define TDA_IOCTL_SET_HDCP     _IOWR(TDA_IOCTL_BASE, TDA_SET_HDCP_CMD,bool)
> #define TDA_IOCTL_GET_HDCP_STATUS     _IOWR(TDA_IOCTL_BASE, TDA_GET_HDCP_STATUS_CMD,tda_hdcp_status)
> #endif
> 
> 
> /* --- Full list --- */
> 
> /* legend: */
> /* ------- */
> /* [ ] : not supported */
> /* [x] : IOCTL */
> /* [i] : open, init... */
> 
> /* [x] tmdlHdmiTxGetSWVersion */
> /* [ ] tmdlHdmiTxGetNumberOfUnits */
> /* [i] tmdlHdmiTxGetCapabilities */
> /* [ ] tmdlHdmiTxGetCapabilitiesM */
> /* [i] tmdlHdmiTxOpen */
> /* [ ] tmdlHdmiTxOpenM */
> /* [i] tmdlHdmiTxClose */
> /* [x] tmdlHdmiTxSetPowerState */
> /* [x] tmdlHdmiTxGetPowerState */
> /* [ ] tmdlHdmiTxInstanceConfig */
> /* [xi] tmdlHdmiTxInstanceSetup */
> /* [x] tmdlHdmiTxGetInstanceSetup */
> /* [x] tmdlHdmiTxHandleInterrupt see IOCTL_WAIT_EVENT */
> /* [i] tmdlHdmiTxRegisterCallbacks */
> /* [x] tmdlHdmiTxEnableEvent */
> /* [x] tmdlHdmiTxDisableEvent */
> /* [x] tmdlHdmiTxGetVideoFormatSpecs */
> /* [x] tmdlHdmiTxSetInputOutput */
> /* [x] tmdlHdmiTxSetAudioInput */
> /* [x] tmdlHdmiTxSetVideoInfoframe */
> /* [x] tmdlHdmiTxSetAudioInfoframe */
> /* [x] tmdlHdmiTxSetACPPacket */
> /* [x] tmdlHdmiTxSetGeneralControlPacket */
> /* [x] tmdlHdmiTxSetISRC1Packet */
> /* [x] tmdlHdmiTxSetISRC2Packet */
> /* [x] tmdlHdmiTxSetMPSInfoframe */
> /* [x] tmdlHdmiTxSetSpdInfoframe */
> /* [x] tmdlHdmiTxSetVsInfoframe */
> /* [ ] tmdlHdmiTxDebugSetNullPacket */
> /* [ ] tmdlHdmiTxDebugSetSingleNullPacket */
> /* [x] tmdlHdmiTxSetAudioMute */
> /* [x] tmdlHdmiTxResetAudioCts */
> /* [x] tmdlHdmiTxGetEdidStatus */
> /* [x] tmdlHdmiTxGetEdidAudioCaps */
> /* [x] tmdlHdmiTxGetEdidVideoCaps */
> /* [x] tmdlHdmiTxGetEdidVideoPreferred */
> /* [x] tmdlHdmiTxGetEdidSinkType */
> /* [x] tmdlHdmiTxGetEdidSourceAddress */
> /* [ ] tmdlHdmiTxGetKsvList */
> /* [ ] tmdlHdmiTxGetDepth */
> /* [ ] tmdlHdmiTxGeneSHA_1_IT */
> /* [ ] tmdlHdmiTxSetHdcp */
> /* [ ] tmdlHdmiTxGetHdcpState */
> /* [ ] tmdlHdmiTxHdcpCheck */
> /* [x] tmdlHdmiTxSetGamutPacket */
> /* [x] tmdlHdmiTxGetEdidDetailledTimingDescriptors */
> /* [x] tmdlHdmiTxGetEdidMonitorDescriptors */
> /* [x] tmdlHdmiTxGetEdidTVPictureRatio */
> /* [ ] tmdlHdmiTxSetHDCPRevocationList */
> /* [ ] tmdlHdmiTxGetHdcpFailStatus */
> /* [x] tmdlHdmiTxGetEdidLatencyInfo */
> /* [ ] tmdlHdmiTxSetBScreen */
> /* [ ] tmdlHdmiTxRemoveBScreen */
> 
> 
> #endif /* __tx_h__ */
> #endif /* __tx_ioctl__ */
> 
> #ifndef __cec_ioctl__
> #define __cec_ioctl__
> 
> #ifdef __cec_h__
> 
> typedef struct {
>    UInt8 DayOfMonth;
>    UInt8 MonthOfYear;
>    UInt16 StartTime;
>    tmdlHdmiCECDuration_t Duration;
>    UInt8 RecordingSequence;
>    tmdlHdmiCECAnalogueBroadcastType_t AnalogueBroadcastType;
>    UInt16 AnalogueFrequency;
>    tmdlHdmiCECBroadcastSystem_t BroadcastSystem;
> } cec_analogue_timer;
> 
> typedef struct {
>    UInt8 DayOfMonth;
>    UInt8 MonthOfYear;
>    UInt16 StartTime;
>    tmdlHdmiCECDuration_t Duration;
>    UInt8 RecordingSequence;
>    tmdlHdmiCECDigitalServiceIdentification_t ServiceIdentification;
> } cec_digital_timer;
> 
> typedef struct {
>    UInt8 DayOfMonth;
>    UInt8 MonthOfYear;
>    UInt16 StartTime;
>    tmdlHdmiCECDuration_t Duration;
>    UInt8 RecordingSequence;
>    tmdlHdmiCECExternalPlug_t ExternalPlug;
> } cec_ext_timer_with_ext_plug;
> 
> typedef struct {
>    UInt8 DayOfMonth;
>    UInt8 MonthOfYear;
>    UInt16 StartTime;
>    tmdlHdmiCECDuration_t Duration;
>    UInt8 RecordingSequence;
>    tmdlHdmiCECExternalPhysicalAddress_t ExternalPhysicalAddress;
> } cec_ext_timer_with_phy_addr;
> 
> typedef struct {
>    tmdlHdmiCECFeatureOpcode_t FeatureOpcode;
>    tmdlHdmiCECAbortReason_t AbortReason;
> } cec_feature_abort;
> 
> typedef struct {
>    tmdlHdmiCECAnalogueBroadcastType_t AnalogueBroadcastType;
>    UInt16 AnalogueFrequency;
>    tmdlHdmiCECBroadcastSystem_t BroadcastSystem;
> } cec_analogue_service;
> 
> typedef struct {
>    UInt16 OriginalAddress;
>    UInt16 NewAddress;
> } cec_routing_change;
> 
> typedef struct {
>    char data[15];
>    unsigned char length;
> } cec_string;
> 
> typedef struct {
>    tmdlHdmiCECDisplayControl_t DisplayControl;
>    char data[15];
>    unsigned char length;
> } cec_osd_string;
> 
> typedef struct {
>    tmdlHdmiCECRecordingFlag_t RecordingFlag;
>    tmdlHdmiCECTunerDisplayInfo_t TunerDisplayInfo;
>    tmdlHdmiCECAnalogueBroadcastType_t AnalogueBroadcastType;
>    UInt16 AnalogueFrequency;
>    tmdlHdmiCECBroadcastSystem_t BroadcastSystem;
> } cec_tuner_device_status_analogue;
> 
> typedef struct {
>    tmdlHdmiCECRecordingFlag_t RecordingFlag;
>    tmdlHdmiCECTunerDisplayInfo_t TunerDisplayInfo;
>    tmdlHdmiCECDigitalServiceIdentification_t ServiceIdentification;
> } cec_tuner_device_status_digital;
> 
> typedef struct {
>    unsigned long VendorID;
>    cec_string cmd;
> } cec_vendor_command_with_id;
> 
> /*
>   typedef struct {
>   UInt8 *pData;
>   UInt16 lenData;
>   } cec_send_msg;
> */
> 
> typedef struct
> {
>    unsigned char count;
>    unsigned char service;
>    unsigned char addr;
>    unsigned char data[15];
> } cec_frame;
> /* typedef tmdlHdmiCecFrameFormat_t cec_frame; */
> 
> typedef tmSWVersion_t cec_sw_version;
> typedef tmPowerState_t cec_power;
> typedef tmdlHdmiCecInstanceSetup_t cec_setup;
> typedef tmdlHdmiCecEvent_t cec_event;
> typedef tmdlHdmiCecClockSource_t cec_clock;
> typedef tmdlHdmiCECSystemAudioStatus_t cec_sys_audio_status;
> typedef tmdlHdmiCECAudioRate_t cec_audio_rate;
> typedef tmdlHdmiCECDigitalServiceIdentification_t cec_digital_service;
> typedef tmdlHdmiCECVersion_t cec_version;
> typedef tmdlHdmiCECDecControlMode_t cec_deck_ctrl;
> typedef tmdlHdmiCECDecInfo_t cec_deck_status;
> typedef tmdlHdmiCECStatusRequest_t cec_status_request;
> typedef tmdlHdmiCECMenuRequestType_t cec_menu_request;
> typedef tmdlHdmiCECMenuState_t cec_menu_status;
> typedef tmdlHdmiCECPlayMode_t cec_play;
> typedef tmdlHdmiCECExternalPlug_t cec_ext_plug;
> typedef tmdlHdmiCECRecordStatusInfo_t cec_rec_status;
> typedef tmdlHdmiCECAudioStatus_t cec_audio_status;
> typedef tmdlHdmiCECPowerStatus_t cec_power_status;
> typedef tmdlHdmiCECTimerClearedStatusData_t cec_timer_cleared_status;
> typedef tmdlHdmiCECTimerStatusData_t cec_timer_status;
> typedef tmdlHdmiCECUserRemoteControlCommand_t cec_user_ctrl;
> typedef tmdlHdmiCECChannelIdentifier_t cec_user_ctrl_tune;
> typedef tmdlHdmiCECDeviceType_t cec_device_type;
> 
> #define CEC_IOCTL_BASE 0x40
> 
> /* service */
> enum {
>    CEC_WAITING = 0x80,
>    CEC_RELEASE,
>    CEC_RX_DONE,
>    CEC_TX_DONE
> };
> 
> enum {
>    /* driver specific */
>    CEC_VERBOSE_ON_CMD = 0,
>    CEC_VERBOSE_OFF_CMD,
>    CEC_BYEBYE_CMD,
> 
>    /* CEC */
>    CEC_IOCTL_RX_ADDR_CMD, /* receiver logical address selector */
>    CEC_IOCTL_PHY_ADDR_CMD, /* physical address selector */
>    CEC_IOCTL_WAIT_FRAME_CMD,
>    CEC_IOCTL_ABORT_MSG_CMD,
>    CEC_IOCTL_ACTIVE_SRC_CMD,
>    CEC_IOCTL_VERSION_CMD,
>    CEC_IOCTL_CLEAR_ANALOGUE_TIMER_CMD,
>    CEC_IOCTL_CLEAR_DIGITAL_TIMER_CMD,
>    CEC_IOCTL_CLEAR_EXT_TIMER_WITH_EXT_PLUG_CMD,
>    CEC_IOCTL_CLEAR_EXT_TIMER_WITH_PHY_ADDR_CMD,
>    CEC_IOCTL_DECK_CTRL_CMD,
>    CEC_IOCTL_DECK_STATUS_CMD,
>    CEC_IOCTL_DEVICE_VENDOR_ID_CMD,
>    CEC_IOCTL_FEATURE_ABORT_CMD,
>    CEC_IOCTL_GET_CEC_VERSION_CMD,
>    CEC_IOCTL_GET_MENU_LANGUAGE_CMD,
>    CEC_IOCTL_GIVE_AUDIO_STATUS_CMD,
>    CEC_IOCTL_GIVE_DECK_STATUS_CMD,
>    CEC_IOCTL_GIVE_DEVICE_POWER_STATUS_CMD,
>    CEC_IOCTL_GIVE_DEVICE_VENDOR_ID_CMD,
>    CEC_IOCTL_GIVE_OSD_NAME_CMD,
>    CEC_IOCTL_GIVE_PHY_ADDR_CMD,
>    CEC_IOCTL_GIVE_SYS_AUDIO_MODE_STATUS_CMD,
>    CEC_IOCTL_GIVE_TUNER_DEVICE_STATUS_CMD,
>    CEC_IOCTL_IMAGE_VIEW_ON_CMD,
>    CEC_IOCTL_INACTIVE_SRC_CMD,
>    CEC_IOCTL_MENU_REQUEST_CMD,
>    CEC_IOCTL_MENU_STATUS_CMD,
>    CEC_IOCTL_PLAY_CMD,
>    CEC_IOCTL_POLLING_MSG_CMD,
>    CEC_IOCTL_REC_OFF_CMD,
>    CEC_IOCTL_REC_ON_ANALOGUE_SERVICE_CMD,
>    CEC_IOCTL_REC_ON_DIGITAL_SERVICE_CMD,
>    CEC_IOCTL_REC_ON_EXT_PHY_ADDR_CMD,
>    CEC_IOCTL_REC_ON_EXT_PLUG_CMD,
>    CEC_IOCTL_REC_ON_OWN_SRC_CMD,
>    CEC_IOCTL_REC_STATUS_CMD,
>    CEC_IOCTL_REC_TV_SCREEN_CMD,
>    CEC_IOCTL_REPORT_AUDIO_STATUS_CMD,
>    CEC_IOCTL_REPORT_PHY_ADDR_CMD,
>    CEC_IOCTL_REPORT_POWER_STATUS_CMD,
>    CEC_IOCTL_REQUEST_ACTIVE_SRC_CMD,
>    CEC_IOCTL_ROUTING_CHANGE_CMD,
>    CEC_IOCTL_ROUTING_INFORMATION_CMD,
>    CEC_IOCTL_SELECT_ANALOGUE_SERVICE_CMD,
>    CEC_IOCTL_SELECT_DIGITAL_SERVICE_CMD,
>    CEC_IOCTL_SET_ANALOGUE_TIMER_CMD,
>    CEC_IOCTL_SET_AUDIO_RATE_CMD,
>    CEC_IOCTL_SET_DIGITAL_TIMER_CMD,
>    CEC_IOCTL_SET_EXT_TIMER_WITH_EXT_PLUG_CMD,
>    CEC_IOCTL_SET_EXT_TIMER_WITH_PHY_ADDR_CMD,
>    CEC_IOCTL_SET_MENU_LANGUAGE_CMD,
>    CEC_IOCTL_SET_OSD_NAME_CMD,
>    CEC_IOCTL_SET_OSD_STRING_CMD,
>    CEC_IOCTL_SET_STREAM_PATH_CMD,
>    CEC_IOCTL_SET_SYS_AUDIO_MODE_CMD,
>    CEC_IOCTL_SET_TIMER_PROGRAM_TITLE_CMD,
>    CEC_IOCTL_STANDBY_CMD,
>    CEC_IOCTL_SYS_AUDIO_MODE_REQUEST_CMD,
>    CEC_IOCTL_SYS_AUDIO_MODE_STATUS_CMD,
>    CEC_IOCTL_TEXT_VIEW_ON_CMD,
>    CEC_IOCTL_TIMER_CLEARED_STATUS_CMD,
>    CEC_IOCTL_TIMER_STATUS_CMD,
>    CEC_IOCTL_TUNER_DEVICE_STATUS_ANALOGUE_CMD,
>    CEC_IOCTL_TUNER_DEVICE_STATUS_DIGITAL_CMD,
>    CEC_IOCTL_TUNER_STEP_DECREMENT_CMD,
>    CEC_IOCTL_TUNER_STEP_INCREMENT_CMD,
>    CEC_IOCTL_USER_CTRL_CMD,
>    CEC_IOCTL_USER_CTRL_PLAY_CMD,
>    CEC_IOCTL_USER_CTRL_SELECT_AUDIOINPUT_CMD,
>    CEC_IOCTL_USER_CTRL_SELECT_AVINPUT_CMD,
>    CEC_IOCTL_USER_CTRL_SELECT_MEDIA_CMD,
>    CEC_IOCTL_USER_CTRL_TUNE_CMD,
>    CEC_IOCTL_USER_CTRL_RELEASED_CMD,
>    CEC_IOCTL_VENDOR_COMMAND_CMD,
>    CEC_IOCTL_VENDOR_COMMAND_WITH_ID_CMD,
>    CEC_IOCTL_VENDOR_REMOTE_BUTTON_DOWN_CMD,
>    CEC_IOCTL_VENDOR_REMOTE_BUTTON_UP_CMD,
>    CEC_IOCTL_GET_SW_VERSION_CMD,
>    CEC_IOCTL_SET_POWER_STATE_CMD,
>    CEC_IOCTL_GET_POWER_STATE_CMD,
>    CEC_IOCTL_INSTANCE_CONFIG_CMD,
>    CEC_IOCTL_INSTANCE_SETUP_CMD,
>    CEC_IOCTL_GET_INSTANCE_SETUP_CMD,
>    CEC_IOCTL_ENABLE_EVENT_CMD,
>    CEC_IOCTL_DISABLE_EVENT_CMD,
>    CEC_IOCTL_ENABLE_CALIBRATION_CMD,
>    CEC_IOCTL_DISABLE_CALIBRATION_CMD,
>    CEC_IOCTL_SEND_MSG_CMD,
>    CEC_IOCTL_SET_REGISTER_CMD
> };
> 
> 
> /* driver specific */
> #define CEC_IOCTL_VERBOSE_ON       _IO(CEC_IOCTL_BASE, CEC_VERBOSE_ON_CMD)
> #define CEC_IOCTL_VERBOSE_OFF      _IO(CEC_IOCTL_BASE, CEC_VERBOSE_OFF_CMD)
> #define CEC_IOCTL_BYEBYE      _IO(CEC_IOCTL_BASE, CEC_BYEBYE_CMD)
> 
> /* CEC */
> #define CEC_IOCTL_RX_ADDR      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_RX_ADDR_CMD,unsigned char)
> #define CEC_IOCTL_PHY_ADDR      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_PHY_ADDR_CMD,unsigned short)
> #define CEC_IOCTL_WAIT_FRAME      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_WAIT_FRAME_CMD,cec_frame)
> #define CEC_IOCTL_ABORT_MSG      _IO(CEC_IOCTL_BASE,CEC_IOCTL_ABORT_MSG_CMD)
> #define CEC_IOCTL_ACTIVE_SRC      _IO(CEC_IOCTL_BASE,CEC_IOCTL_ACTIVE_SRC_CMD)
> #define CEC_IOCTL_VERSION      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_VERSION_CMD,cec_version)
> #define CEC_IOCTL_CLEAR_ANALOGUE_TIMER      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_CLEAR_ANALOGUE_TIMER_CMD,cec_analogue_timer)
> #define CEC_IOCTL_CLEAR_DIGITAL_TIMER      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_CLEAR_DIGITAL_TIMER_CMD,cec_digital_timer)
> #define CEC_IOCTL_CLEAR_EXT_TIMER_WITH_EXT_PLUG      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_CLEAR_EXT_TIMER_WITH_EXT_PLUG_CMD,cec_ext_timer_with_ext_plug)
> #define CEC_IOCTL_CLEAR_EXT_TIMER_WITH_PHY_ADDR      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_CLEAR_EXT_TIMER_WITH_PHY_ADDR_CMD,cec_ext_timer_with_phy_addr)
> #define CEC_IOCTL_DECK_CTRL      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_DECK_CTRL_CMD,cec_deck_ctrl)
> #define CEC_IOCTL_DECK_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_DECK_STATUS_CMD,cec_deck_status)
> #define CEC_IOCTL_DEVICE_VENDOR_ID      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_DEVICE_VENDOR_ID_CMD,unsigned long)
> #define CEC_IOCTL_FEATURE_ABORT      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_FEATURE_ABORT_CMD,cec_feature_abort)
> #define CEC_IOCTL_GET_CEC_VERSION      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_GET_CEC_VERSION_CMD,unsigned char)
> #define CEC_IOCTL_GET_MENU_LANGUAGE      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GET_MENU_LANGUAGE_CMD)
> #define CEC_IOCTL_GIVE_AUDIO_STATUS      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_AUDIO_STATUS_CMD)
> #define CEC_IOCTL_GIVE_DECK_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_DECK_STATUS_CMD,cec_status_request)
> #define CEC_IOCTL_GIVE_DEVICE_POWER_STATUS      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_DEVICE_POWER_STATUS_CMD)
> #define CEC_IOCTL_GIVE_DEVICE_VENDOR_ID      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_DEVICE_VENDOR_ID_CMD)
> #define CEC_IOCTL_GIVE_OSD_NAME      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_OSD_NAME_CMD)
> #define CEC_IOCTL_GIVE_PHY_ADDR      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_PHY_ADDR_CMD)
> #define CEC_IOCTL_GIVE_SYS_AUDIO_MODE_STATUS      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_SYS_AUDIO_MODE_STATUS_CMD)
> #define CEC_IOCTL_GIVE_TUNER_DEVICE_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_TUNER_DEVICE_STATUS_CMD,cec_status_request)
> #define CEC_IOCTL_IMAGE_VIEW_ON      _IO(CEC_IOCTL_BASE,CEC_IOCTL_IMAGE_VIEW_ON_CMD)
> #define CEC_IOCTL_INACTIVE_SRC      _IO(CEC_IOCTL_BASE,CEC_IOCTL_INACTIVE_SRC_CMD)
> #define CEC_IOCTL_MENU_REQUEST      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_MENU_REQUEST_CMD,cec_menu_request)
> #define CEC_IOCTL_MENU_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_MENU_STATUS_CMD,cec_menu_status)
> #define CEC_IOCTL_PLAY      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_PLAY_CMD,cec_play)
> #define CEC_IOCTL_POLLING_MSG      _IO(CEC_IOCTL_BASE,CEC_IOCTL_POLLING_MSG_CMD)
> #define CEC_IOCTL_REC_OFF      _IO(CEC_IOCTL_BASE,CEC_IOCTL_REC_OFF_CMD)
> #define CEC_IOCTL_REC_ON_ANALOGUE_SERVICE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REC_ON_ANALOGUE_SERVICE_CMD,cec_analogue_service)
> #define CEC_IOCTL_REC_ON_DIGITAL_SERVICE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REC_ON_DIGITAL_SERVICE_CMD,cec_digital_service)
> #define CEC_IOCTL_REC_ON_EXT_PHY_ADDR      _IO(CEC_IOCTL_BASE,CEC_IOCTL_REC_ON_EXT_PHY_ADDR_CMD)
> #define CEC_IOCTL_REC_ON_EXT_PLUG      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REC_ON_EXT_PLUG_CMD,cec_ext_plug)
> #define CEC_IOCTL_REC_ON_OWN_SRC      _IO(CEC_IOCTL_BASE,CEC_IOCTL_REC_ON_OWN_SRC_CMD)
> #define CEC_IOCTL_REC_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REC_STATUS_CMD,cec_rec_status)
> #define CEC_IOCTL_REC_TV_SCREEN      _IO(CEC_IOCTL_BASE,CEC_IOCTL_REC_TV_SCREEN_CMD)
> #define CEC_IOCTL_REPORT_AUDIO_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REPORT_AUDIO_STATUS_CMD,cec_audio_status)
> #define CEC_IOCTL_REPORT_PHY_ADDR      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REPORT_PHY_ADDR_CMD,cec_device_type)
> #define CEC_IOCTL_REPORT_POWER_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REPORT_POWER_STATUS_CMD,cec_power_status)
> #define CEC_IOCTL_REQUEST_ACTIVE_SRC      _IO(CEC_IOCTL_BASE,CEC_IOCTL_REQUEST_ACTIVE_SRC_CMD)
> #define CEC_IOCTL_ROUTING_CHANGE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_ROUTING_CHANGE_CMD,cec_routing_change)
> #define CEC_IOCTL_ROUTING_INFORMATION      _IO(CEC_IOCTL_BASE,CEC_IOCTL_ROUTING_INFORMATION_CMD)
> #define CEC_IOCTL_SELECT_ANALOGUE_SERVICE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SELECT_ANALOGUE_SERVICE_CMD,cec_analogue_service)
> #define CEC_IOCTL_SELECT_DIGITAL_SERVICE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SELECT_DIGITAL_SERVICE_CMD,cec_digital_service)
> #define CEC_IOCTL_SET_ANALOGUE_TIMER      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_ANALOGUE_TIMER_CMD,cec_analogue_timer)
> #define CEC_IOCTL_SET_AUDIO_RATE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_AUDIO_RATE_CMD,cec_audio_rate)
> #define CEC_IOCTL_SET_DIGITAL_TIMER      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_DIGITAL_TIMER_CMD,cec_digital_timer)
> #define CEC_IOCTL_SET_EXT_TIMER_WITH_EXT_PLUG      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_EXT_TIMER_WITH_EXT_PLUG_CMD,cec_ext_timer_with_ext_plug)
> #define CEC_IOCTL_SET_EXT_TIMER_WITH_PHY_ADDR      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_EXT_TIMER_WITH_PHY_ADDR_CMD,cec_ext_timer_with_phy_addr)
> #define CEC_IOCTL_SET_MENU_LANGUAGE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_MENU_LANGUAGE_CMD,cec_string)
> #define CEC_IOCTL_SET_OSD_NAME      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_OSD_NAME_CMD,cec_string)
> #define CEC_IOCTL_SET_OSD_STRING      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_OSD_STRING_CMD,cec_osd_string)
> #define CEC_IOCTL_SET_STREAM_PATH      _IO(CEC_IOCTL_BASE,CEC_IOCTL_SET_STREAM_PATH_CMD)
> #define CEC_IOCTL_SET_SYS_AUDIO_MODE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_SYS_AUDIO_MODE_CMD,cec_sys_audio_status)
> #define CEC_IOCTL_SET_TIMER_PROGRAM_TITLE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_TIMER_PROGRAM_TITLE_CMD,cec_string)
> #define CEC_IOCTL_STANDBY      _IO(CEC_IOCTL_BASE,CEC_IOCTL_STANDBY_CMD)
> #define CEC_IOCTL_SYS_AUDIO_MODE_REQUEST      _IO(CEC_IOCTL_BASE,CEC_IOCTL_SYS_AUDIO_MODE_REQUEST_CMD)
> #define CEC_IOCTL_SYS_AUDIO_MODE_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SYS_AUDIO_MODE_STATUS_CMD,cec_sys_audio_status)
> #define CEC_IOCTL_TEXT_VIEW_ON      _IO(CEC_IOCTL_BASE,CEC_IOCTL_TEXT_VIEW_ON_CMD)
> #define CEC_IOCTL_TIMER_CLEARED_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_TIMER_CLEARED_STATUS_CMD,cec_timer_cleared_status)
> #define CEC_IOCTL_TIMER_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_TIMER_STATUS_CMD,cec_timer_status)
> #define CEC_IOCTL_TUNER_DEVICE_STATUS_ANALOGUE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_TUNER_DEVICE_STATUS_ANALOGUE_CMD,cec_tuner_device_status_analogue)
> #define CEC_IOCTL_TUNER_DEVICE_STATUS_DIGITAL      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_TUNER_DEVICE_STATUS_DIGITAL_CMD,cec_tuner_device_status_digital)
> #define CEC_IOCTL_TUNER_STEP_DECREMENT      _IO(CEC_IOCTL_BASE,CEC_IOCTL_TUNER_STEP_DECREMENT_CMD)
> #define CEC_IOCTL_TUNER_STEP_INCREMENT      _IO(CEC_IOCTL_BASE,CEC_IOCTL_TUNER_STEP_INCREMENT_CMD)
> #define CEC_IOCTL_USER_CTRL_PRESSED      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_CMD,cec_user_ctrl)
> #define CEC_IOCTL_USER_CTRL_PLAY      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_PLAY_CMD,cec_play)
> #define CEC_IOCTL_USER_CTRL_SELECT_AUDIOINPUT      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_SELECT_AUDIOINPUT_CMD,unsigned char)
> #define CEC_IOCTL_USER_CTRL_SELECT_AVINPUT      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_SELECT_AVINPUT_CMD,unsigned char)
> #define CEC_IOCTL_USER_CTRL_SELECT_MEDIA      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_SELECT_MEDIA_CMD,unsigned char)
> #define CEC_IOCTL_USER_CTRL_TUNE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_TUNE_CMD,cec_user_ctrl_tune)
> #define CEC_IOCTL_USER_CTRL_RELEASED      _IO(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_RELEASED_CMD)
> #define CEC_IOCTL_VENDOR_COMMAND      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_VENDOR_COMMAND_CMD,cec_string)
> #define CEC_IOCTL_VENDOR_COMMAND_WITH_ID      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_VENDOR_COMMAND_WITH_ID_CMD,cec_vendor_command_with_id)
> #define CEC_IOCTL_VENDOR_REMOTE_BUTTON_DOWN      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_VENDOR_REMOTE_BUTTON_DOWN_CMD,cec_string)
> #define CEC_IOCTL_VENDOR_REMOTE_BUTTON_UP      _IO(CEC_IOCTL_BASE,CEC_IOCTL_VENDOR_REMOTE_BUTTON_UP_CMD)
> #define CEC_IOCTL_GET_SW_VERSION      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_GET_SW_VERSION_CMD,cec_sw_version)
> #define CEC_IOCTL_SET_POWER_STATE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_POWER_STATE_CMD,cec_power)
> #define CEC_IOCTL_GET_POWER_STATE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_GET_POWER_STATE_CMD,cec_power)
> #define CEC_IOCTL_INSTANCE_CONFIG      _IO(CEC_IOCTL_BASE,CEC_IOCTL_INSTANCE_CONFIG_CMD)
> #define CEC_IOCTL_INSTANCE_SETUP      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_INSTANCE_SETUP_CMD,cec_setup)
> #define CEC_IOCTL_GET_INSTANCE_SETUP      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_GET_INSTANCE_SETUP_CMD,cec_setup)
> #define CEC_IOCTL_ENABLE_EVENT      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_ENABLE_EVENT_CMD,cec_event)
> #define CEC_IOCTL_DISABLE_EVENT      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_DISABLE_EVENT_CMD,cec_event)
> #define CEC_IOCTL_ENABLE_CALIBRATION      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_ENABLE_CALIBRATION_CMD,cec_clock)
> #define CEC_IOCTL_DISABLE_CALIBRATION      _IO(CEC_IOCTL_BASE,CEC_IOCTL_DISABLE_CALIBRATION_CMD)
> //#define CEC_IOCTL_SEND_MSG      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SEND_MSG_CMD,cec_send_msg)
> 
> /* --- Full list --- */
> 
> /* legend: */
> /* ------- */
> /* [ ] : not supported */
> /* [x] : IOCTL */
> /* [i] : open, init... */
> 
> /* [ ] tmdlHdmiCecAbortMessage */
> /* [ ] tmdlHdmiCecActiveSource */
> /* [ ] tmdlHdmiCecVersion */
> /* [ ] tmdlHdmiCecClearAnalogueTimer */
> /* [ ] tmdlHdmiCecClearDigitalTimer */
> /* [ ] tmdlHdmiCecClearExternalTimerWithExternalPlug */
> /* [ ] tmdlHdmiCecClearExternalTimerWithPhysicalAddress */
> /* [ ] tmdlHdmiCecDeckControl */
> /* [ ] tmdlHdmiCecDeckStatus */
> /* [ ] tmdlHdmiCecDeviceVendorID */
> /* [ ] tmdlHdmiCecFeatureAbort */
> /* [ ] tmdlHdmiCecGetCecVersion */
> /* [ ] tmdlHdmiCecGetMenuLanguage */
> /* [ ] tmdlHdmiCecGiveAudioStatus */
> /* [ ] tmdlHdmiCecGiveDeckStatus */
> /* [ ] tmdlHdmiCecGiveDevicePowerStatus */
> /* [ ] tmdlHdmiCecGiveDeviceVendorID */
> /* [ ] tmdlHdmiCecGiveOsdName */
> /* [ ] tmdlHdmiCecGivePhysicalAddress */
> /* [ ] tmdlHdmiCecGiveSystemAudioModeStatus */
> /* [ ] tmdlHdmiCecGiveTunerDeviceStatus */
> /* [ ] tmdlHdmiCecImageViewOn */
> /* [ ] tmdlHdmiCecInactiveSource */
> /* [ ] tmdlHdmiCecMenuRequest */
> /* [ ] tmdlHdmiCecMenuStatus */
> /* [ ] tmdlHdmiCecPlay */
> /* [ ] tmdlHdmiCecPollingMessage */
> /* [ ] tmdlHdmiCecRecordOff */
> /* [ ] tmdlHdmiCecRecordOnAnalogueService */
> /* [ ] tmdlHdmiCecRecordOnDigitalService */
> /* [ ] tmdlHdmiCecRecordOnExternalPhysicalAddress */
> /* [ ] tmdlHdmiCecRecordOnExternalPlug */
> /* [ ] tmdlHdmiCecRecordOnOwnSource */
> /* [ ] tmdlHdmiCecRecordStatus */
> /* [ ] tmdlHdmiCecRecordTvScreen */
> /* [ ] tmdlHdmiCecReportAudioStatus */
> /* [ ] tmdlHdmiCecReportPhysicalAddress */
> /* [ ] tmdlHdmiCecReportPowerStatus */
> /* [ ] tmdlHdmiCecRequestActiveSource */
> /* [ ] tmdlHdmiCecRoutingChange */
> /* [ ] tmdlHdmiCecRoutingInformation */
> /* [ ] tmdlHdmiCecSelectAnalogueService */
> /* [ ] tmdlHdmiCecSelectDigitalService */
> /* [ ] tmdlHdmiCecSetAnalogueTimer */
> /* [ ] tmdlHdmiCecSetAudioRate */
> /* [ ] tmdlHdmiCecSetDigitalTimer */
> /* [ ] tmdlHdmiCecSetExternalTimerWithExternalPlug */
> /* [ ] tmdlHdmiCecSetExternalTimerWithPhysicalAddress */
> /* [ ] tmdlHdmiCecSetMenuLanguage */
> /* [ ] tmdlHdmiCecSetOsdName */
> /* [ ] tmdlHdmiCecSetOsdString */
> /* [ ] tmdlHdmiCecSetStreamPath */
> /* [ ] tmdlHdmiCecSetSystemAudioMode */
> /* [ ] tmdlHdmiCecSetTimerProgramTitle */
> /* [ ] tmdlHdmiCecStandby */
> /* [ ] tmdlHdmiCecSystemAudioModeRequest */
> /* [ ] tmdlHdmiCecSystemAudioModeStatus */
> /* [ ] tmdlHdmiCecTextViewOn */
> /* [ ] tmdlHdmiCecTimerClearedStatus */
> /* [ ] tmdlHdmiCecTimerStatus */
> /* [ ] tmdlHdmiCecTunerDeviceStatusAnalogue */
> /* [ ] tmdlHdmiCecTunerDeviceStatusDigital */
> /* [ ] tmdlHdmiCecTunerStepDecrement */
> /* [ ] tmdlHdmiCecTunerStepIncrement */
> /* [ ] tmdlHdmiCecUserControlPressed */
> /* [ ] tmdlHdmiCecUserControlPressedPlay */
> /* [ ] tmdlHdmiCecUserControlPressedSelectAudioInput */
> /* [ ] tmdlHdmiCecUserControlPressedSelectAVInput */
> /* [ ] tmdlHdmiCecUserControlPressedSelectMedia */
> /* [ ] tmdlHdmiCecUserControlPressedTune */
> /* [ ] tmdlHdmiCecUserControlReleased */
> /* [ ] tmdlHdmiCecVendorCommand */
> /* [ ] tmdlHdmiCecVendorCommandWithID */
> /* [ ] tmdlHdmiCecVendorRemoteButtonDown */
> /* [ ] tmdlHdmiCecVendorRemoteButtonUp */
> /* [ ] tmdlHdmiCecGetSWVersion */
> /* [ ] tmdlHdmiCecGetNumberOfUnits */
> /* [ ] tmdlHdmiCecGetCapabilities */
> /* [ ] tmdlHdmiCecGetCapabilitiesM */
> /* [ ] tmdlHdmiCecOpen */
> /* [ ] tmdlHdmiCecOpenM */
> /* [ ] tmdlHdmiCecClose */
> /* [ ] tmdlHdmiCecSetPowerState */
> /* [ ] tmdlHdmiCecGetPowerState */
> /* [ ] tmdlHdmiCecInstanceConfig */
> /* [ ] tmdlHdmiCecInstanceSetup */
> /* [ ] tmdlHdmiCecGetInstanceSetup */
> /* [ ] tmdlHdmiCecHandleInterrupt */
> /* [ ] tmdlHdmiCecRegisterCallbacks */
> /* [ ] tmdlHdmiCecSetAutoAnswer */
> /* [ ] tmdlHdmiCecSetLogicalAddress */
> /* [ ] tmdlHdmiCecEnableEvent */
> /* [ ] tmdlHdmiCecDisableEvent */
> /* [ ] tmdlHdmiCecEnableCalibration */
> /* [ ] tmdlHdmiCecDisableCalibration */
> /* [ ] tmdlHdmiCecSendMessage */
> /* [ ] tmdlHdmiCecSetRegister */
> 
> 
> #endif /* __cec_h__ */
> #endif /* __cec_ioctl__ */
diff ./tda998x_version.h /home/jaeseong.gim/android/kernel/drivers/video/hdmi/tda998x_version.h
1,16c1,16
< #ifndef __tda_version__
< #define __tda_version__
< 
< /* version */
< #define TDA_VERSION_MAJOR	1
< #define TDA_VERSION_MINOR	0
< #define TDA_VERSION_PATCHLEVEL 0
< #define TDA_VERSION_EXTRA	"-ioctl (2009-10-15)"
< 
< /* TDA TX chip list */
< #define TDA19989 "tda19989"
< #define TDA9984  "tda9984"
< #define TDA9983  "tda9983"
< #define TDA9981  "tda9981"
< 
< #endif
---
> #ifndef __tda_version__
> #define __tda_version__
> 
> /* version */
> #define TDA_VERSION_MAJOR	0
> #define TDA_VERSION_MINOR	964
> #define TDA_VERSION_PATCHLEVEL 0
> #define TDA_VERSION_EXTRA	"-ioctl (2009-10-15)"
> 
> /* TDA TX chip list */
> #define TDA19989 "tda19989"
> #define TDA9984  "tda9984"
> #define TDA9983  "tda9983"
> #define TDA9981  "tda9981"
> 
> #endif
Common subdirectories: ./test and /home/jaeseong.gim/android/kernel/drivers/video/hdmi/test
Only in .: tmp
